.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GO::Node 3"
.TH GO::Node 3 "2007-11-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GO::Node \- provides information about a node in the Gene Ontology
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The GO::Node package is intended to be used as a container for
information about a node in one of the three Gene Ontologies.  It
allows the storage of the goid, and immediate parents and children, as
well as paths to the top of the ontology.  This package provides
methods to both store and retrieve that information.
.PP
It should be strongly noted that clients are not expected to create
individual Node objects themselves, but instead should rely in a Node
Factory to create nodes and return them.  Such a factory would be a
concrete subclass of the abstract GO::OntologyProvider package.
.SH "TODO"
.IX Header "TODO"
The following items needs to be done at some point to make the Node
class more flexible, and for it to better model the data.
.PP
.Vb 1
\&    Add in methods to deal with secondary GOIDs
\&
\&    Add in methods to allow definitions to be associated with, and
\&    retrieved from Nodes.
\&
\&    Add in methods to allow dbxrefs to be included.
\&
\&    Not require Factories to add the paths to the root, but instead
\&    have this class generate those paths from the inherent structure
\&    of the graph in which the Nodes sit.  This will also be useful to
\&    generate paths to leaves/descendants.
.Ve
.SH "Protected Methods"
.IX Header "Protected Methods"
.SS "_handleMissingArgument"
.IX Subsection "_handleMissingArgument"
This protected method simply provides a simple way for concrete
subclasses to deal with missing arguments from method calls.  It will
die with an appropriate error message.
.PP
Usage:
.PP
.Vb 1
\&    $self\->_handleMissingArgument(argument=>\*(Aqblah\*(Aq);
.Ve
.SH "Instance Constructor"
.IX Header "Instance Constructor"
.SS "new"
.IX Subsection "new"
This is the constructor for the Node object At a minimum, the
constructor expects, as named arguments, a \s-1GOID\s0 and a \s-1GO\s0 term, with
which to create the node object.
.PP
Usage:
.PP
.Vb 2
\&    my $node = GO::Node\->new(goid => $goid,
\&                             term => $term);
.Ve
.SH "Instance Methods"
.IX Header "Instance Methods"
.SS "addChildNodes"
.IX Subsection "addChildNodes"
The public setter method allows a client to indicate that an array of
nodes are children of the 'self' node.  Only one node per child goid
will get stored.
.PP
Usage:
.PP
.Vb 1
\&    $node\->addChildNodes(@childNodes);
.Ve
.SS "addParentNodes"
.IX Subsection "addParentNodes"
The public setter method allows a client to indicate that an array of
nodes are parents of the 'self' node.  Only one node per parent goid
will get stored.
.PP
Usage:
.PP
.Vb 1
\&    $node\->addParentNodes(@parentNodes);
.Ve
.SS "addPathToRoot"
.IX Subsection "addPathToRoot"
This public setter method expects an array of nodes, that indicates a
direct path to the root of the ontology.  The array should not contain
the self node, but should contain the root node.  The last entry in
the array is expected to be an immediate parent of the self node,
while the first entry is expected to be the root node itself.  This
method will \s-1NOT\s0 check to see if the supplied path has not already been
added.  It is the Node Factory's responsibility to only add a unique
path once.  Furthermore, it will not check whether there is
consistency between addedPaths and addedParents (this can be done
using the isValid method though).
.PP
Usage:
.PP
.Vb 1
\&    $node\->addPathToRoot(@nodes);
.Ve
.SS "goid"
.IX Subsection "goid"
This public method returns the goid associated with the node.
.PP
Usage:
.PP
.Vb 1
\&    my $goid = $node\->goid;
.Ve
.SS "term"
.IX Subsection "term"
This public method returns the term associated with the node.
.PP
Usage:
.PP
.Vb 1
\&    my $goid = $node\->term;
.Ve
.SS "childNodes"
.IX Subsection "childNodes"
This public method returns an array of child nodes for the self node.
.PP
Usage:
.PP
.Vb 1
\&    my @childNodes = $node\->childNodes;
.Ve
.SS "parentNodes"
.IX Subsection "parentNodes"
This public method returns an array of parent nodes for the self node.
.PP
Usage:
.PP
.Vb 1
\&    my @parentNodes = $node\->parentNodes;
.Ve
.SS "pathsToRoot"
.IX Subsection "pathsToRoot"
This public method returns an array of references to arrays, each of
which contains the nodes in a path between the self node and the root.
The self node is not included in the paths, but the root node is.  The
first node in each array is the most distant ancestor (the root), the
last node is an immediate parent.  If there are no paths to the root
(i.e. it is the root node) then an empty array will be returned.
.PP
Usage:
.PP
.Vb 1
\&    my @pathsToRoot = $node\->pathsToRoot;
.Ve
.SS "pathsToAncestor"
.IX Subsection "pathsToAncestor"
This public method returns an array of references to arrays, each of
which contains the nodes in a path between the self node and the
specified ancestor.  The self node is not included paths, but the
specified ancestor node is.  The first node in each array is the
specified ancestor, the last node is an immediate parent.  If there
are no paths to the ancestor then an empty array will be returned.
.PP
Usage:
.PP
.Vb 1
\&    my @pathsToAncestor = $node\->pathsToAncestor($ancestorNode);
.Ve
.SS "ancestors"
.IX Subsection "ancestors"
This public method returns an array of unique GO::Nodes which are
the unique ancestors that a node has.  These ancestors will be derived
from the paths to the root node that have been added to the node.
.PP
Usage:
.PP
.Vb 1
\&    my @ancestors = $node\->ancestors;
.Ve
.SS "lengthOfLongestPathToRoot"
.IX Subsection "lengthOfLongestPathToRoot"
This public method returns the length of the longest path to the root
of the ontology from the node.  If the node is in fact the root, then
a value of zero will be returned.
.PP
Usage:
.PP
.Vb 1
\&    my $length = $node\->lengthOfLongestPathToRoot;
.Ve
.SS "lengthOfShortestPathToRoot"
.IX Subsection "lengthOfShortestPathToRoot"
This public method returns the length of the shortest path to the
root of the ontology from the node.  If the node is in fact the root,
then a value of zero will be returned.
.PP
Usage:
.PP
.Vb 1
\&    my $length = $node\->lengthOfShortestPathToRoot;
.Ve
.SS "meanLengthOfPathsToRoot"
.IX Subsection "meanLengthOfPathsToRoot"
This public method returns the mean length of all paths to the
root node.  If the node is in fact the root, then a value of zero
will be returned.
.PP
Usage:
.PP
.Vb 1
\&    my $length = $node\->meanLengthOfPathsToRoot;
.Ve
.SS "isValid"
.IX Subsection "isValid"
This method can be used to check that a node has been constructed
correctly.  It checks that it is a child of all its parents, and a
parent of all of its children.  In addition, it checks that parents
exist as the most recent ancestors of the node in its paths to the
root node, and vice versa.  It returns a boolean.
.PP
Usage:
.PP
.Vb 1
\&    if ($node\->isValid){
\&
\&        # do something
\&
\&    }
.Ve
.SS "isAParentOf"
.IX Subsection "isAParentOf"
This public method returns a boolean to indicate whether a node has
the supplied node as a child.
.PP
Usage :
.PP
.Vb 1
\&    if ($node\->isAParentOf($anotherNode)){
\&    
\&        # blah
\&
\&    }
.Ve
.SS "isAChildOf"
.IX Subsection "isAChildOf"
This public method returns a boolean to indicate whether a node
has the supplied node as a parent.
.PP
Usage :
.PP
.Vb 1
\&    if ($node\->isAChildOf($anotherNode)){
\&    
\&        # blah
\&
\&    }
.Ve
.SS "isAnAncestorOf"
.IX Subsection "isAnAncestorOf"
This method returns a boolean to indicate whether a node is an
ancestor of another.
.PP
Usage:
.PP
.Vb 1
\&    if ($node\->isAnAncestorOf($anotherNode)){
\&
\&        # blah
\&
\&    }
.Ve
.SS "isADescendantOf"
.IX Subsection "isADescendantOf"
This method returns a boolean to indicate whether a node is a
descendant of another.
.PP
Usage:
.PP
.Vb 1
\&    if ($node\->isADescendantOf($anotherNode)){
\&
\&        # blah
\&
\&    }
.Ve
.SS "isLeaf"
.IX Subsection "isLeaf"
This method returns a boolean to indicate whether a node is a leaf
in the ontology (i.e. it has no children).
.PP
Usage:
.PP
.Vb 1
\&    if ($node\->isLeaf){
\&    
\&        # blah  
\&
\&    }
.Ve
.SS "isRoot"
.IX Subsection "isRoot"
This method returns a boolean to indicate whether a node is the root
in the ontology (i.e. it has no parents).
.PP
Usage:
.PP
.Vb 1
\&    if ($node\->isRoot){
\&
\&        # blah  
\&
\&    }
.Ve
.SH "Authors"
.IX Header "Authors"
.Vb 1
\&    Gavin Sherlock; sherlock@genome.stanford.edu
.Ve
