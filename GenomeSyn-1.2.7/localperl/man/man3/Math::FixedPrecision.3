.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FixedPrecision 3"
.TH FixedPrecision 3 "2002-05-25" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::FixedPrecision \- Decimal Math without Floating Point Errors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Math::FixedPrecision;
\&\f(CW$height\fR  = Math::FixedPrecision\->new(12.362);   # 3 decimal places
\&\f(CW$width\fR   = Math::FixedPrecision\->new(9.65);     # 2 decimal places
\&\f(CW$area\fR    = \f(CW$height\fR * \f(CW$width\fR; # area is now 119.29 not 119.2933
\&\f(CW$length\fR  = Math::FixedPrecision\->new(\*(L"100.00\*(R"); # 2 decimal places
\&\f(CW$section\fR = \f(CW$length\fR / 9; # section is now 11.11 not 11.1111111...
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
There are numerous instances where floating point math is unsuitable, yet the
data does not consist solely of integers.  This module employs new features
in Math::BigFloat to automatically maintain precision during math operations.
This is a convenience module, since all of the operations are handled by
Math::BigFloat internally.  You could do everything this module does by
setting some attributes in Math::BigFloat.  This module simplifies that
task by assuming that if you specify a given number of decimal places in
the call to \fInew()\fR then that should be the precision for that object going
forward.
.PP
Please examine assumptions you are operating under before deciding between this
module and Math::BigFloat.  With this module the assumption is that your data
is not very accurate and you do not want to overstate any resulting values;
Math::BigFloat can unintentially inflate the apparent accuracy of a calculation.
.SS "new(number[,precision])"
.IX Subsection "new(number[,precision])"
The constructor accepts either a number or a string that looks like a number.
But if you want to enforce a specific precision, you either need to pass an
exact string or include the second term.  In other words, all of the following
variables have different precisions:
.PP
.Vb 6
\&  $var1 = Math::FixedPrecision\->new(10);
\&          # 10 to infinite decimals
\&  $var2 = Math::FixedPrecision\->new(10,2);
\&          # 10.00 to 2 decimals
\&  $var3 = Math::FixedPrecision\->new("10.000");
\&          # 10.000 to 3 decimals
.Ve
.PP
All calculations will return a value rounded to the level of precision of
the least precise datum.  A number which looks like an integer (like \f(CW$var1\fR
above) has infinite precision (no decimal places).  This is important to note
since Perl will happily truncate all trailing zeros from a number like 10.000
and the code will get 10 no matter how many zeros you typed.  If you need to
assert a specific precision, you need to either explicitly state that like
\&\f(CW$var2\fR above, or quote the number like \f(CW$var3\fR.  For example:
.PP
.Vb 5
\&  $var4 = $var3 * 2; # 20.000 to 3 decimals
\&  $var5 = Math::FixedPrecision\->new("2.00");
\&          # 2.00 to 2 decimals
\&  $var6 = $var3 * $var 5;
\&          # 20.00 to 2 decimals, not 3
.Ve
.SS "\s-1EXPORT\s0 None by default."
.IX Subsection "EXPORT None by default."
.SH "AUTHOR"
.IX Header "AUTHOR"
John Peacock <jpeacock@rowman.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigFloat
