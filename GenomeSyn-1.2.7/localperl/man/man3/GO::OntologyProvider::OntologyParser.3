.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GO::OntologyProvider::OntologyParser 3"
.TH GO::OntologyProvider::OntologyParser 3 "2007-03-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GO::OntologyProvider::OntologyParser \- Provides API for retrieving data from Gene Ontology files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use GO::OntologyProvider::OntologyParser;
\&
\&    my $ontology = GO::OntologyProvider::OntologyParser\->new(ontologyFile => "process.ontology");
\&
\&    print "The ancestors of GO:0006177 are:\en";
\&
\&    my $node = $ontology\->nodeFromId("GO:0006177");
\&
\&    foreach my $ancestor ($node\->ancestors){
\&    
\&        print $ancestor\->goid, " ", $ancestor\->term, "\en";
\&    
\&    }
\&
\&    $ontology\->printOntology();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
GO::OntologyProvider::OntologyParser implements the interface
defined by GO::OntologyProvider, and parses a gene ontology file
(\s-1GO\s0) in plain text (not \s-1XML\s0) format.  These files can be obtained from
the Gene Ontology Consortium web site, http://www.geneontology.org/.
From the information in the file, it creates a directed acyclic graph
(\s-1DAG\s0) structure in memory.  This means that \s-1GO\s0 terms are arranged into
tree-like structures where each \s-1GO\s0 node can have multiple parent nodes
and multiple child nodes.
.PP
This data structure can be used in conjunction with files in which
certain genes are annotated to corresponding \s-1GO\s0 nodes.
.PP
Each \s-1GO\s0 \s-1ID\s0 (e.g. \*(L"\s-1GO:1234567\s0\*(R") has associated with it a \s-1GO\s0 node.  That
\&\s-1GO\s0 node contains the name of the \s-1GO\s0 term, a list of the nodes directly
above the node (\*(L"parent nodes\*(R"), and a list of the nodes directly
below the current node (\*(L"child nodes\*(R").  The \*(L"ancestor nodes\*(R" of a
certain node are all of the nodes that are in a path from the current
node to the root of the ontology, with all repetitions removed.
.PP
The format of the \s-1GO\s0 file is as follows (taken from
http://www.geneontology.org/doc/GO.doc.html)
.PP
Comment lines:
.PP
Lines that begin ! are comment lines.
.PP
$ lines:
.PP
Line in which the first non-space character is a $ either reflect the
domain and aspect of the ontology (i.e. \f(CW$text\fR) or the end of file
(i.e. the $ character on a line by itself).
.PP
Versioning:
.PP
The first lines of each file after any html header information (in
*.html files) always carry information about the version, the date of
last update, (optionally) the source of the file, the name of the
database, the domain of the file and the editors of the file, e.g.:
.PP
!
!Gene Ontology
![domain of file]
!
!editors: Michael Ashburner (FlyBase), Midori Harris (\s-1GO\s0), Judith Blake (\s-1MGD\s0)
!Leonore Reiser (\s-1TAIR\s0), Karen Christie (\s-1SGD\s0) and colleagues
!with software by Suzanna Lewis (FlyBase Berkeley).
.PP
Syntax:
.PP
Parent-child relationships between terms are represented by
indentation:
.PP
.Vb 2
\&  parent_term
\&   child_term
.Ve
.PP
Instance relationship:
.PP
.Vb 2
\&  %term0
\&   %term1 % term2
.Ve
.PP
To be read as term1 being an instance of term0 and also an instance of
term2. Part of relationship:
.PP
.Vb 2
\&  %term0
\&    %term1 < term2 < term3
.Ve
.PP
To be read as term1 being an instance of term0 and also a part-of of
term2 and term3.
.PP
Line syntax (showing the order in which items appear on a line; *
indicates optional item):
.PP
< | % term [; db cross ref]* [; synonym:text]*  [ < | % term]*
.SH "Instance Constructor"
.IX Header "Instance Constructor"
.SS "new"
.IX Subsection "new"
This is the constructor for an OntologyParser object.  The constructor
expects one of two arguments, either an 'ontologyFile' argument, or an
\&'objectFile' argument.  When instantiated with an ontologyFile
argument, it expects it to correspond to an ontology file created by
the \s-1GO\s0 consortium, according to their file format.  When instantiated
with an objectFile argument, it expects to open a previously created
ontologyParser object that has been serialized to disk (see serializeToDisk).
.PP
Usage:
.PP
.Vb 1
\&    my $ontology = GO::OntologyProvider::OntologyParser\->new(ontologyFile => $ontologyFile);
\&
\&    my $ontology = GO::OntologyProvider::OntologyParser\->new(objectFile   => $objectFile);
.Ve
.SH "Instance Methods"
.IX Header "Instance Methods"
.SS "printOntology"
.IX Subsection "printOntology"
This prints out the ontology, with redundancies, to \s-1STDOUT\s0.  It does
not yet print out all of the ontology information (like relationship
type etc).  This method will be likely be removed in a future version,
so should not be relied upon.
.PP
Usage:
.PP
.Vb 1
\&    $ontologyParser\->printOntology;
.Ve
.SS "allNodes"
.IX Subsection "allNodes"
This method returns an array of all the GO:Nodes that have been
created.
.PP
Usage:
.PP
.Vb 1
\&    my @nodes = $ontologyParser\->allNodes;
.Ve
.SS "rootNode"
.IX Subsection "rootNode"
This returns the root node in the ontology.
.PP
.Vb 1
\&    my $rootNode = $ontologyParser\->rootNode;
.Ve
.SS "nodeFromId"
.IX Subsection "nodeFromId"
This public method takes a \s-1GOID\s0 and returns the GO::Node that
it corresponds to.
.PP
Usage :
.PP
.Vb 1
\&    my $node = $ontologyParser\->nodeFromId($goid);
.Ve
.PP
If the \s-1GOID\s0 does not correspond to a \s-1GO\s0 node, then undef will be
returned.  Note if you try to call any methods on an undef, you will
get a fatal runtime error, so if you can't guarantee all GOIDs that
you supply are good, you should check that the return value from this
method is defined.
.SS "numNodes"
.IX Subsection "numNodes"
This public method returns the number of nodes that exist with the
ontology
.PP
Usage :
.PP
.Vb 1
\&    my $numNodes = $ontologyParser\->numNodes;
.Ve
.SS "serializeToDisk"
.IX Subsection "serializeToDisk"
Saves the current state of the Ontology Parser Object to a file, using
the Storable package.  Saves in network order for portability, just in
case.  Returns the name of the file.  If no filename is provided, then
the name of the file (and its directory, if one was provided) used for
object construction, will be used, with .obj appended.  If the object
was instantiated from a file with a .obj suffix, then the same
filename would be used, if none were provided.
.PP
This method currently causes a segfault on MacOSX (at least 10.1.5 \->
10.2.3), with perl 5.6, and Storable 1.0.14, when trying to store the
process ontology.  This failure occurs using either store, or nstore,
and is manifested by a segmentation fault.  It has not been
investigated whether this is a perl problem, or a Storable problem
(which has large amounts of C\-code).  This does not cause a
segmentation on Solaris, using perl 5.6.1 and Storable 1.0.13.  This
does not make it clear whether it is a MacOSX problem or a perl
problem or not.  It should be noted that newer versions of both perl
and Storable exist, and the code should be tested with those as well.
.PP
Usage:
.PP
.Vb 1
\&    my $objectFile = $ontologyParser\->serializeToDisk(filename=>$filename);
.Ve
.SH "Authors"
.IX Header "Authors"
.Vb 2
\&    Gavin Sherlock; sherlock@genome.stanford.edu
\&    Elizabeth Boyle; ell@mit.edu
.Ve
