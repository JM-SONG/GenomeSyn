.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GO::View::GD 3"
.TH GO::View::GD 3 "2007-03-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GO::View::GD \- a helper class for GO::View to deal with the image
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use GO::View::GD;
.PP
To instantiate a new GO::View::GD object, you may use  
following syntax:
.PP
.Vb 2
\&    my $gd = GO::View::GD\->new(width  => $imgWidth,
\&                               height => $imgHeight);
.Ve
.PP
my \f(CW$im\fR = \f(CW$gd\fR\->im;
my \f(CW$white\fR = \f(CW$gd\fR\->white;
my \f(CW$red\fR = \f(CW$gd\fR\->red;
.PP
and more ......
.SS "new"
.IX Subsection "new"
.Vb 6
\&  Title    : new
\&  Function : Creates a new GO::View::GD object
\&           : recognized named parameters are height and width
\&             both of which must be provided.
\&  Returns  : a GO::View::GD object
\&  Args     : the named parameters
.Ve
.SS "im"
.IX Subsection "im"
This method returns the internal GD::Image object
.SS "height"
.IX Subsection "height"
This method returns the height that was used to instantiate the object
.SS "width"
.IX Subsection "width"
This method returns the width that was used to instantiate the object
.SS "white1 =head2 black"
.IX Subsection "white1 =head2 black"
.SS "blue =head2 blue1 =head2 blue2 =head2 blue3 =head2 blue4 =head2 blue5"
.IX Subsection "blue =head2 blue1 =head2 blue2 =head2 blue3 =head2 blue4 =head2 blue5"
.SS "lightBlue =head2 darkBlue"
.IX Subsection "lightBlue =head2 darkBlue"
.SS "darkGreen =head2 green =head2 green1 =head2 green2 =head2 green3 =head2 green4 =head2 green5"
.IX Subsection "darkGreen =head2 green =head2 green1 =head2 green2 =head2 green3 =head2 green4 =head2 green5"
.SS "grey =head2 darkGrey =head2 lightGrey"
.IX Subsection "grey =head2 darkGrey =head2 lightGrey"
.SS "magenta =head2 magenta1 =head2 magenta2 =head2 magenta3 =head2 magenta4 =head2 magenta5"
.IX Subsection "magenta =head2 magenta1 =head2 magenta2 =head2 magenta3 =head2 magenta4 =head2 magenta5"
.SS "maroon"
.IX Subsection "maroon"
.SS "orange =head2 orange1"
.IX Subsection "orange =head2 orange1"
.SS "red =head2 red1 =head2 red2 =head2 red3 =head2 red4"
.IX Subsection "red =head2 red1 =head2 red2 =head2 red3 =head2 red4"
.SS "tan =head2 tan1"
.IX Subsection "tan =head2 tan1"
.SS "white"
.IX Subsection "white"
.SS "yellow =head2 yellow1 =head2 yellow2 =head2 yellow3"
.IX Subsection "yellow =head2 yellow1 =head2 yellow2 =head2 yellow3"
.SS "chartreuse"
.IX Subsection "chartreuse"
.SS "cenColor"
.IX Subsection "cenColor"
.SS "sagecolor1 =head2 sagecolor2 =head2 sagecolor3 =head2 sagecolor4"
.IX Subsection "sagecolor1 =head2 sagecolor2 =head2 sagecolor3 =head2 sagecolor4"
.SS "drawFrameWithLabelAndDate"
.IX Subsection "drawFrameWithLabelAndDate"
This method draws a blue frame around the image with date at the right
bottom corner and image label on the left bottom corner if there is a
label passed in.  The date and label will be printed in red
.PP
Usage:
.PP
.Vb 1
\&   $gd\->drawFrameWithLabelAndDate;
.Ve
.PP
Optional arguments:
.PP
\&'date', which is a string indicating the date, otherwise the current
date will be determined and used.  The date will be printed in red in
the lower right hand corner.
.PP
\&'text', which is a string that can be used to label the image.  This will 
printed in the lower left hand corner of the image.
.SS "drawBar"
.IX Subsection "drawBar"
This method draws a rectangle for a given coordinate set and creates a
link for the box if there is a linkUrl passed in.  The link for the
box is in the form of text that can be placed in an image map on an
html page.  The text for that is currently printed to \s-1STDOUT\s0.
.PP
Usage:
.PP
.Vb 8
\&  $gd\->drawBar(barColor  => $gd\->blue,
\&               numX1     => $X1,
\&               numX2     => $X2,
\&               numY      => $Y,
\&               linkUrl   => $linkUrl,
\&               barHeight => $barHeight,
\&               outline   => 1,
\&               arrow     => \*(Aqup\*(Aq);
.Ve
.PP
Required Arguments:
.PP
barColor     : The color of the box
numX1        : The left-hand x\-coordinate of the box
numX2        : The right-hand x\-coordinate of the box
numY         : The top y coorinate of the box
.PP
Optional Arguments:
.PP
strand       : ??? \- left over from use in SGDs \s-1ORF\s0 Map
linkUrl      : A url to which you would like the box to be linked
barHeight    : The height of the box \- will be used to determine the bottom
               y\-coordinate of the box \- default is 4 pixels
outlineColor : The color in which to outline the box
onInfoText   : Information text that can used for mouseovers
.PP
arrow        : The type of arrowhead desired on the box.  One of up, down,
               left, right, which indicates the direction in which the arrow
               head should point
arrowHeight  : The height of the arrowhead
.SS "drawName"
.IX Subsection "drawName"
This method draws a string and creates a link for it if there is a
linkUrl passed in.  The link is in the form of text that can be placed
in an image map on an html page.  The text for that is currently
printed to \s-1STDOUT\s0.
.PP
Usage:
.PP
.Vb 4
\&    $gd\->drawName(name=>" = GO term with child(ren)",
\&                  nameColor=>$gd\->black,  
\&                  numX1=>$numX1,
\&                  numY=>$y\-2);
.Ve
.PP
Required Arguments:
.PP
name      : The text that should be printed on the image
nameColor : The color in which the text should be written
numX1     : The X\-coordinate where the text should be printed
numY      : The Y\-coordinate where the text should be printed
.PP
Optional Arguments
.PP
linkUrl : A url to which you would like the text to be linked
.SS "imageMap"
.IX Subsection "imageMap"
.Vb 4
\& Title    : imageMap
\& Usage    : my $map = $goView\->imageMap;
\& Function : returns the text that constitutes an image map for the
\&            created image.
\&
\&            During creation of various glyphs, that have had a URL
\&            passed in to which they could link, text that can be used
\&            as an image map for the image, within a web page, will be
\&            generated.  When all glyphs have been added to the image,
\&            you can retrieve the image map text.  It then needs to be
\&            wrapped in a <MAP>...</MAP> declaration, and the html that
\&            displays the image will need to refer to the image, eg:
\&
\&            <MAP NAME=\*(Aqblah\*(Aq>
\&
\&            _IMAGE_MAP_TEXT_HERE_
\&
\&            </MAP>
\&            <img src=\*(Aqhttp::/some.url.here/xxx/gif\*(Aq usemap=\*(Aq#blah\*(Aq>
\&
\&            Note that the map and the usemap tag have the same name.
\&
\& Returns  : a string
.Ve
.SS "_appendToMap"
.IX Subsection "_appendToMap"
This protected method appends the passed in string onto the image
map that is generated for the image that is also created by this
module
.PP
Usage:
.PP
.Vb 1
\&    $self\->_appendToMap($text);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Shuai Weng (shuai@genome.stanford.edu)
