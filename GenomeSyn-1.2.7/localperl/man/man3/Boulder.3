.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Boulder 3"
.TH Boulder 3 "2000-06-21" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Boulder \- An API for hierarchical tag/value structures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   # Read a series of People records from STDIN.
\&   # Add an "Eligibility" attribute to all those whose
\&   # Age >= 35 and Friends list includes "Fred"
\&   
\&   use Boulder::Stream;
\&   
\&   my $stream = Boulder::Stream\->newFh;
\&   
\&   while ( my $record = <$stream> ) {
\&      next unless $record\->Age >= 35;
\&      my @friends = $record\->Friends;
\&      next unless grep {$_ eq \*(AqFred\*(Aq} @friends;
\&
\&      $record\->insert(Eligibility => \*(Aqyes\*(Aq);
\&      print $stream $record;
\&    }
.Ve
.PP
Related manual pages:
.PP
.Vb 4
\&  basics
\&  \-\-\-\-\-\-
\&  Stone            hierarchical tag/value records
\&  Stone::Cursor    Traverse a hierarchy
\&
\&  Boulder::Stream  stream\-oriented storage for Stones
\&  Boulder::Store   record\-oriented storage for Stones
\&  Boulder::XML     XML conversion for Stones
\&  Boulder::String  conversion to strings
\&
\&  genome\-related
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  Boulder::Genbank   parse Genbank (DNA sequence) records
\&  Boulder::Blast     parse BLAST (basic local alignment search tool) reports
\&  Boulder::Medline   parse Medline (pubmed) records
\&  Boulder::Omim      parse OMIM (online Mendelian inheritance in man) records
\&  Boulder::Swissprot parse Swissprot records
\&  Boulder::Unigene   parse Unigene records
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Boulder \s-1IO\s0"
.IX Subsection "Boulder IO"
Boulder \s-1IO\s0 is a simple TAG=VALUE data format designed for sharing data
between programs connected via a pipe.  It is also simple enough to use
as a common data exchange format between databases, Web pages, and other
data representations.
.PP
The basic data format is very simple.  It consists of a series of TAG=VALUE
pairs separated by newlines.  It is record-oriented.  The end of a record is
indicated by an empty delimiter alone on a line.  The delimiter is \*(L"=\*(R" by
default, but can be adjusted by the user.
.PP
An example boulder stream looks like this:
.PP
.Vb 10
\&        Name=Lincoln Stein
\&        Home=/u/bush202/lds32
\&        Organization=Cold Spring Harbor Laboratory
\&        Login=lds32
\&        Password_age=20
\&        Password_expires=60
\&        Alias=lstein
\&        Alias=steinl
\&        =
\&        Name=Leigh Deacon
\&        Home=/u/bush202/tanager
\&        Organization=Cold Spring Harbor Laboratory
\&        Login=tanager
\&        Password_age=2
\&        Password_expires=60
\&        =
.Ve
.PP
Notes:
.IP "(1)" 4
.IX Item "(1)"
There is no need for all tags to appear in all records, or
indeed for all the records to be homogeneous.
.IP "(2)" 4
.IX Item "(2)"
Multiple values are allowed, as with the Alias tag in the second
record.
.IP "(3)" 4
.IX Item "(3)"
Lines can be any length, as in a potential 40 Kbp \s-1DNA\s0 sequence entry.
.IP "(4)" 4
.IX Item "(4)"
Tags can be any alphanumeric character (upper or lower case) and may
contain embedded spaces.  Conventionally we use the characters
A\-Z0\-9_, because they can be used without single quoting as keys in
Perl associative arrays, but this is merely stylistic.  Values can be
any character at all except for the reserved characters {}=% and
newline.  You can incorporate binary data into the data stream by
escaping these characters in the \s-1URL\s0 manner, using a % sign followed
by the (capitalized) hexadecimal code for the character.  The module
makes this automatic.
.SS "Hierarchical Records"
.IX Subsection "Hierarchical Records"
The simple boulder format can be extended to accomodate nested
relations and other intresting structures.  Nested records can be
created in this way:
.PP
.Vb 10
\& Name=Lincoln Stein
\& Home=/u/bush202/lds32
\& Organization=Cold Spring Harbor Laboratory
\& Login=lds32
\& Password_age=20
\& Password_expires=60
\& Privileges={
\&   ChangePasswd=yes
\&   CronJobs=yes
\&   Reboot=yes
\&   Shutdown=no
\& }
\& =
\& Name=Leigh Deacon
\& Home=/u/bush202/tanager
\& Organization=Cold Spring Harbor Laboratory
\& Login=tanager
\& Password_age=2
\& Password_expires=60
\& Privileges={
\&   ChangePasswd=yes
\&   CronJobs=no
\&   Reboot=no
\&   Shutdown=no
\& }
\& =
.Ve
.PP
As in the original format, tags may be multivalued.  For example,
there might be several Privilege record assigned to a login account.
Each subrecord may contain further subrecords.
.PP
Within the program, a hierarchical record is encapsulated within a
\&\*(L"Stone\*(R", an opaque structure that implements methods for fetching and
settings its various tags.
.SS "Using Boulder for I/O"
.IX Subsection "Using Boulder for I/O"
The Boulder \s-1API\s0 was designed to make reading and writing of complex
hierarchical records almost as easy as reading and writing single
lines of text.
.IP "Boulder::Stream" 4
.IX Item "Boulder::Stream"
The main component of the Boulder modules is Boulder::Stream, which
provides a stream-oriented view of the data.  You can read and write
to Boulder::Streams via tied filehandles, or via method calls.  Data
records are flattened into a simple format called \*(L"boulderio\*(R" format.
.IP "Boulder::XML" 4
.IX Item "Boulder::XML"
Boulder::XML acts like Boulder::Stream, but the serialization format
is \s-1XML\s0.  You need XML::Parser installed to use this module.
.IP "Boulder::Store" 4
.IX Item "Boulder::Store"
This is a simple persistent storage class which allows you to store
several (thousand) Stone's into a DB_File database.  You must have
libdb and the Perl DB_File extensions installed in order to take
advantage of this class.
.IP "Boulder::Genbank" 4
.IX Item "Boulder::Genbank"
.PD 0
.IP "Boulder::Unigene" 4
.IX Item "Boulder::Unigene"
.IP "Boulder::OMIM" 4
.IX Item "Boulder::OMIM"
.IP "Boulder::Blast" 4
.IX Item "Boulder::Blast"
.IP "Boulder::Medline" 4
.IX Item "Boulder::Medline"
.IP "Boulder::SwissProt" 4
.IX Item "Boulder::SwissProt"
.PD
These are parsers and accessors for various biological data sources.
They act like Boulder::Stream, but return a set of Stone objects that
have certain prescribed tags and values.  Many of these modules were
written by Luca I.G. Toldo <luca.toldo@merck.de>.
.SS "Stone Objects"
.IX Subsection "Stone Objects"
The Stone object encapsulates a set of tags and values.  Any tag can
be single\- or multivalued, and tags are allowed to contain subtags to
any depth.  A simple set of methods named \fItags()\fR, \fIget()\fR, \fIput()\fR,
\&\fIinsert()\fR, \fIreplace()\fR and so forth, allows you to examine the tags that
are available, get and set their values, and search for particular
tags.  In addition, an autoload mechanism allows you to use method
calls to access tags, for example:
.PP
.Vb 1
\&   my @friends = $record\->Friends;
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\&   my @friends = $record\->get(\*(AqFriends\*(Aq);
.Ve
.PP
A Stone::Cursor class allows you to traverse Stones systematically.
.PP
A full explanation of the Stone class can be found in its manual page.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln D. Stein <lstein@cshl.org>, Cold Spring Harbor Laboratory,
Cold Spring Harbor, \s-1NY\s0.  This module can be used and distributed on
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Boulder::Blast, Boulder::Genbank, Boulder::Medline, Boulder::Unigene,
Boulder::Omim, Boulder::SwissProt
