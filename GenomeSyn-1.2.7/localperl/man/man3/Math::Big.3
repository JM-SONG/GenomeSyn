.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Big 3"
.TH Math::Big 3 "2007-04-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Big \- routines (cos,sin,primes,hailstone,euler,fibbonaci etc) with big numbers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Math::Big qw/primes fibonacci hailstone factors wheel
\&      cos sin tan euler bernoulli arctan arcsin pi/;
\&
\&    @primes     = primes(100);          # first 100 primes
\&    $prime      = primes(100);          # 100th prime
\&    @fib        = fibonacci (100);      # first 100 fibonacci numbers
\&    $fib_1000   = fibonacci (1000);     # 1000th fibonacci number
\&    $hailstone  = hailstone (1000);     # length of sequence
\&    @hailstone  = hailstone (127);      # the entire sequence
\&    
\&    $factorial  = factorial(1000);      # factorial 1000!
\& 
\&    $e = euler(1,64);                   # e to 64 digits
\&
\&    $b3 = bernoulli(3);
\&
\&    $cos        = cos(0.5,128);         # cosinus to 128 digits
\&    $sin        = sin(0.5,128);         # sinus to 128 digits
\&    $cosh       = cosh(0.5,128);        # cosinus hyperbolicus to 128 digits
\&    $sinh       = sinh(0.5,128);        # sinus hyperbolicus to 128 digits
\&    $tan        = tan(0.5,128);         # tangens to 128 digits
\&    $arctan     = arctan(0.5,64);       # arcus tangens to 64 digits
\&    $arcsin     = arcsin(0.5,32);       # arcus sinus to 32 digits
\&    $arcsinh    = arcsin(0.5,18);       # arcus sinus hyperbolicus to 18 digits
\&
\&    $pi         = pi(1024);             # first 1024 digits
\&    $log        = log(64,2);            # $log==6, because 2**6==64
\&    $log        = log(100,10);          # $log==2, because 10**2==100
\&    $log        = log(100);             # base defaults to 10: $log==2
.Ve
.SH "REQUIRES"
.IX Header "REQUIRES"
perl5.006002, Exporter, Math::BigInt, Math::BigFloat
.SH "EXPORTS"
.IX Header "EXPORTS"
Exports nothing on default, but can export \f(CW\*(C`primes()\*(C'\fR, \f(CW\*(C`fibonacci()\*(C'\fR,
\&\f(CW\*(C`hailstone()\*(C'\fR, \f(CW\*(C`bernoulli\*(C'\fR, \f(CW\*(C`euler\*(C'\fR, \f(CW\*(C`sin\*(C'\fR, \f(CW\*(C`cos\*(C'\fR, \f(CW\*(C`tan\*(C'\fR, \f(CW\*(C`cosh\*(C'\fR,
\&\f(CW\*(C`sinh\*(C'\fR, \f(CW\*(C`arctan\*(C'\fR, \f(CW\*(C`arcsin\*(C'\fR, \f(CW\*(C`arcsinh\*(C'\fR, \f(CW\*(C`pi\*(C'\fR, \f(CW\*(C`log\*(C'\fR and \f(CW\*(C`factorial\*(C'\fR.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains some routines that may come in handy when you want to
do some math with really, really big (or small) numbers. These are primarily
examples.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fB\fP\f(BIprimes()\fP\fB\fP"
.IX Subsection "primes()"
.Vb 2
\&        @primes = primes($n);
\&        $primes = primes($n);
.Ve
.PP
Calculates all the primes below N and returns them as array. In scalar context
returns the number of primes below N.
.PP
This uses an optimized version of the \fBSieve of Eratosthenes\fR, which takes
half of the time and half of the space, but is still O(N). Or in other words,
quite slow.
.SS "\fB\fP\f(BIfibonacci()\fP\fB\fP"
.IX Subsection "fibonacci()"
.Vb 2
\&        @fib = fibonacci($n);
\&        $fib = fibonacci($n);
.Ve
.PP
Calculates the first N fibonacci numbers and returns them as array.
In scalar context returns the Nth number of the Fibonacci series.
.PP
The scalar context version uses an ultra-fast conquer-divide style algorithm
to calculate the result and is many times faster than the straightforward way
of calculating the linear sum.
.SS "\fB\fP\f(BIhailstone()\fP\fB\fP"
.IX Subsection "hailstone()"
.Vb 2
\&        @hail = hailstone($n);          # sequence
\&        $hail = hailstone($n);          # length of sequence
.Ve
.PP
Calculates the \fIHailstone\fR sequence for the number N. This sequence is defined 
as follows:
.PP
.Vb 11
\&        while (N != 0)
\&          {
\&          if (N is even)
\&            {
\&            N is N /2
\&            }
\&          else
\&            {
\&            N = N * 3 +1
\&            }
\&          }
.Ve
.PP
It is not yet proven whether for every N the sequence reaches 1, but it
apparently does so. The number of steps is somewhat chaotically.
.SS "\fB\fP\f(BIbase()\fP\fB\fP"
.IX Subsection "base()"
.Vb 1
\&        ($n,$a) = base($number,$base);
.Ve
.PP
Reduces a number to \f(CW$base\fR to the \f(CW$n\fRth power plus \f(CW$a\fR. Example:
.PP
.Vb 2
\&        use Math::BigInt :constant;
\&        use Math::Big qw/base/;
\&
\&        print base ( 2 ** 150 + 42,2);
.Ve
.PP
This will print 150 and 42.
.SS "\fB\fP\f(BIto_base()\fP\fB\fP"
.IX Subsection "to_base()"
.Vb 1
\&        $string = to_base($number,$base);
\&
\&        $string = to_base($number,$base, $alphabet);
.Ve
.PP
Returns a string of \f(CW$number\fR in base \f(CW$base\fR. The alphabet is optional if
\&\f(CW$base\fR is less or equal than 36. \f(CW$alphabet\fR is a string.
.PP
Examples:
.PP
.Vb 3
\&        print to_base(15,2);            # 1111
\&        print to_base(15,16);           # F
\&        print to_base(31,16);           # 1F
.Ve
.SS "\fB\fP\f(BIfactorial()\fP\fB\fP"
.IX Subsection "factorial()"
.Vb 1
\&        $n = factorial($number);
.Ve
.PP
Calculate \f(CW\*(C`n!\*(C'\fR for \f(CW\*(C`n \*(C'\fR= 0>.
.PP
Uses internally Math::BigInt's \fIbfac()\fR method.
.SS "\fB\fP\f(BIbernoulli()\fP\fB\fP"
.IX Subsection "bernoulli()"
.Vb 2
\&        $b = bernoulli($n);
\&        ($c,$d) = bernoulli($n);        # $b = $c/$d
.Ve
.PP
Calculate the Nth number in the \fIBernoulli\fR series. Only the first 40 are
defined for now.
.SS "\fB\fP\f(BIeuler()\fP\fB\fP"
.IX Subsection "euler()"
.Vb 1
\&        $e = euler($x,$d);
.Ve
.PP
Calculate \fIEuler's constant\fR to the power of \f(CW$x\fR (usual 1), to \f(CW$d\fR digits.
Defaults to 1 and 42 digits.
.SS "\fB\fP\f(BIsin()\fP\fB\fP"
.IX Subsection "sin()"
.Vb 1
\&        $sin = sin($x,$d);
.Ve
.PP
Calculate \fIsinus\fR of \f(CW$x\fR, to \f(CW$d\fR digits.
.SS "\fB\fP\f(BIcos()\fP\fB\fP"
.IX Subsection "cos()"
.Vb 1
\&        $cos = cos($x,$d);
.Ve
.PP
Calculate \fIcosinus\fR of \f(CW$x\fR, to \f(CW$d\fR digits.
.SS "\fB\fP\f(BItan()\fP\fB\fP"
.IX Subsection "tan()"
.Vb 1
\&        $tan = tan($x,$d);
.Ve
.PP
Calculate \fItangens\fR of \f(CW$x\fR, to \f(CW$d\fR digits.
.SS "\fB\fP\f(BIarctan()\fP\fB\fP"
.IX Subsection "arctan()"
.Vb 1
\&        $arctan = arctan($x,$d);
.Ve
.PP
Calculate \fIarcus tangens\fR of \f(CW$x\fR, to \f(CW$d\fR digits.
.SS "\fB\fP\f(BIarctanh()\fP\fB\fP"
.IX Subsection "arctanh()"
.Vb 1
\&        $arctanh = arctanh($x,$d);
.Ve
.PP
Calculate \fIarcus tangens hyperbolicus\fR of \f(CW$x\fR, to \f(CW$d\fR digits.
.SS "\fB\fP\f(BIarcsin()\fP\fB\fP"
.IX Subsection "arcsin()"
.Vb 1
\&        $arcsin = arcsin($x,$d);
.Ve
.PP
Calculate \fIarcus sinus\fR of \f(CW$x\fR, to \f(CW$d\fR digits.
.SS "\fB\fP\f(BIarcsinh()\fP\fB\fP"
.IX Subsection "arcsinh()"
.Vb 1
\&        $arcsinh = arcsinh($x,$d);
.Ve
.PP
Calculate \fIarcus sinus hyperbolicus\fR of \f(CW$x\fR, to \f(CW$d\fR digits.
.SS "\fB\fP\f(BIcosh()\fP\fB\fP"
.IX Subsection "cosh()"
.Vb 1
\&        $cosh = cosh($x,$d);
.Ve
.PP
Calculate \fIcosinus hyperbolicus\fR of \f(CW$x\fR, to \f(CW$d\fR digits.
.SS "\fB\fP\f(BIsinh()\fP\fB\fP"
.IX Subsection "sinh()"
.Vb 1
\&        $sinh = sinh($x,$d);
.Ve
.PP
Calculate \fIsinus hyperbolicus\fR of $<$x>, to \f(CW$d\fR digits.
.SS "\fB\fP\f(BIpi()\fP\fB\fP"
.IX Subsection "pi()"
.Vb 1
\&        $pi = pi($N);
.Ve
.PP
The number \s-1PI\s0 to \f(CW$N\fR digits after the dot.
.SS "\fB\fP\f(BIlog()\fP\fB\fP"
.IX Subsection "log()"
.Vb 1
\&        $log = log($number,$base,$A);
.Ve
.PP
Calculates the logarithmn of \f(CW$number\fR to base \f(CW$base\fR, with \f(CW$A\fR digits accuracy
and returns a new number as the result (leaving \f(CW$number\fR alone).
.PP
BigInts are promoted to BigFloats, meaning you will never get a truncated
integer result like when using \f(CW\*(C`Math::BigInt::blog\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 2
Primes and the Fibonacci series use an array of size N and will not be able
to calculate big sequences due to memory constraints.
.Sp
The exception is fibonacci in scalar context, this is able to calculate
arbitrarily big numbers in O(N) time:
.Sp
.Vb 2
\&        use Math::Big;
\&        use Math::BigInt qw/:constant/;
\&
\&        $fib = Math::Big::fibonacci( 2 ** 320 );
.Ve
.IP "\(bu" 2
The Bernoulli numbers are not yet calculated, but looked up in a table, which
has only 40 elements. So \f(CW\*(C`bernoulli($x)\*(C'\fR with \f(CW$x\fR > 42 will fail.
.Sp
If you know of an algorithmn to calculate them, please drop me a note.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
If you use this module in one of your projects, then please email me. I want
to hear about how my code helps you ;)
.PP
Quite a lot of ideas from other people, especially D. E. Knuth, have been used,
thank you!
.PP
Tels http://bloodgate.com 2001 \- 2007.
