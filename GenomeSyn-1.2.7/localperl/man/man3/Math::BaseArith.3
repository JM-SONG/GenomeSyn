.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BaseArith 3"
.TH BaseArith 3 "2002-10-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BaseArith \- Perl extension for mixed\-base number representation (like APL encode/decode)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Math::BaseArith;
\&  encode( value, base_list );
\&  decode( representation_list, base_list );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The inspiration for this module is a pair of functions in the \s-1APL\s0
programming language called encode (a.k.a. \*(L"representation\*(R") and decode
(a.k.a. base-value). Their principal use is to convert numbers from one
number base to another. Mixed number bases are permitted.
.PP
In this perl implementation, the representation of a number in a
particular number base consists of a list whose elements are the digit
values in that base. For example, the decimal number 31 would be
expressed in binary as a list of five ones with any number of leading
zeros: [0, 0, 0, 1, 1, 1, 1, 1]. The same number expressed as three
hexadecimal (base 16) digits would be [0, 1, 15], while in base 10 it
would be [0, 3, 1]. Fifty-one inches would be expressed in yards, feet,
inches as [1, 1, 3], an example of a mixed number base.
.PP
In the following description of encode and decode, Q will mean an
abstract value or quantity, R will be its representation and B will
define the number base. Q will be a perl scalar; R and B are perl lists.
The values in R correspond to the radix values in B.
.PP
In the examples below, assume the output of \fBprint\fR has been altered by
setting $, = ' ' and that \f(CW\*(C`=>\*(C'\fR is your shell prompt.
.SH "&encode"
.IX Header "&encode"
Encode is used to represent a number in one or more number bases. The
first argument is the number to be converted, and the second argument
defines the base (or bases) to be used for the representation. Consider
first the representation of a scalar in a single uniform number base:
.PP
.Vb 2
\&    print encode( 2, [2, 2, 2, 2] )
\&    => 0 0 1 0
\&
\&    print encode( 5, [2, 2, 2, 2] )
\&    => 0 1 0 1
\&
\&    print encode( 13, [2, 2, 2, 2] )
\&    => 1 1 0 1
\&
\&    print encode( 62, [16, 16, 16] )
\&    => 0 3 14
.Ve
.PP
The second argument is called the base list. The length of the
base list determines the number of digits in the representation of
the first argument. No error occurs if the length is insufficient to
give a proper representation of the number. Exploring this situation
will suggest other uses of encode, and may clarify the use of encode
with mixed number bases.
.PP
.Vb 3
\&    # The representation of 75 in base 4
\&    print encode( 75, [4, 4, 4, 4] )
\&    => 1 0 2 3
\&
\&    # At least four digits are needed for the full representation
\&    print encode( 75, [4, 4, 4] )
\&    => 0 2 3
\&
\&    # If fewer elements are in the second argument,
\&    # leading digits do not appear in the representation.
\&    print encode( 75, [4, 4] )
\&    => 2 3
\&
\&    # If the second argument is a one\-element list, encode is identical
\&    # to modulus (%)
\&    print encode( 75, [4] )
\&    => 3
\&    print encode( 76, [4] )
\&    => 0
\&
\&    # The expression encode( Q, [0] ) always yields Q as the result
\&    print encode ( 75, [0] )
\&    => 75
\&
\&    # This usage returns quotient and remainder
\&    print encode( 75, [0, 4] )
\&    => 18 3
\&
\&    # The first quotient (18) is again divided by 4,
\&    # yielding a second quotient and remainder
\&    print encode( 75, [0, 4, 4] )
\&    => 4 2 3
\&
\&    # The process is repeated again. Since the last quotient
\&    # is less than 4, the result is the same as encode(75,[4,4,4,4])
\&    print encode( 75, [0, 4, 4, 4] )
\&    => 1 0 2 3
.Ve
.PP
Now consider a mixed number base: convert 175 inches into yards, feet,
inches.
.PP
.Vb 3
\&    # 175 inches is 14 feet, 7 inches (quotient and remainder). 
\&    print encode( 175, [0, 12] )
\&    => 14 7
\&
\&    # 14 feet is 4 yards, 2 feet,
\&    print encode( 14, [0, 3] )
\&    => 4 2
\&       
\&    # so 175 inches is 4 yards, 2 feet, 7 inches.
\&    print encode( 175, [0, 3, 12] )
\&    => 4 2 7
.Ve
.SH "&decode"
.IX Header "&decode"
Decode (or base-value) is used to determine the value of the
representation of a quantity in some number base. If \fBR\fR is a list
representation (perhaps produced by the encode function described above)
of some quantity \fBQ\fR in a number base defined by the radix list \fBB\fR (i.e.,
\&\f(CW\*(C`@R = encode($Q,@B)\*(C'\fR, then the expression \f(CW\*(C`decode(@R,@B)\*(C'\fR yields \f(CW$Q\fR:
.PP
.Vb 2
\&    print decode( [0, 0, 1, 0], [2, 2, 2, 2] )
\&    => 2
\&
\&    print decode( [0, 1, 0, 1], [2, 2, 2, 2] )
\&    => 5
\&
\&    print decode( [0, 3, 14], [16, 16, 16]
\&    => 62
.Ve
.PP
The length of the representation list must be less than or equal to
that of the base list.
.PP
.Vb 2
\&    print decode( [1, 1, 1, 1], [2, 2, 2, 2] )
\&    => 15
\&
\&    print decode( [1, 1, 1, 1], [2] )
\&    => 15
\&
\&    print decode( [1], [2, 2, 2, 2] )
\&    => 15
\&
\&    print decode( [1, 1, 1, 1], [2, 2, 2] )
\&    => (void) 
\&    raises a LENGTH ERROR
.Ve
.PP
As with the encode function, mixed number bases can be used:
.PP
.Vb 3
\&    # Convert 4 yards, 2 feet, 7 inches to inches.
\&    print decode( [4, 2, 7], [0, 3, 12] )
\&    => 175
\&
\&
\&    # Convert 2 days, 3 hours, 5 minutes, and 27 seconds to seconds 
\&    print decode( [2, 3, 5, 27], [0, 24, 60, 60] )
\&    => 183927
\&
\&    # or to minutes.
\&    print decode( [2, 3, 5, 27], [0, 24, 60, 60] ) / 60
\&    => 3065.45
.Ve
.PP
The first element of the radix list (second argument) is not used; it is
required only to make the lengths match and so can be any value.
.SH "EXPORT"
.IX Header "EXPORT"
.Vb 3
\&  use Math::BaseArith;
\&   &encode
\&   &decode
\&
\&  use Math::BaseArith \*(Aq:all\*(Aq;
\&   &encode
\&   &decode
\&   BaseArith::debug
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
Import the global \f(CW$Math::BaseArith::debug\fR to print debugging information to \s-1STDERR\s0.
.PP
If set to 1, function names and parameters are printed.
.PP
If set to 2, intermediate results are also printed.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
The \s-1APL\s0 encode function allows both arguments to be a list, in which case the
function evaluates in dot-product fashion, generating a matrix whose columns
are the representation vectors for each value in the value list; i.e. a call
such as encode([15,31,32,33,75],[4,4,4,4]) would generate the following matrix;
.PP
.Vb 4
\&        0 0 0 0 1
\&        0 1 2 2 0
\&        3 3 0 0 2
\&        3 3 0 1 3
.Ve
.PP
This version of encode supports only a scalar value as the first argument.
.PP
The \s-1APL\s0 version of decode support non-integer values.  This version doesn't.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gary Puckering <gary.puckering@cognos.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://www.acm.org/sigapl/encode.htm>.
