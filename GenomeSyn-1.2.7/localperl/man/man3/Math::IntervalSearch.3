.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::IntervalSearch 3"
.TH Math::IntervalSearch 3 "1999-08-25" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::IntervalSearch \- Search where an element lies in a list of sorted elements
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Math::IntervalSearch qw(interval_search);
\& my @array = (1..5);
\& my $location = interval_search(2.4, \e@array);
\&
\& # Use your own comparison operators.
\& sub ReverseLessThan {
\&   $_[0] < $_[1];
\& }
\&
\& sub ReverseLessThanEqualTo {
\&   $_[0] <= $_[1];
\& }
\&
\& $location = interval_search(2.4,
\&                             \e@array,
\&                             \e&ReverseLessThan,
\&                             \e&ReverseLessThanEqualTo);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This subroutine is used to locate a position in an array of values where
a given value would fit.  It has been designed to be efficient in the
common situation that it is called repeatedly.  The user can supply a
different set of comparison operators to replace the standard < and <=.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.IP "\fBinterval_search\fR \fIvalue\fR \fIsequence\fR [\fIless_than\fR [\fIless_than_equal_to\fR]]" 4
.IX Item "interval_search value sequence [less_than [less_than_equal_to]]"
Given a \fIvalue\fR \fIinterval_search\fR returns the location in the reference
to an array \fIsequence\fR where the value would fit.  The default <
operator to compare the elements in \fIsequence\fR can be replaced by the
subroutine \fIless_than\fR which should return 1 if the first element passed
to \fIless_than\fR is less than the second.  The default <= operator to
compare the elements in \fIsequence\fR can be replaced by the subroutine
\&\fIless_than\fR which should return 1 if the first element passed to
\&\fIless_than\fR is less than the second.
.Sp
The values in \fIsequence\fR should already be sorted in numerically
increasing order or in the order that would be produced by using the
\&\fIless_than\fR subroutine.
.Sp
Let N be the number of elements in referenced array \fIsequence\fR, then
\&\fIinterval_search\fR returns these values:
    \-1  if                    \fIvalue\fR < \fIsequence\fR\->[0]
    i   if \fIsequence\fR\->[i]   <= \fIvalue\fR < \fIsequence\fR\->[i+1]
    N\-1 if \fIsequence\fR\->[N\-1] <= \fIvalue\fR
.Sp
If a reference is made to an empty array, then \-1 is always returned.
.Sp
If there is illegal input to \fIinterval_search\fR, such as an improper
number of arguments, then an empty list in list context, an undefined
value in scalar context, or nothing in a void context is returned.
.Sp
This subroutine is designed to be efficient in the common situation
that it is called repeatedly, with \fIvalue\fR taken from an increasing or
decreasing list of values.  This will happen, e.g., when an irregular
waveform is interpolated to create a sequence with constant separation.
The first guess for the output is therefore taken to be the value
returned at the previous call and stored in the variable ilo.  A first
check ascertains that ilo is less than the number of data points in
\&\fIsequence\fR.  This is necessary since the present call may have nothing
to do with the previous call.  Then, if
    \fIsequence\fR\->[ilo] <= \fIvalue\fR < \fIsequence\fR\->[ilo+1],
.Sp
we set left = ilo and are done after just three comparisons.  Otherwise,
we repeatedly double the difference
    istep = ihi \- ilo
.Sp
while also moving ilo and ihi in the direction of x, until
    \fIsequence\fR\->[ilo] <= x < \fIsequence\fR\->[ihi],
.Sp
after which bisection is used to get, in addition,
    ilo+1 = ihi.
.Sp
Then left = ilo is returned.
.SH "AUTHOR"
.IX Header "AUTHOR"
Blair Zajac <bzajac@geostaff.com>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998 by Blair Zajac.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 243:" 4
.IX Item "Around line 243:"
=back doesn't take any parameters, but you said =back 4
