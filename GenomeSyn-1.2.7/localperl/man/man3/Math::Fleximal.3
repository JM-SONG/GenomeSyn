.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Fleximal 3"
.TH Math::Fleximal 3 "2013-06-17" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Fleximal \- Integers with flexible representations.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Math::Fleximal;
\&  my $number = new Math::Fleximal($value, $flex);
\&  
\&  # Set the value
\&  $number = $number\->set_value("\- $fleck_4$fleck_3");
\&  $number = $number\->set_value($another_number);
\&
\&  # Get the object in a familiar form  
\&  my $string = $number\->to_str();
\&  my $integer = $number\->base_10();
\&  
\&  # Construct more numbers with same flex
\&  my $copy = $number\->dup();
\&  my $other_number = $number\->dup($value);
\&  my $absolute_value = $number\->abs();
\&
\&  # New representation anyone?
\&  my $in_new_base = $number\->change_flex($new_flex);
\&
\&  # Arithmetic \- can be different flex.  Answers have
\&  # the flex of $number.
\&  $result = $number\->add($other_number);
\&  $result = $number\->mul($other_number);
\&  $result = $number\->subtr($other_numer);
\&  $result = $number\->div($other_number);
\&
\&  # And integer\-specific arithmetic works
\&  $result = $number\->gcd($other_number);
\&  $result = $number\->mod($other_number);
\&  
\&  my $comparison = $number\->cmp($other_number);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a package for doing integer arithmetic while
using a different base representation than normal.  In
base n arithmetic you have n symbols which have a
representation.  I was going to call them \*(L"glyphs\*(R",
but being text strings they are not really.  On Tye
McQueen's whimsical suggestion I settled on the name 
Math::Fleximal, the set of text representations is 
called a \*(L"flex\*(R", and the representation of individual 
digits are the \*(L"flecks\*(R".  These names are somewhat 
unofficial...
.PP
This allows you to do basic arithmetic using whatever
digits you want, and to convert from one to another.
.PP
Like \f(CW\*(C`Math::BigInt\*(C'\fR it is able to handle very large
numbers, though performance is not very good.  (Which
is also like \f(CW\*(C`Math::BigInt\*(C'\fR, for good performance
you should be using <Bit::Vector>.)  Instead use it as
a version of Math::BaseCalc without an upper limit on
the size of numbers.  A sample use would be to put an
\&\s-1MD5\s0 hash into a convenient representation:
.PP
.Vb 3
\&  use Math::Fleximal;
\&  use Digest::MD5 qw(md5_hex);
\&  my $digest = hex2alpha(md5_hex($data));
\&  
\&  # Converts a hex representation of a number into
\&  # one that uses more alphanumerics.  (ie base 62)
\&  sub hex2alpha {
\&    Math::Fleximal\->new(
\&      lc(shift), [0..9, \*(Aqa\*(Aq..\*(Aqf\*(Aq]
\&    )\->change_flex(
\&      [0..9,\*(Aqa\*(Aq..\*(Aqz\*(Aq,\*(AqA\*(Aq..\*(AqZ\*(Aq]
\&    )\->to_str();
\&  }
.Ve
.ie n .IP """new""" 4
.el .IP "\f(CWnew\fR" 4
.IX Item "new"
Construct a new number.  The arguments are the value,
the anonymous array of flecks that make up the flex,
followed by an anonymous hash of other arguments.
The flex will default to [0..9] and the other arguments
will default to an empty hash.
.Sp
This can be used to calculations in bases other than 10
\&\- the base is just the number of flecks in the flex.  So
you could construct a base 16 number with:
.Sp
.Vb 1
\&  my $base_16 = new Math::Fleximal("4d", [0..9, \*(Aqa\*(Aq..\*(Aqf\*(Aq]);
.Ve
.Sp
If a value is passed it can be an existing Math::Fleximal
or (as above) a string that can be parsed with the current
flex.
.Sp
The possible keys to the optional arguments are:
.RS 4
.IP "\(bu" 8
\&\fI+\fR for the plus symbol to use.  This defaults to '+'.
.IP "\(bu" 8
\&\fI\-\fR for the minus symbol to use.  This defaults to '\-'.
.IP "\(bu" 8
\&\fIshow_+\fR is a flag for whether to show the plus symbol
on positive numbers.  This defaults to a false value.
.IP "\(bu" 8
Whatever matches \fIstrip\fR will be stripped from the
string before parsing.  This defaults to qr/[\es\e.,_]/
to cover most of the common ways that are used to group
digits in a long number.
.RE
.RS 4
.Sp
The parsing of a string into flecks is case sensitive.
Also possibly ambiguous parses are not handled very
well.
.RE
.ie n .IP """dup""" 4
.el .IP "\f(CWdup\fR" 4
.IX Item "dup"
Copy an existing number.  This copy may be worked with
without changing the existing number.  If dup is passed
a value, the new instance will have that value instead.
.ie n .IP """set_value""" 4
.el .IP "\f(CWset_value\fR" 4
.IX Item "set_value"
This sets the internal value and returns the object.
.Sp
You can either pass the new value an existing instance
(which may be in another base) or a string.  When passed
a string it first strips whitespace.  After that it
accepts an optional +\-, followed by a series of flecks
(there must be at least one) for the first to last
digits.  It will be confused if the leading fleck starts
with + or \- and no sign is included.
.ie n .IP """to_str""" 4
.el .IP "\f(CWto_str\fR" 4
.IX Item "to_str"
Returns the string representation of the current value
using the current flex.  This always includes a sign,
with no white space in front of the sign.
.ie n .IP """base_10""" 4
.el .IP "\f(CWbase_10\fR" 4
.IX Item "base_10"
Returns the internal value in a base 10 representation.
The numbers returned may be larger than Perl's usual
integer representation can handle.
.ie n .IP """change_flex""" 4
.el .IP "\f(CWchange_flex\fR" 4
.IX Item "change_flex"
Takes a new flex and converts the current to that.
Will implicitly change base if needed.
.ie n .IP """add""" 4
.el .IP "\f(CWadd\fR" 4
.IX Item "add"
Adds one or more numbers to the current one and returns
the answer in the current representation.  The numbers
may be objects in any base, or strings of the current
representation.
.ie n .IP """mul""" 4
.el .IP "\f(CWmul\fR" 4
.IX Item "mul"
Multiplies one or more numbers to the current one and
returns the answer in the current representation.  The
numbers may be objects in any base, or strings of the
current representation.
.ie n .IP """subtr""" 4
.el .IP "\f(CWsubtr\fR" 4
.IX Item "subtr"
Subtracts one or more numbers from the current one and
returns the answer in the current representation.
The numbers may be objects in any base, or strings of
the current representation.
.ie n .IP """div""" 4
.el .IP "\f(CWdiv\fR" 4
.IX Item "div"
Divides one or more numbers from the current one and
returns the answer in the current representation.
In list context it will return the answer and an
array of remainders in the current representation.
The remainders will be positive and less than the
absolute value of the denominator. The numbers may be
objects in any base, or strings of the current
representation.
.ie n .IP """gcd""" 4
.el .IP "\f(CWgcd\fR" 4
.IX Item "gcd"
Takes one or more numbers and calculates the gcd of
this and the entire list.
.ie n .IP """mod""" 4
.el .IP "\f(CWmod\fR" 4
.IX Item "mod"
Does the divisions as \f(CW\*(C`div\*(C'\fR does and returns only the
remainders.  In scalar context only the last remainder
is returned.  Thus the following returns the
ten-thousands digit:
.Sp
.Vb 1
\&  my $digit = $number\->mod(1000, 10);
.Ve
.ie n .IP """cmp""" 4
.el .IP "\f(CWcmp\fR" 4
.IX Item "cmp"
Pass another number, returns \-1 if it is smaller than
the other number, 0 if they are equal, and 1 if it is
larger.  (Much like cmp does with strings.)
.ie n .IP """one""" 4
.el .IP "\f(CWone\fR" 4
.IX Item "one"
Returns 1 in the current flex.
.ie n .IP """zero""" 4
.el .IP "\f(CWzero\fR" 4
.IX Item "zero"
Returns 0 in the current flex.
.SH "BUGS"
.IX Header "BUGS"
This will fail if you are trying to work in bases of
size more than 30,000 or so.
.PP
Only a slight effort is made to resolve potential
ambiguities in the parsing of a string into flecks.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright 2000\-2001, Ben Tilly (<btilly@gmail.com>)
.PP
Math::Fleximal may be copied and distributed on the
same terms as Perl itself.
