.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GO::AnnotationProvider 3"
.TH GO::AnnotationProvider 3 "2006-07-28" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GO::AnnotationProvider \- abstract base class defining interface for how Annotation information should be provided
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
GO::AnnotationProvider is an interface that defines an \s-1API\s0 that
should be implemented by specific subclasses, which may read \s-1GO\s0
annotation from databases, flatfiles, \s-1XML\s0 files etc.
.PP
\&\s-1GO\s0 (Gene Ontology) is a project of the Gene Ontology Consortium
(http://www.geneontology.org).  The \s-1GO\s0 project has 3 'aspects' :
.PP
.Vb 3
\&    Biological Process
\&    Molecular Function
\&    Cellular Component
.Ve
.PP
When a method requires the client to refer to an aspect, it is simply
by a shorthand, namely P, F and C, respectively.
.PP
In \s-1GO\s0 associations, annotated entities may be identified by many
different names.  Firstly, they should have a database identifier,
which should be unique for an entity.  Secondly, they should have a
standard name.  Standard names should be unique among standard names,
but it is possible that a standard name of one entity may be used as
an alias of another.  An entity may have many aliases, and an alias
may be used for many entities.  Hence, a name (drawn from databaseIds,
standard names, and aliases) may be ambiguous in the entity to which
it refers.  This is an important concept for clients of concrete
subclasses to take into consideration, so that unexpected results are
avoided.
.SH "TODO"
.IX Header "TODO"
Currently this interface dictates that clients can retrieve GOIDs that
have been used to annotated genes.  In future, this interface is
likely to change, such that instead of GOIDs, GO::Annotation objects
are instead returned, which will be richer in the terms of information
they can give about a given annotation.  Such objects would contain a
GO::AnnotatedGene object, one or more GO::Reference objects, and an
evidence code.  The retrieval of annotations for a given database id
could then be extended to allow filtering by evidence codes, to either
include or exclude certain codes.
.PP
This interface also currently only allows retrieval of GOIDs for
genes, in future, it will be extended such that the genes can be
retrieved by \s-1GOID\s0.
.SH "Constructor"
.IX Header "Constructor"
Because this is an abstract class, there is no constructor.  A
constructor must be implemented by concrete subclasses.
.SH "Public instance methods"
.IX Header "Public instance methods"
All of these public instance methods must be implemented by concrete subclasses.
.SH "Some methods dealing with ambiguous names"
.IX Header "Some methods dealing with ambiguous names"
Because there are many names by which an annotated entity may be
referred to, that are non-unique, this interface defines a set of
methods for determining whether a name is ambiguous, and to what
database identifiers such ambiguous names may refer.
.PP
Note, that the AnnotationProvider subclasses should now be case
insensitive, though there are some caveats.  For instance, you can use
\&'cdc6' to retrieve data for \s-1CDC6\s0.  However, This if gene has been
referred to as abc1, and another referred to as \s-1ABC1\s0, then these are
treated as different, and unambiguous.  However, the text 'Abc1' would
be considered ambiguous, because it could refer to either.  On the
other hand, if a single gene is referred to as \s-1XYZ1\s0 and xyz1, and no
other genes have that name (in any casing), then Xyz1 would still be
considered unambiguous.
.SS "nameIsAmbiguous"
.IX Subsection "nameIsAmbiguous"
\&\s-1NB:\s0 \s-1API\s0 change:
.PP
nameIsAmbiguous is now case insensitive \- that is, if there is a name
that is used twice using different casing, that will be treated as
ambiguous.  Previous versions would have not treated these as
ambiguous.  In the case that a name is provided in a certain casing,
which was encountered only once, then it will be treated as
unambiguous.  This is the price of wanting a case insensitive
annotation provider...
.PP
Usage:
.PP
.Vb 1
\&    if ($annotationProvider\->nameIsAmbiguous($name)){
\&
\&        do something useful....or not....
\&
\&    }
.Ve
.SS "databaseIdsForAmbiguousName"
.IX Subsection "databaseIdsForAmbiguousName"
This public method returns an array of database identifiers for an
ambiguous name.  If the name is not ambiguous, an empty list will be
returned.
.PP
B: \s-1API\s0 change:
.PP
databaseIdsForAmbiguousName is now case insensitive \- that is, if
there is a name that is used twice using different casing, that will
be treated as ambiguous.  Previous versions would have not treated
these as ambiguous.  However, if the name provided is of the exact
casing as a name that appeared only once with that exact casing, then
it is treated as unambiguous. This is the price of wanting a case
insensitive annotation provider...
.PP
Usage:
.PP
.Vb 1
\&    my @databaseIds = $annotationProvider\->databaseIdsForAmbiguousName($name);
.Ve
.SS "ambiguousNames"
.IX Subsection "ambiguousNames"
This method returns an array of names, which from the annotation source
have been deemed to be ambiguous.
.PP
Note \- even though this is now case insensitive, if something is
called both \s-1BLAH1\s0 and blah1, we would not deem either of these to be
ambiguous.  However, if it appeared as blah1 twice, referring to two
different genes, then blah1 would be ambiguous.
.PP
Usage:
.PP
.Vb 1
\&    my @ambiguousNames = $annotationProvider\->ambiguousNames;
.Ve
.SH "Methods for retrieving GO annotations for entities"
.IX Header "Methods for retrieving GO annotations for entities"
.SS "goIdsByDatabaseId"
.IX Subsection "goIdsByDatabaseId"
This public method returns a reference to an array of GOIDs that are
associated with the supplied databaseId for a specific aspect.  If no
annotations are associated with that databaseId in that aspect, then a
reference to an empty array will be returned.  If the databaseId is
not recognized, then undef will be returned.
.PP
Usage:
.PP
.Vb 2
\&    my $goidsRef = $annotationProvider\->goIdsByDatabaseId(databaseId=>$databaseId,
\&                                                          aspect=><P|F|C>);
.Ve
.SS "goIdsByStandardName"
.IX Subsection "goIdsByStandardName"
This public method returns a reference to an array of GOIDs that are
associated with the supplied standardName for a specific aspect.  If
no annotations are associated with the entity with that standard name
in that aspect, then a a reference to an empty list will be returned.
If the supplied name is not used as a standard name, then undef will
be returned.
.PP
Usage:
.PP
.Vb 2
\&    my $goidsRef = $annotationProvider\->goIdsByStandardName(standardName=>$databaseId,
\&                                                            aspect=><P|F|C>);
.Ve
.SS "goIdsByName"
.IX Subsection "goIdsByName"
This public method returns a reference to an array of \s-1GO\s0 IDs that are
associated with the supplied name for a specific aspect.  If there are
no \s-1GO\s0 associations for the entity corresponding to the supplied name
in the provided aspect, then a reference to an empty list will be
returned.  If the supplied name does not correspond to any entity,
then undef will be returned.  Because the name can be any of the
databaseId, the standard name, or any of the aliases, it is possible
that the name might be ambiguous.  Clients of this object should first
test whether the name they are using is ambiguous, using the
\&\fInameIsAmbiguous()\fR method, and handle it accordingly.  If an ambiguous
name is supplied, then it will die.
.PP
\&\s-1NB:\s0 \s-1API\s0 change:
.PP
goIdsByName is now case insensitive \- that is, if there is a name that
is used twice using different casing, that will be treated as
ambiguous.  Previous versions would have not treated these as
ambiguous.  This is the price of wanting a case insensitive annotation
provider.  In the event that a name is provided that is ambiguous
because of case, if it matches exactly the case of one of the possible
matches, it will be treated unambiguously.
.PP
Usage:
.PP
.Vb 2
\&    my $goidsRef = $annotationProvider\->goIdsByName(name=>$name,
\&                                                    aspect=><P|F|C>);
.Ve
.SH "Methods for mapping different types of name to each other"
.IX Header "Methods for mapping different types of name to each other"
.SS "standardNameByDatabaseId"
.IX Subsection "standardNameByDatabaseId"
This method returns the standard name for a database id.
.PP
\&\s-1NB:\s0 \s-1API\s0 change
.PP
standardNameByDatabaseId is now case insensitive \- that is, if there
is a databaseId that is used twice (or more) using different casing,
it will be treated as ambiguous.  Previous versions would have not
treated these as ambiguous.  This is the price of wanting a case
insensitive annotation provider.  In the event that a name is provided
that is ambiguous because of case, if it matches exactly the case of
one of the possible matches, it will be treated unambiguously.
.PP
Usage:
.PP
.Vb 1
\&    my $standardName = $annotationProvider\->standardNameByDatabaseId($databaseId);
.Ve
.SS "databaseIdByStandardName"
.IX Subsection "databaseIdByStandardName"
This method returns the database id for a standard name.
.PP
\&\s-1NB:\s0 \s-1API\s0 change
.PP
databaseIdByStandardName is now case insensitive \- that is, if there
is a standard name that is used twice (or more) using different
casing, it will be treated as ambiguous.  Previous versions would have
not treated these as ambiguous.  This is the price of wanting a case
insensitive annotation provider.  In the event that a name is provided
that is ambiguous because of case, if it matches exactly the case of
one of the possible matches, it will be treated unambiguously.
.PP
Usage:
.PP
.Vb 1
\&    my $databaseId = $annotationProvider\->databaseIdByStandardName($standardName);
.Ve
.SS "databaseIdByName"
.IX Subsection "databaseIdByName"
This method returns the database id for any identifier for a gene (e.g.
by databaseId itself, by standard name, or by alias).  If the used
name is ambiguous, then the program will die.  Thus clients should
call the \fInameIsAmbiguous()\fR method, prior to using this method.  If the
name does not map to any databaseId, then undef will be returned.
.PP
\&\s-1NB:\s0 \s-1API\s0 change
.PP
databaseIdByName is now case insensitive \- that is, if there is a name
that is used twice using different casing, that will be treated as
ambiguous.  Previous versions would have not treated these as
ambiguous.  This is the price of wanting a case insensitive annotation
provider.  In the event that a name is provided that is ambiguous
because of case, if it matches exactly the case of one of the possible
matches, it will be treated unambiguously.
.PP
Usage:
.PP
.Vb 1
\&    my $databaseId = $annotationProvider\->databaseIdByName($name);
.Ve
.SS "standardNameByName"
.IX Subsection "standardNameByName"
This public method returns the standard name for the the gene
specified by the given name.  Because a name may be ambiguous, the
\&\fInameIsAmbiguous()\fR method should be called first.  If an ambiguous name
is supplied, then it will die with an appropriate error message.  If
the name does not map to a standard name, then undef will be returned.
.PP
\&\s-1NB:\s0 \s-1API\s0 change
.PP
standardNameByName is now case insensitive \- that is, if there is a
name that is used twice using different casing, that will be treated
as ambiguous.  Previous versions would have not treated these as
ambiguous.  This is the price of wanting a case insensitive annotation
provider.
.PP
Usage:
.PP
.Vb 1
\&    my $standardName = $annotationProvider\->standardNameByName($name);
.Ve
.SH "Other methods relating to names"
.IX Header "Other methods relating to names"
.SS "nameIsStandardName"
.IX Subsection "nameIsStandardName"
This method returns a boolean to indicate whether the supplied name is
used as a standard name.
.PP
\&\s-1NB\s0 : \s-1API\s0 change.
.PP
This is now case insensitive.  If you provide abC1, and ABc1 is a
standard name, then it will return true.
.PP
Usage :
.PP
.Vb 1
\&    if ($annotationProvider\->nameIsStandardName($name)){
\&
\&        # do something
\&
\&    }
.Ve
.SS "nameIsDatabaseId"
.IX Subsection "nameIsDatabaseId"
This method returns a boolean to indicate whether the supplied name is
used as a database id.
.PP
\&\s-1NB\s0 : \s-1API\s0 change.
.PP
This is now case insensitive.  If you provide abC1, and ABc1 is a
database id, then it will return true.
.PP
Usage :
.PP
.Vb 1
\&    if ($annotationProvider\->nameIsDatabaseId($name)){
\&
\&        # do something
\&
\&    }
.Ve
.SS "nameIsAnnotated"
.IX Subsection "nameIsAnnotated"
This method returns a boolean to indicate whether the supplied name has any 
annotations, either when considered as a databaseId, a standardName, or
an alias.  If an aspect is also supplied, then it indicates whether that
name has any annotations in that aspect only.
.PP
\&\s-1NB:\s0 \s-1API\s0 change.
.PP
This is now case insensitive.  If you provide abC1, and ABc1 has
annotation, then it will return true.
.PP
Usage :
.PP
.Vb 1
\&    if ($annotationProvider\->nameIsAnnotated(name => $name)){
\&
\&        # blah
\&
\&    }
.Ve
.PP
or:
.PP
.Vb 2
\&    if ($annotationProvider\->nameIsAnnotated(name   => $name,
\&                                           aspect => $aspect)){
\&
\&        # blah
\&
\&    }
.Ve
.SH "Other public methods"
.IX Header "Other public methods"
.SS "databaseName"
.IX Subsection "databaseName"
This method returns the name of the annotating authority of the annotations.
.PP
Usage :
.PP
.Vb 1
\&    my $databaseName = $annotationProvider\->databaseName;
.Ve
.SS "numAnnotatedGenes"
.IX Subsection "numAnnotatedGenes"
This method returns the number of entities in the annotation file that
have annotations in the supplied aspect.  If no aspect is provided,
then it will return the number of genes with an annotation in at least
one aspect of \s-1GO\s0.
.PP
Usage:
.PP
.Vb 1
\&    my $numAnnotatedGenes = $annotationProvider\->numAnnotatedGenes;
\&
\&    my $numAnnotatedGenes = $annotationProvider\->numAnnotatedGenes($aspect);
.Ve
.SS "allDatabaseIds"
.IX Subsection "allDatabaseIds"
This public method returns an array of all the database identifiers
.PP
Usage:
.PP
.Vb 1
\&    my @databaseIds = $annotationProvider\->allDatabaseIds;
.Ve
.SS "allStandardNames"
.IX Subsection "allStandardNames"
This public method returns an array of all standard names.
.PP
Usage:
.PP
.Vb 1
\&    my @standardNames = $annotationProvider\->allStandardNames;
.Ve
.SH "Protected Methods"
.IX Header "Protected Methods"
.SS "_handleMissingArgument"
.IX Subsection "_handleMissingArgument"
This protected method simply provides a simple way for concrete
subclasses to deal with missing arguments from method calls.  It will
die with an appropriate error message.
.PP
Usage:
.PP
.Vb 1
\&    $self\->_handleMissingArgument(argument=>\*(Aqblah\*(Aq);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Gavin Sherlock,  sherlock@genome.stanford.edu
