.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Boulder::Store 3"
.TH Boulder::Store 3 "2002-06-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Boulder::Store \- Simple persistent storage for Stone tag/value objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& Boulder:Store;
\&
\& my $store=new Boulder::Store(\*(Aqtest.db\*(Aq,1);
\& my $s = new Stone (Name=>\*(Aqgeorge\*(Aq,
\&                    Age=>23,
\&                    Sex=>M,
\&                    Address=>{
\&                           Street=>\*(Aq29 Rockland drive\*(Aq,
\&                           Town=>\*(AqFort Washington\*(Aq,
\&                           ZIP=>\*(Aq77777\*(Aq
\&                           }
\&                       );
\& $store\->put($s);
\& $store\->put(new Stone(Name=>\*(Aqfred\*(Aq,
\&                       Age=>30,
\&                       Sex=>M,
\&                       Address=>{
\&                                   Street=>\*(Aq19 Gravel Path\*(Aq,
\&                                   Town=>\*(AqBedrock\*(Aq,
\&                                   ZIP=>\*(Aq12345\*(Aq},
\&                       Phone=>{
\&                                 Day=>\*(Aq111\-1111\*(Aq,
\&                                 Eve=>\*(Aq222\-2222\*(Aq
\&                                 }
\&                             ));
\& $store\->put(new Stone(Name=>\*(Aqandrew\*(Aq,
\&                       Age=>18,
\&                       Sex=>M));
\&
\& $store\->add_index(\*(AqName\*(Aq);
\&
\& my $stone = $store\->get(0);
\& print "name = ",$stone\->Name;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Boulder::Store provides persistent storage for Boulder objects using a
simple DB_File implementation.  To use it, you need to have Berkeley
db installed (also known as libdb), and the Perl DB_File module.  See
the DB_File package for more details on obtaining Berkeley db if you
do not already have it.
.PP
Boulder::Store provides an unsophisticated query mechanism which takes
advantage of indexes that you specify.  Despite its lack of
sophistication, the query system is often very helpful.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.ie n .IP "$store = Boulder::Store\->new(""database/path"",$writable)" 4
.el .IP "\f(CW$store\fR = Boulder::Store\->new(``database/path'',$writable)" 4
.IX Item "$store = Boulder::Store->new(database/path,$writable)"
The \fB\f(BInew()\fB\fR method creates a new Boulder::Store object and associates
it with the database file provided in the first parameter (undef is a
valid pathname, in which case all methods work but the data isn't
stored).  The second parameter should be a \fBtrue\fR value if you want
to open the database for writing.  Otherwise it's opened read only.
.Sp
Because the underlying storage implementation is not multi-user, only
one process can have the database for writing at a time.  A
\&\fB\f(BIfcntl()\fB\fR\-based locking mechanism is used to give a process that has
the database opened for writing exclusive access to the database.
This also prevents the database from being opened for reading while
another process is writing to it (this is a \fBgood\fR thing).  Multiple
simultaneous processes can open the database read only.
.Sp
Physically the data is stored in a human-readable file with the
extension \*(L".data\*(R".
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.ie n .IP "$stone = $store\->read_record(@taglist)" 4
.el .IP "\f(CW$stone\fR = \f(CW$store\fR\->read_record(@taglist)" 4
.IX Item "$stone = $store->read_record(@taglist)"
The semantics of this call are exactly the same as in
\&\fBBoulder::Stream\fR.  Stones are returned in sequential order, starting
with the first record.  In addition to their built-in tags, each stone
returned from this call has an additional tag called \*(L"record_no\*(R".
This is the zero-based record number of the stone in the database.
Use the \fB\f(BIreset()\fB\fR method to begin iterating from the beginning of the
database.
.Sp
If called in an array context, \fB\f(BIread_record()\fB\fR returns a list of all
stones in the database that contains one or more of the provided tags.
.ie n .IP "$stone = $store\->write_record($stone [,$index])" 4
.el .IP "\f(CW$stone\fR = \f(CW$store\fR\->write_record($stone [,$index])" 4
.IX Item "$stone = $store->write_record($stone [,$index])"
This has the same semantics as \fBBoulder::Stream\fR.  A stone is
appended to the end of the database.  If successful, this call returns
the record number of the new entry.  By providing an optional second
parameter, you can control where the stone is entered.  A positive
numeric index will write the stone into the database at that position.
A value of \-1 will use the Stone's internal record number (if present)
to determine where to place it.
.ie n .IP "$stone = $store\->get($record_no)" 4
.el .IP "\f(CW$stone\fR = \f(CW$store\fR\->get($record_no)" 4
.IX Item "$stone = $store->get($record_no)"
This is random access to the database.  Provide a record number and
this call will return the stone stored at that position.
.ie n .IP "$record_number = $store\->put($stone,$record_no)" 4
.el .IP "\f(CW$record_number\fR = \f(CW$store\fR\->put($stone,$record_no)" 4
.IX Item "$record_number = $store->put($stone,$record_no)"
This is a random write to the database.  Provide a record number and
this call stores the stone at the indicated position, replacing whatever
was there before.
.Sp
If no record number is provided, this call will look for the presence
of a 'record_no' tag in the stone itself and put it back in that
position.  This allows you to pull a stone out of the database, modify
it, and then put it back in without worrying about its record number.
If no record is found in the stone, then the effect is identical to
\&\fIwrite_record()\fR.
.Sp
The record number of the inserted stone is returned from this call, or
\&\-1 if an error occurred.
.ie n .IP "$store\->delete($stone),Boulder::Store::delete($record_no)" 4
.el .IP "\f(CW$store\fR\->delete($stone),Boulder::Store::delete($record_no)" 4
.IX Item "$store->delete($stone),Boulder::Store::delete($record_no)"
These method calls delete a stone from the database.  You can provide
either the record number or a stone containing the 'record_no' tag.
\&\fBWarning\fR: if the database is heavily indexed deletes can be
time-consuming as it requires the index to be brought back into synch.
.ie n .IP "$record_count = $store\->\fIlength()\fR" 4
.el .IP "\f(CW$record_count\fR = \f(CW$store\fR\->\fIlength()\fR" 4
.IX Item "$record_count = $store->length()"
This returns the length of the database, in records.
.ie n .IP "$store\->\fIreset()\fR" 4
.el .IP "\f(CW$store\fR\->\fIreset()\fR" 4
.IX Item "$store->reset()"
This resets the database, nullifying any queries in effect, and
causing \fIread_record()\fR to begin fetching stones from the first record.
.ie n .IP "$store\->query(%query_array)" 4
.el .IP "\f(CW$store\fR\->query(%query_array)" 4
.IX Item "$store->query(%query_array)"
This creates a query on the database used for selecting stones in
\&\fB\f(BIread_record()\fB\fR.  The query is an associative array.  Three types of
keys/value pairs are allowed:
.RS 4
.ie n .IP "(1) $index=>$value" 4
.el .IP "(1) \f(CW$index\fR=>$value" 4
.IX Item "(1) $index=>$value"
This instructs Boulder::Store to look for stones containing the
specified tags in which the tag's value (determined by the Stone
\&\fB\f(BIindex()\fB\fR method) exactly matches the provided
value.  Example:
.Sp
.Vb 1
\&        $db\->query(\*(AqSTS.left_primer.length\*(Aq=>30);
.Ve
.Sp
Only the non-bracketed forms of the index string are allowed (this
is probably a bug...)
.Sp
If the tag path was declared to be an index, then this search
will be fast.  Otherwise Boulder::Store must iterate over every
record in the database.
.IP "(2) EVAL=>'expression'" 4
.IX Item "(2) EVAL=>'expression'"
This instructs Boulder::Store to look for stones in which the
provided expression evaluates to \fBtrue\fR.  When the expression
is evaluated, the variable \fB\f(CB$s\fB\fR will be set to the current 
record's stone.  As a shortcut, you can use \*(L"<index.string>\*(R"
as shorthand for \*(L"$s\->index('index.string')\*(R".
.IP "(3) EVAL=>['expression1','expression2','expression3'...]" 4
.IX Item "(3) EVAL=>['expression1','expression2','expression3'...]"
This lets you provide a whole bunch of expressions, and is exactly
equivalent to EVAL=>'(expression1) && (expression2) && (expression3)'.
.RE
.RS 4
.Sp
You can mix query types in the parameter provided to \fB\f(BIquery()\fB\fR.
For example, here's how to look up all stones in which the sex is
male and the age is greater than 30:
.Sp
.Vb 1
\&        $db\->query(\*(Aqsex\*(Aq=>\*(AqM\*(Aq,EVAL=>\*(Aq<age> > 30\*(Aq);
.Ve
.Sp
When a query is in effect, \fB\f(BIread_record()\fB\fR returns only Stones
that satisfy the query.  In an array context, \fB\f(BIread_record()\fB\fR 
returns a list of all Stones that satisfy the query.  When no
more satisfactory Stones are found, \fB\f(BIread_record()\fB\fR returns
\&\fBundef\fR until a new query is entered or \fB\f(BIreset()\fB\fR is called.
.RE
.ie n .IP "$store\->add_index(@indices)" 4
.el .IP "\f(CW$store\fR\->add_index(@indices)" 4
.IX Item "$store->add_index(@indices)"
Declare one or more tag paths to be a part of a fast index.
\&\fB\f(BIread_record()\fB\fR will take advantage of this record when processing
queries.  For example:
.Sp
.Vb 1
\&        $db\->add_index(\*(Aqage\*(Aq,\*(Aqsex\*(Aq,\*(Aqperson.pets\*(Aq);
.Ve
.Sp
You can add indexes any time you like, when the database is first
created or later.  There is a trade off:  \fB\f(BIwrite_record()\fB\fR,
\&\fB\f(BIput()\fB\fR, and other data-modifying calls will become slower as 
more indexes are added.
.Sp
The index is stored in an external file with the extension \*(L".index\*(R".
An index file is created even if you haven't indexed any tags.
.ie n .IP "$store\->\fIreindex_all()\fR" 4
.el .IP "\f(CW$store\fR\->\fIreindex_all()\fR" 4
.IX Item "$store->reindex_all()"
Call this if the index gets screwed up (or lost).  It rebuilds it
from scratch.
.SH "CAVEATS"
.IX Header "CAVEATS"
Boulder::Store makes heavy use of the \fIflock()\fR call in order to avoid
corruption of DB_File databases when multiple processes try to write
simultaneously.  \fIflock()\fR may not work correctly across \s-1NFS\s0 mounts,
particularly on Linux machines that are not running the rpc.lockd
daemon.  Please confirm that your \fIflock()\fR works across \s-1NFS\s0 before
attempting to use Boulder::Store.  If the store.t test hangs during
testing, this is the likely culprit.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln D. Stein <lstein@cshl.org>, Cold Spring Harbor Laboratory,
Cold Spring Harbor, \s-1NY\s0.  This module can be used and distributed on
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Boulder, Boulder::Stream, Stone
