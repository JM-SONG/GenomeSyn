.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Roman 3"
.TH Math::Roman 3 "2004-03-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Roman \- Arbitrary sized Roman numbers and conversion from and to Arabic.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::Roman qw(roman);
\&
\&    $a = new Math::Roman \*(AqMCMLXXIII\*(Aq;  # 1973
\&    $b = roman(\*(AqMCMLXI\*(Aq);              # 1961
\&    print $a \- $b,"\en";                # prints \*(AqXII\*(Aq
\&   
\&    $d = Math::Roman\->bzero();         # \*(Aq\*(Aq
\&    $d++;                              # \*(AqI\*(Aq  
\&    $d += 1998;                        # \*(AqMCMXCIX\*(Aq
\&    $d \-= \*(AqMCM\*(Aq;                       # \*(AqXCIX\*(Aq
\&
\&    print "$d\en";                      # string       "MCMIC"
\&    print $d\->as_number(),"\en";        # Math::BigInt "+1999"
.Ve
.SH "REQUIRES"
.IX Header "REQUIRES"
perl5.005, Exporter, Math::BigInt
.SH "EXPORTS"
.IX Header "EXPORTS"
Exports nothing on default, but can export \f(CW\*(C`as_number()\*(C'\fR, \f(CW\*(C`roman()\*(C'\fR, 
and \f(CW\*(C`error()\*(C'\fR.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Well, it seems I have been infected by the Perligata-Virus, too. ;o)
.PP
This module lets you calculate with Roman numbers, as if they were big
integers. The numbers can have arbitrary length and all the usual functions
from Math::BigInt are available.
.SS "\s-1INPUT\s0"
.IX Subsection "INPUT"
The Roman single digits are as follows:
.PP
.Vb 7
\&        I       1
\&        V       5
\&        X       10
\&        L       50
\&        C       100
\&        D       500
\&        M       1000
.Ve
.PP
The following (quite modern) rules are in effect:
.Sp
.RS 1
Each of I, X and C can be repeated up to 3 times, V, L and D only once. 
Technically, M could be used up to four times, but this module imposes
no limit on this to allow arbitrarily big numbers.
.Sp
A Roman number consists of \fBtokens\fR, each token is either a digit from
\&\s-1IVXLCDM\s0 or consist of two digits, whereas the first digit is smaller than
the second one. In the latter case the first digit is subtracted from the
second (e.g. \s-1IV\s0 means 4, not 6).
.Sp
The smaller number must be a power of ten (I, X or C) and precede a 
number no larger than 10 times its own value. The smaller number itself 
can be preceded only by a number at least 10 times greater (e.g. \s-1LXC\s0 is 
invalid) and it must also be larger than any numeral that follows the one
from which it is being subtracted (e.g. \s-1CMD\s0 is invalid).
.Sp
Each token must be smaller than the token before (e.g. \s-1IIV\s0 is invalid,
since I is smaller than \s-1IV\s0).
.Sp
The input will be checked and the result will be a 'NaN' if the check 
fails. You can get the cause with \f(CW\*(C`Math::Roman::error()\*(C'\fR until you try 
to create the next Roman number.
.Sp
The default list of valid tokens a Roman number can consist of is thus:
.Sp
.Vb 10
\&        III     3
\&        XXX     30
\&        CCC     300
\&        II      2
\&        XX      20
\&        CC      200
\&        IV      4
\&        IX      9
\&        XL      40
\&        XC      90
\&        CD      400
\&        CM      900
\&        I       1
\&        V       5
\&        X       10
\&        L       50
\&        C       100
\&        D       500
\&        M       1000
.Ve
.Sp
The default list of invalid tokens is as follows:
.Sp
.Vb 3
\&        IIII            XXXX            CCCC
\&        DD              LL              VV              
\&        C[MD][CDM]      X[LC][XLCDM]    I[VX][IVXLCDM]
.Ve
.RE
.PP
Thanx must go to http://netdirect.net/~charta/Roman_numerals.html for 
clarifications.
.SS "\s-1OUTPUT\s0"
.IX Subsection "OUTPUT"
The output will always be of the shortest possible form, and the tokens
will be arranged in a decreasing order.
.SH "BENDING THE RULES"
.IX Header "BENDING THE RULES"
You can use \f(CW\*(C`Math::Roman::tokens()\*(C'\fR to get an array with all the defined 
tokens and their value. Tokens with a value of \-1 are invalid, all others 
are valid. The format is token0, value0, token1, value1...
.PP
You can create your own set and store it with \f(CW\*(C`Math::Roman::tokens()\*(C'\fR.
The routine expects an array of the form token, value, token, value... 
etc.  Each token can be a simple string or regular expresion. Values of
\&\-1 indicate invalid tokens.
.PP
Here is an example that removes the subtraction (only addition is valid) 
as well as most of the other rules. It then parses '\s-1XIIII\s0' to be 14, then
redefine the token set completely and parses '\s-1AAB\s0' to be 25:
.Sp
.Vb 1
\&        use Math::Roman;
\&
\&        Math::Roman::tokens( qw(I 1  V 5  X 10  L 50  C 100  D 500  M 1000));
\&        $r = Math::Roman::roman(\*(AqXIIII\*(Aq);
\&        print "\*(Aq$r\*(Aq is ",$r\->as_number(),"\en";
\&        $r = Math::Roman::roman(\*(AqXV\*(Aq);
\&        print "\*(Aq$r\*(Aq is ",$r\->as_number(),"\en";
\&        Math::Roman::tokens ( qw(A 10 B 5) );
\&        $r = Math::Roman::roman(\*(AqAAB\*(Aq);
\&        print "\*(Aq$r\*(Aq is ",$r\->as_number(),"\en";
.Ve
.PP
Another idea is to implement the dash over symbols, this indicates
multiplying by 1000. Since it is hard to do this in \s-1ASCII\s0, lower-case
letters could be used like in the following:
.PP
.Vb 1
\&        use Math::Roman;
\&        
\&        # will wrongly ommit the \*(AqM\*(Aqs, but so much \*(AqM\*(Aqs would not fit
\&        # on your screen anyway
\&        print \*(Aqold: \*(Aq,new Math::Roman (\*(Aq+12345678901234567890\*(Aq),"\en";
\&        @a = Math::Roman::tokens();
\&        push @a, qw ( v 5000  x 10000  l 50000  c 100000  d 500000  
\&                      m 1000000 );
\&        Math::Roman::tokens(@a);
\&        print \*(Aqnew: \*(Aq,new Math::Roman (\*(Aq+12345678901234567890\*(Aq),"\en";
.Ve
.SH "USEFULL METHODS"
.IX Header "USEFULL METHODS"
.SS "\fB\fP\f(BInew()\fP\fB\fP"
.IX Subsection "new()"
.Vb 1
\&            new();
.Ve
.PP
Create a new Math::Roman object. Argument is a Roman number as string, 
like '\s-1MCMLXXIII\s0' (1973) of the form /^[\s-1IVXLCDM\s0]*$/ (see above for further
rules) or a string number as used by Math::BigInt.
.SS "\fB\fP\f(BIroman()\fP\fB\fP"
.IX Subsection "roman()"
.Vb 1
\&            roman();
.Ve
.PP
Just like new, but you can import it to write shorter code.
.SS "\fB\fP\f(BIerror()\fP\fB\fP"
.IX Subsection "error()"
.Vb 1
\&            Math::Roman::error();
.Ve
.PP
Return error of last number creation when result was NaN.
.SS "\fB\fP\f(BIbstr()\fP\fB\fP"
.IX Subsection "bstr()"
.Vb 1
\&            $roman\->bstr();
.Ve
.PP
Return a string representing the internal value as a Roman number 
according to the aforementioned rules. A zero will be represented by 
\&''.  The output will only consist of valid tokens, and not contain a 
sign.  Use \f(CW\*(C`as_number()\*(C'\fR if you need the sign.
.PP
This function always generates the shortest possible form.
.SS "\fB\fP\f(BIas_number()\fP\fB\fP"
.IX Subsection "as_number()"
.Vb 1
\&            $roman\->as_number();
.Ve
.PP
Return a string representing the internal value as a normalized arabic
number, including sign.
.SH "DETAILS"
.IX Header "DETAILS"
Uses internally Math::BigInt to do the math, all with overloaded
operators.
.PP
Roman has neither negative numbers nor zero, but this module handles 
these, too. You will get only the absolute value as Roman number, but 
can look at the sign with \f(CW\*(C`sign()\*(C'\fR or use \f(CW\*(C`as_number()\*(C'\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&  use Math::Roman qw(roman);
\&
\&  print Math::Roman\->new(\*(AqMCMLXXII\*(Aq)\->as_number(),"\en";
\&  print Math::Roman\->new(\*(AqLXXXI\*(Aq)\->as_number(),"\en";
\&  print roman(\*(AqMDCCCLXXXVIII\*(Aq)\->as_number(),"\en";
\&
\&  $a = roman(\*(Aq1311\*(Aq);
\&  print "$a is ",$a\->as_number(),"\en";
\&
\&  $a = roman(\*(AqMCMLXXII\*(Aq);
\&  print "\e$a is now $a (",$a\->as_number(),")\en";
\&  $a++; $a += \*(AqMCMXII\*(Aq; $a = $a * \*(AqX\*(Aq \- \*(AqI\*(Aq;
\&  print "\e$a is now $a (",$a\->as_number(),")\en";
.Ve
.SH "LIMITS"
.IX Header "LIMITS"
.IP "Internal Number Length" 1
.IX Item "Internal Number Length"
For the actual math, the same limits as in Math::BigInt apply.
.IP "Output length" 1
.IX Item "Output length"
The output in Roman is limited to 65536 times the biggest symbol. With
the default set this is 'M', so the biggest Roman number you can print
is 65536000 \- and it will give you 64 KBytes M's in a row. This could be
fixed, but who really needs it? ;)
.IP "Number Rules" 1
.IX Item "Number Rules"
The rule \*(L"Each token must be greater than the token before\*(R" is
hard-coded in and can not be overcome. So '\s-1IIX\s0' will be invalid for
subtraction-less numbers unless you define an '\s-1IIX\s0' token with a value
of 12.
.SH "BUGS"
.IX Header "BUGS"
.IP "Importing functions" 1
.IX Item "Importing functions"
You can not import ordinary math functions like \f(CW\*(C`badd()\*(C'\fR and write
things like:
.Sp
.Vb 1
\&        use Math::Roman qw(badd);               # will fail
\&
\&        $a = badd(\*(AqMCM\*(Aq,\*(AqM\*(Aq);                   # does not work
\&        $a = Math::Roman::badd(\*(AqMCM\*(Aq,\*(AqM\*(Aq);      # neither
.Ve
.Sp
It is be possible to make this work, but this takes quite a lot of
Copy&Paste code, and some small overhead price for every calculation.
I think this is really not needed, since you can always use:
.Sp
.Vb 1
\&        use Math::Roman;
\&
\&        $a = new Math::Roman \*(AqMCM\*(Aq; $a += \*(AqM\*(Aq;  # neat isn\*(Aqt it?
\&        $a = Math::Roman\->badd(\*(AqMCM\*(Aq,\*(AqM\*(Aq);      # or this
.Ve
.IP "'0'\-'9' as tokens" 1
.IX Item "'0'-'9' as tokens"
0\-9 in the token set produce wrong results in \fInew()\fR if the given argument
consists only of 0\-9. That is because first a BigInt is tried to be
constructed, and in this case, would succeed.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
If you use this module in one of your projects, then please email me. I want
to hear about how my code helps you ;)
.PP
Copyright (C) MCMXCIX-MMIV by Tels <http://bloodgate.com/>
