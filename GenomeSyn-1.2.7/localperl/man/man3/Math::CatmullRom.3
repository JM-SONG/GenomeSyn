.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::CatmullRom 3"
.TH Math::CatmullRom 3 "2003-09-01" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::CatmullRom \- Calculate Catmull\-Rom splines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Math::CatmullRom;
\&
\&        # create curve passing through list of control points
\&        my $curve = new Math::CatmullRom( $x1, $y1, $x2, $y2, ..., $xn, $yn );
\&
\&        # or pass reference to list of control points
\&        my $curve = new Math::CatmullRom( [ $x1, $y1, $x2, $y2, ..., $xn, $yn ] );
\&
\&        # determine (x, y) at point along curve, range 0.0 \-> 1.0
\&        my ($x, $y) = $curve\->point( 0.5 );
\&
\&        # returns list ref in scalar context
\&        my $xy = $curve\->point( 0.5 );
\&
\&        # return list of 20 (x, y) points along curve
\&        my @curve = $curve\->curve( 20 );
\&
\&        # returns list ref in scalar context
\&        my $curve = $curve\->curve( 20 );
\&
\&        # include start and finish points by adding false data points
\&        $curve\->plot_all;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an algorithm to generate plots for Catmull-Rom splines.
.PP
A Catmull-Rom spline can be considered a special type of Bezier curve that
guarantees that the curve will cross every control point starting at the
second point and terminating at the penultimate one. For this reason the
minimum number of control points is 4.
.PP
To plot a curve where you have a set of points but want the curve to be
drawn through the start and finish points you can tell the module to plot
all of the points. In this case it assumes that there are two extra points,
prior to the start point with the same values as the start point and one
prior to the finish point with the same values as the finish point. This is
really just a convenience function for certain kinds of plot.
.PP
A new Catmull-Rom spline is created using the \fInew()\fR constructor, passing a
list of control points.
.PP
.Vb 1
\&        use Math::CatmullRom;
\&
\&        # create curve passing through list of control points 
\&        my @control = ( $x1, $y1, $x2, $y2, $x3, $y3, $x4, $y4 );
\&        my $spline = new Math::CatmullRom( @control );
.Ve
.PP
Alternatively, a reference to a list of control points may be passed.
.PP
.Vb 2
\&        # or pass reference to list of control points
\&        my $spline = new Math::CatmullRom( \e@control );
.Ve
.PP
The point( \f(CW$theta\fR ) method can be called on the object, passing a value in
the range 0.0 to 1.0 which represents the distance along the spline.  When
called in list context, the method returns the x and y coordinates of that
point on the curve.
.PP
.Vb 2
\&        my ( $x, $y ) = $curve\->plot( 0.75 );
\&        print "X : $x\enY : $y\en";
.Ve
.PP
When called in a scalar context, it returns a reference to a list containing
the X and Y coordinates.
.PP
.Vb 2
\&        my $point = $curve\->plot( 0.75 );
\&        print "X : $point\->[0]\enY : $point\->[1]\en";
.Ve
.PP
The curve( \f(CW$n\fR, \f(CW$per_segment\fR ) method can be used to return a set of points
sampled along the length of the curve (i.e. in the range 0.0 <= \f(CW$theta\fR <=
1.0).
.PP
The parameter indicates the number of sample points required. The method
returns a list of ($x1, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, ..., \f(CW$xn\fR, \f(CW$yn\fR) points when called in
list context, or a reference to such an array when called in scalar context.
.PP
The \f(CW$per_segment\fR parameter determines whether \f(CW$n\fR points total will be plotted
or \f(CW$n\fR points between every point, defaulting to \f(CW$n\fR points total.
.PP
.Vb 1
\&        my @points = $curve\->curve( 10, 1 );
\&
\&        while( @points )
\&        {
\&                my ( $x, $y ) = splice( @points, 0, 2 );
\&                print "X : $x\enY : $y\en";
\&        }
\&
\&        my $points = $curve\->curve( 50 );
\&
\&        while( @$points )
\&        {
\&                my ( $x, $y ) = splice( @$points, 0, 2 );
\&                print "X : $x\enY : $y\en";
\&        }
.Ve
.SH "TODO"
.IX Header "TODO"
Test, test, test.
.SH "BUGS"
.IX Header "BUGS"
None known so far. Please report any and all to Nigel Rantor <\fIwiggly@wiggly.org\fR>
.SH "SUPPORT / WARRANTY"
.IX Header "SUPPORT / WARRANTY"
This module is free software. \s-1IT\s0 \s-1COMES\s0 \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0.
.SH "LICENSE"
.IX Header "LICENSE"
The Math::CatmullRom module is Copyright (c) 2003 Nigel Rantor. England. All
rights reserved.
.PP
You may distribute under the terms of either the \s-1GNU\s0 General Public License
or the Artistic License, as specified in the Perl \s-1README\s0 file.
.SH "AUTHORS"
.IX Header "AUTHORS"
Nigel Rantor <\fIwiggly@wiggly.org\fR>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::Bezier.
