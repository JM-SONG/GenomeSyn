.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GO::TermFinder 3"
.TH GO::TermFinder 3 "2009-11-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GO::TermFinder \- identify GO nodes that annotate a group of genes with a significant p\-value
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package is intended to provide a method whereby the P\-values of a
set of \s-1GO\s0 annotations can be determined for a set of genes, based on
the number of genes that exist in the particular genome (or in a
selected background distribution from the genome), and their
annotation, and the frequency with which the \s-1GO\s0 nodes are annotated
across the provided set of genes.  The P\-value is simply calculated
using the hypergeometric distribution as the probability of x or more
out of n genes having a given annotation, given that G of N have that
annotation in the genome in general.  We chose the hypergeometric
distribution (sampling without replacement) since it is more accurate,
though slower to calculate, than the binomial distribution (sampling
with replacement).
.PP
In addition, a corrected p\-value can be calculated, to correct for
multiple hypothesis testing.  The correction factor used is the total
number of nodes to which the provided list of genes are annotated,
excepting any nodes which have only a single annotation in the
background, as a priori, we know that these cannot be significantly
enriched.  The client has access to both the corrected and uncorrected
values.  It is also possible to correct the p\-value using 1000
simulations, which control the Family Wise Error Rate \- using this
option suggests that the Bonferroni correction is in fact somewhat
liberal, rather than conservative, as might be expected.  Finally, the
False Discovery Rate can also be calculated.
.PP
The general idea is that a list of genes may have been identified for
some reason, e.g. they are co-regulated, and TermFinder can be used to
find out if any nodes annotate the set of genes to a level which is
extremely improbable if the genes had simply been picked at random.
.SH "TODO"
.IX Header "TODO"
1.  May want the client to decide the behavior for ambiguous names,
    rather than having it hard coded (e.g. always ignore; use if
    standard name (current implementation); use all databaseIds for
    the ambiguous name; decide on a case by case basis (potentially
    useful if running on command line)).
.PP
2.  Create new GO::Hypothesis and GO::HypothesisSet objects, so that
    it is easier to access the information generated about the p\-value
    etc. of any particular \s-1GO\s0 node that annotates a set of genes.
.PP
3.  Instead of all the global variables, \f(CW$k\fR..., replace them with
    constants, which may improve runtime, as the optimizer should
    optimize the hash look ups to look like hard-coded strings at
    runtime, rather than variable lookups.
.PP
4.  Lots of other stuff....
.SH "Instance Constructor"
.IX Header "Instance Constructor"
.SS "new"
.IX Subsection "new"
This is the constructor.  It expects to be passed named arguments for
an annotationProvider, and an ontologyProvider.  In addition, it must
be told the aspect of the ontology provider, so that it knows how to
query the annotationProvider.
.PP
There are also some additional, optional arguments:
.PP
population:
.PP
This argument allows a client to indicate the population that should
used to calculate a background distribution of \s-1GO\s0 terms.  In the
absence of population argument, then the background distribution will
be drawn from all genes in the annotationProvider.  This should be
provided as an array reference, and no ambiguous names should be
provided (see AnnotationProvider for details of name ambiguity).  This
option is particularly pertinent in a case where for example you
assayed only 2000 genes in a two hybrid experiment, and found 20
interesting ones.  To find significant terms, you need to do it in the
context of the genes that you assayed, not in the context of all genes
with annotation.
.PP
Note, new in version 0.71, if you provided a population as the
background distribution from which genes have been drawn, any genes
provided to the findTerms method that are not in the background
distribution will be discarded from the calculations.  The identity of
these genes can be retrieved using the \fIdiscardedGenes()\fR method, after
the \fIfindTerms()\fR method has been called.
.PP
totalNumGenes:
.PP
This argument allows a client to indicate that the size of the
background distribution is in fact larger that the number of genes
that exist in the annotation provider, and the extra genes are merely
assumed to be entirely unannotated.
.PP
\&\s-1NB:\s0 This is an \s-1API\s0 change, as totalNumGenes was previously required.
.PP
Thus \- if using 'population', the total number of genes considered as
the background will be the number of genes in the provided population.
If not using 'population', then the number of genes that will be
considered as the total population will be the number of genes in the
annotationProvider.  However, if the totalNumGenes argument is
provided, then that number will be used as the size of the population.
If it is not larger than the total number of genes in the
annotationParser, then the number of genes in the annotationParser
will be used.  The totalNumGenes and the population arguments are
mutually exclusive, and both should not be provided at the same time.
.PP
Usage ($num is larger than the number of genes with annotations):
.PP
.Vb 4
\&   my $termFinder = GO::TermFinder\->new(annotationProvider=> $annotationProvider,
\&                                        ontologyProvider  => $ontologyProvider,
\&                                        totalNumGenes     => $num,
\&                                        aspect            => <P|C|F>);
.Ve
.PP
Usage (use all annotated genes as population):
.PP
.Vb 3
\&   my $termFinder = GO::TermFinder\->new(annotationProvider=> $annotationProvider,
\&                                        ontologyProvider  => $ontologyProvider,
\&                                        aspect            => <P|C|F>);
.Ve
.PP
Usage (use a subset of genes as the background population):
.PP
.Vb 4
\&   my $termFinder = GO::TermFinder\->new(annotationProvider=> $annotationProvider,
\&                                        ontologyProvider  => $ontologyProvider,
\&                                        population        => \e@genes,
\&                                        aspect            => <P|C|F>);
.Ve
.SH "Instance Methods"
.IX Header "Instance Methods"
.SS "findTerms"
.IX Subsection "findTerms"
This method returns an array of hash references, one for each GO::Node
that was tested as a hypothesis, that indicates which terms annotate
the list of genes with what P\-values.  The contents of the hashes in
the returned array depend on some of the run time options.  They are:
.PP
.Vb 2
\&    key                   value
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.PP
Always Present:
.PP
.Vb 1
\&    NODE                  A GO::Node
\&
\&    PVALUE                The P\-value for having the observed number of
\&                          annotations that the provided list of genes
\&                          has to that node.
\&
\&    NUM_ANNOTATIONS       The number of genes within the provided list that
\&                          are annotated to the node.
\&
\&    TOTAL_NUM_ANNOTATIONS The number of genes in the population (total
\&                          or provided) that are annotated to the node.
\&
\&    ANNOTATED_GENES       A hash reference, whose keys are the
\&                          databaseIds that are annotated to the node,
\&                          and whose values are the original name
\&                          supplied to the findTerms() method.
.Ve
.PP
Present if corrected p\-values are calculated:
.PP
.Vb 7
\&    CORRECTED_PVALUE      The CORRECTED_PVALUE is the PVALUE, but corrected
\&                          for multiple hypothesis testing, due to the
\&                          fact that you are more likely to generate
\&                          significant looking p\-values if you test a
\&                          lot of hypotheses.  See below for details of
\&                          how this pvalue is calculated, and the
\&                          options associated with it.
.Ve
.PP
Present if p\-values were corrected by simulation:
.PP
.Vb 2
\&    NUM_OBSERVATIONS      The number of simulations in which a p\-value as
\&                          good as this one, or better, was observed.
.Ve
.PP
Present if the False Discovery Rate is calculated:
.PP
.Vb 4
\&    FDR_RATE              The False Discovery Rate \- this is a fraction 
\&                          of how many of the nodes with p\-values as good or 
\&                          better than the node with this FDR would be expected 
\&                          to be false positives.
\&
\&    FDR_OBSERVATIONS      The average number of nodes during simulations 
\&                          that had an uncorrected p\-value as good or better
\&                          than the p\-value of this node.
\&
\&    EXPECTED_FALSE_POSITIVES The expected number of false positives if this node
\&                             is chosen as the cut\-off.
.Ve
.PP
The entries in the returned array are sorted by increasing p\-value
(i.e. least likely is first).  If there is a tie in the p\-value, then
the sort order is determined by \s-1GOID\s0, using a cmp comparison.
.PP
\&\fIfindTerm()\fR expects to be passed, by reference, a list of gene names
for which terms will be found.  If a passed in name is ambiguous (see
AnnotationProvider), then the following will occur:
.PP
.Vb 2
\&    1) If the name can be used as a standard name, it will assume that
\&       it is that.
\&
\&    2) Otherwise it will not use it.
.Ve
.PP
Currently a warning will be printed to \s-1STDOUT\s0 in the case of an
ambiguous name being used.
.PP
The passed in gene names are converted into a list of databaseIds.  If
a gene does not map to a databaseId, then an undef is put in the list
\&\- however, if the same gene name, which does not map to a databaseId,
is used twice then it will produce only one undef in the list.  If
more than one gene name maps to the same databaseId (either because
you used the same name twice, or you used an alias as well), then that
databaseId is only put into the list once, and a warning is printed.
.PP
If a gene name does not have any information returned from the
AnnotationProvider, then it is assumed that the gene is entirely
unannotated.  For these purposes, TermFinder annotates such genes to
the root node (Gene_Ontology), its immediate child (which indicates
the aspect of the ontology (such as biological_process), and a dummy
go node, corresponding to unannotated.  This node will have a goid of
\&'\s-1GO:XXXXXXX\s0', and a term name of 'unannotated'.  No other information
will be set up for this GO::Node, so you should not count on being
able to retrieve it.  What it does mean is that you can determine if
the predominant feature of a set of genes is that they have no
annotation.
.PP
If more genes are provided that have been indicated exist in the
genome (as provided during object construction), then an error message
will be printed out, and an empty list will be returned.
.PP
In addition, it is possible that for a small list of genes, that no
hypotheses will be tested \- in this case, those genes will only have
annotated nodes with a count of 1, other than the Gene_Ontology node
itself, and the node corresponding to the aspect of the ontology.
Neither of these are considered for p\-value testing, as a priori they
must have a p\-value of 1.
.PP
\&\s-1MULTIPLE\s0 \s-1HYPOTHESIS\s0 \s-1CORRECTION\s0
.PP
An optional argument, 'correction' may be used, which indicates what
method of multiple hypothesis correction should be used.  Multiple
hypothesis correction attempts to keep the overall chance of getting
any false positives at the same level (e.g. 0.05).  Acceptable values
are:
.PP
bonferroni, none, simulation
.PP
.Vb 5
\& : \*(Aqbonferroni\*(Aq will correct the p\-values by using as the correction
\&    factor the total number of nodes to which the provided list of
\&    genes are annotated, either directly or indirectly, excepting any
\&    nodes that are annotated only once in the background distribution,
\&    as, a priori, these cannot be overrepresented.
\&
\& : \*(Aqnone\*(Aq will perform no multiple hypothesis correction
\&
\& : \*(Aqsimulation\*(Aq will run 1000 simulations with random lists of genes
\&   (the same size as the originally provided gene list), and determine
\&   a corrected value by how many simulations produced a p\-value better
\&   than the p\-value associated with one of the real hypotheses.
\&   E.g. if a node from the real data has a p\-value of 0.05, but a
\&   p\-value that good or better is generated in 500 out of 1000 trials,
\&   the corrected pvalue will be 0.5.  In the case that a p\-value
\&   generated from a real list of genes is never seen in the
\&   simulations, it will be given a corrected p\-value of < 0.001, and
\&   the NUM_OBSERVATIONS attribute of the hypothesis will be 0.  Using
\&   this option takes 1000 time as long!
.Ve
.PP
The default for this argument, if not provided, is bonferroni.
.PP
\&\s-1FALSE\s0 \s-1DISCOVERY\s0 \s-1RATE\s0
.PP
As a way of preempting the potential problems of using p\-values
corrected for multiple hypothesis testing, the False Discovery Rate
can instead be calculated, and you can instead set your cutoff based
on an acceptable false discovery rate, such as 0.01 (1%), or 0.05 (5%)
etc.  Thus, the optional argument 'calculateFDR' can be used.  A
non-zero value means that the False Discovery Rate will be calculated
for each node, such that you can determine, if you chose your p\-value
cut-off at that node, what the \s-1FDR\s0 would be.  The \s-1FDR\s0 is calculated by
running 50 simulations, and counting the average number of times a
p\-value as good or better that a p\-value generated from the real data
is seen.  This is used as the numerator.  The denominator is the
number of p\-values in the real data that are as good or better than
it.
.PP
Usage example \- in this example, the default (Bonferroni) correction
is used to calculate a corrected p\-value, and in addition, the False
Discovery Rate is also calculated:
.PP
.Vb 2
\&    my @pvalueStructures = $termFinder\->findTerms(genes        => \e@genes,
\&                                                  calculateFDR => 1);
\&
\&    my $hypothesis = 1;                                             
\&
\&    foreach my $pvalue (@pvalueStructures){
\&
\&    print "\-\- $hypothesis of ", scalar @pvalueStructures, "\-\-\en",
\&
\&        "GOID\et", $pvalue\->{NODE}\->goid, "\en",
\&
\&        "TERM\et", $pvalue\->{NODE}\->term, "\en",
\&
\&        "P\-VALUE\et", $pvalue\->{PVALUE}, "\en",
\&
\&        "CORRECTED P\-VALUE\et", $pvalue\->{CORRECTED_PVALUE}, "\en",
\&
\&        "FALSE DISCOVERY RATE\et", $pvalue\->{FDR_RATE}, "\en",
\&        
\&        "NUM_ANNOTATIONS\et", $pvalue\->{NUM_ANNOTATIONS}, " (of ", $pvalue\->{TOTAL_NUM_ANNOTATIONS}, ")\en",
\&
\&        "ANNOTATED_GENES\et", join(", ", values (%{$pvalue\->{ANNOTATED_GENES}})), "\en\en";
\&
\&        $hypothesis++;
\&
\&    }
.Ve
.PP
If a background population had been provided when the object was
constructed, you should check to see if any of your genes for which
you are finding terms were discarded, due to not being found in the background 
population, e.g.:
.PP
.Vb 2
\&    my @pvalueStructures = $termFinder\->findTerms(genes        => \e@genes,
\&                                                  calculateFDR => 1);
\&
\&    my @discardedGenes = $termFinder\->discardedGenes;
\&
\&    if (@discardedGenes){
\&
\&        print "The following genes were not considered in the pvalue
\&calculations, as they were not found in the provided background
\&population.\en\en", join("\en", @discardedGenes), "\en\en";
\&
\&    }
.Ve
.SS "discardedGenes"
.IX Subsection "discardedGenes"
This method returns an array of genes which were discarded from the
pvalue calculations, because they could not be found in the background
population.  It should only be called after findTerms.  It will either
return an empty list, if no genes were discarded, or an array of genes
that were discarded.
.PP
Usage:
.PP
.Vb 2
\&    my @pvalueStructures = $termFinder\->findTerms(genes        => \e@genes,
\&                                                  calculateFDR => 1);
\&
\&    my @discardedGenes = $termFinder\->discardedGenes;
\&
\&    if (@discardedGenes){
\&
\&        print "The following genes were not considered in the pvalue
\&calculations, as they were not found in the provided background
\&population.\en\en", join("\en", @discardedGenes), "\en\en";
\&
\&    }
.Ve
.SS "genesDatabaseIds"
.IX Subsection "genesDatabaseIds"
This method returns an array of databaseIds corresponding to the genes
that were used for the \fIfindTerms()\fR method.  Thus it allows a client to
find out how many actual entities their list of genes that were passed
in mapped to, e.g. they may have passed in the same thing with two
different names.  Using this method, immediately following use of the
findTerms method, they will determine how many genes their list
collapsed to.
.SS "totalNumGenes"
.IX Subsection "totalNumGenes"
This returns the total number of genes that are in the background set
of genes from which the genes of interest were drawn.  Unannotated
genes are included in this count.
.SS "aspect"
.IX Subsection "aspect"
Returns the aspect with the the GO::TermFinder object was constructed.
.PP
Usage:
.PP
.Vb 1
\&    my $aspect = $termFinder\->aspect;
.Ve
.SH "Authors"
.IX Header "Authors"
.Vb 3
\&    Gavin Sherlock; sherlock@genome.stanford.edu
\&    Elizabeth Boyle; ell@mit.edu
\&    Ihab Awad; ihab@genome.stanford.edu
.Ve
