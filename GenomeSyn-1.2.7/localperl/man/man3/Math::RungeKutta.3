.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RungeKutta 3"
.TH RungeKutta 3 "2010-08-21" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::RungeKutta.pm \- Integrating Systems of Differential Equations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Math::RungeKutta;
\&
\& # When working on data in an array ...
\& sub dydt { my ($t, @y) = @_;   # the derivative function
\&   my @dydt; ... ; return @dydt;
\& }
\& @y = @initial_y; $t=0; $dt=0.4;  # the initial conditions
\& # For automatic timestep adjustment ...
\& while ($t < $tfinal) {
\&    ($t, $dt, @y) = &rk4_auto(\e@y, \e&dydt, $t, $dt, 0.00001);
\&    &display($t, @y);
\& }
\& # Or, for fixed timesteps ...
\& while ($t < $tfinal) {
\&   ($t, @y) = &rk4(\e@y, \e&dydt, $t, $dt); # Merson\*(Aqs 4th\-order method
\&   &display($t, @y);
\& }
\& # alternatively, though not so accurate ...
\& ($t, @y) = &rk2(\e@y, \e&dydt, $t, $dt);   # Heun\*(Aqs 2nd\-order method
\&
\& # Or, working on data in a hash...
\& sub dydt { my ($t, %y) = @_;   # the derivative function
\&   my %dydt; ... ; return %dydt;
\& }
\& %y = %initial_y; $t=0; $dt=0.4;  # the initial conditions
\& # For automatic timestep adjustment on hashes ...
\& while ($t < $tfinal) {
\&    ($t, $dt, %y) = &rk4_auto(\e%y, \e%dydt, $t, $dt, 0.00001);
\&    &display($t, %y);
\& }
\& # Or, for fixed timesteps on hashes ...
\& while ($t < $tfinal) {
\&   ($t, %y) = &rk4(\e%y, \e%dydt, $t, $dt); # Merson\*(Aqs 4th\-order method
\&   &display($t, %y);
\& }
\& # alternatively, though not so accurate ...
\& ($t, %y) = &rk2(\e%y, \e%dydt, $t, $dt);   # Heun\*(Aqs 2nd\-order method
\&
\& # or, also available but not exported by default ...
\& import qw(:ALL);
\& ($t, @y) = &rk4_classical(\e@y, \e&dydt, $t, $dt); # Runge\-Kutta 4th\-order
\& ($t, @y) = &rk4_ralston(\e@y, \e&dydt, $t, $dt);   # Ralston\*(Aqs 4th\-order
\& # or similarly for data in hashes.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
RungeKutta.pm offers algorithms for the numerical integration
of simultaneous differential equations of the form
.PP
.Vb 1
\& dY/dt = F(t,Y)
.Ve
.PP
where Y is an array of variables whose initial values Y(0) are
known, and F is a function known from the dynamics of the problem.
.PP
The Runge-Kutta methods all involve evaluating the derivative function
F(t,Y) more than once, at various points within the timestep, and
combining the results to reach an accurate answer for the Y(t+dt).
This module only uses explicit Runge-Kutta methods; the implicit methods
involve, at each timestep, solving a set of simultaneous equations
involving both Y(t) and F(t,Y), and this is generally intractable.
.PP
Three main algorithms are offered.  \fIrk2\fR is Heun's 2nd\-order
Runge-Kutta algorithm, which is relatively imprecise, but does have
a large range of stability which might be useful in some problems.  \fIrk4\fR
is Merson's 4th\-order Runge-Kutta algorithm, which should be the normal
choice in situations where the step-size must be specified.  \fIrk4_auto\fR
uses the step-doubling method to adjust the step-size of \fIrk4\fR automatically
to achieve a specified precision; this saves much fiddling around trying
to choose a good step-size, and can also save \s-1CPU\s0 time by automatically
increasing the step-size when the solution is changing only slowly.
.PP
\&\fIPerl\fR is not the right language for high-end numerical integration like
global weather simulation, colliding galaxies and so on (if you need
something like this you could check out \fIxmds\fR).  But as Gear says,
\&\*(L"Many equations that are solved on digital computers can be classified
as trivial by the fact that even with an inefficient method of solution,
little computer time is used. Economics then dictates that the best method
is the one that minimises the human time of preparation of the program.\*(R"
.PP
This module has been designed to be robust and easy to use, and should
be helpful in solving systems of differential equations which arise
within a \fIPerl\fR context, such as economic, financial, demographic
or ecological modelling, mechanical or process dynamics, etc.
.PP
Version 1.07
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.ie n .IP "\fIrk2\fR( \e@y, \e&dydt, $t, $dt )" 3
.el .IP "\fIrk2\fR( \e@y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR )" 3
.IX Item "rk2( @y, &dydt, $t, $dt )"
.PD 0
.ie n .IP "\fIrk2\fR( \e%y, \e&dydt, $t, $dt )" 3
.el .IP "\fIrk2\fR( \e%y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR )" 3
.IX Item "rk2( %y, &dydt, $t, $dt )"
.PD
where the arguments are:
 \fI\e@y\fR a reference to the array of initial values of variables,
 \fI\e%y\fR a reference to the hash of initial values of variables,
 \fI\e&dydt\fR a reference to the function calculating the derivatives,
 \fI\f(CI$t\fI\fR the initial time,
 \fI\f(CI$dt\fI\fR the timestep.
.Sp
The algorithm used is that derived by Ralston, which uses Lotkin's bound
on the derivatives, and minimises the solution error (gamma=3/4).
It is also known as the Heun method, though unfortunately several other
methods are also known under this name. Two function evaluations are needed
per timestep, and the remaining error is in the 3rd and higher order terms.
.Sp
\&\fIrk2\fR returns ($t, \f(CW@y\fR) where \f(CW$t\fR and \f(CW@y\fR are now the new values
at the completion of the timestep,
or it returns ($t, \f(CW%y\fR) if called with the data in a hashref.
.ie n .IP "\fIrk4\fR( \e@y, \e&dydt, $t, $dt )" 3
.el .IP "\fIrk4\fR( \e@y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR )" 3
.IX Item "rk4( @y, &dydt, $t, $dt )"
.PD 0
.ie n .IP "\fIrk4\fR( \e%y, \e&dydt, $t, $dt )" 3
.el .IP "\fIrk4\fR( \e%y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR )" 3
.IX Item "rk4( %y, &dydt, $t, $dt )"
.PD
The arguments are the same as in \fIrk2\fR.
.Sp
The algorithm used is that developed by Merson,
which performs five function evaluations per timestep.
For the same timestep, \fIrk4\fR is much more accurate than \fIrk4_classical\fR,
so the extra function evaluation is well worthwhile.
.Sp
\&\fIrk4\fR returns ($t, \f(CW@y\fR) where \f(CW$t\fR and \f(CW@y\fR are now the new values
at the completion of the timestep.
.ie n .IP "\fIrk4_auto\fR( \e@y, \e&dydt, $t, $dt, $epsilon )" 3
.el .IP "\fIrk4_auto\fR( \e@y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR, \f(CW$epsilon\fR )" 3
.IX Item "rk4_auto( @y, &dydt, $t, $dt, $epsilon )"
.PD 0
.ie n .IP "\fIrk4_auto\fR( \e@y, \e&dydt, $t, $dt, \e@errors )" 3
.el .IP "\fIrk4_auto\fR( \e@y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR, \e@errors )" 3
.IX Item "rk4_auto( @y, &dydt, $t, $dt, @errors )"
.ie n .IP "\fIrk4_auto\fR( \e%y, \e&dydt, $t, $dt, $epsilon )" 3
.el .IP "\fIrk4_auto\fR( \e%y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR, \f(CW$epsilon\fR )" 3
.IX Item "rk4_auto( %y, &dydt, $t, $dt, $epsilon )"
.ie n .IP "\fIrk4_auto\fR( \e%y, \e&dydt, $t, $dt, \e%errors )" 3
.el .IP "\fIrk4_auto\fR( \e%y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR, \e%errors )" 3
.IX Item "rk4_auto( %y, &dydt, $t, $dt, %errors )"
.PD
In the I>epsilon> form the arguments are:
 \fI\e@y\fR a reference to the array of initial values of variables or
 \fI\e%y\fR a reference to the hash of initial values of variables,
 \fI\e&dydt\fR a reference to the function calculating the derivatives,
 \fI\f(CI$t\fI\fR the initial time,
 \fI\f(CI$dt\fI\fR the initial timestep,
 \fI\f(CI$epsilon\fI\fR the errors per step will be about \f(CW$epsilon\fR*$ymax
.Sp
In the \fIerrors\fR form the last argument is:
 \fI\e@errors\fR a reference to an array of maximum permissible errors,
 or \fI\e%errors\fR a reference to a hash, accordingly.
.Sp
The first \fI\f(CI$epsilon\fI\fR calling form is useful when all the elements of
\&\fI\f(CI@y\fI\fR are in the same units and have the same typical size (e.g. y[10]
is population aged 10\-11 years, y[25] is population aged 25\-26 years).
The default value of the 4th argument is \fI\f(CI$epsilon\fI = 0.00001\fR.
.Sp
The second \fIerrors\fR form is useful otherwise
(e.g. \f(CW$y\fR[1] is gross national product, \f(CW$y\fR[2] is interest rate,
or \f(CW$y\fR{'gross national product'} and \f(CW$y\fR{'interest rate'} accordingly.
In this calling form, the permissible errors are specified in
absolute size for each variable; they won't get scaled at all.
.Sp
\&\fIrk4_auto\fR adjusts the timestep automatically to give the
required precision.  It does this by trying one full-timestep,
then two half-timesteps, and comparing the results.
(Merson's method, as used by \fIrk4\fR, was devised to be able
to give an estimate of the remaining local error; for the
record, it is \fI0.2*($ynp1[i]\-$eta4[i])\fR in each term.
\&\fIrk4_auto\fR does not exploit this feature because it only
works for linear \fIdydt\fR functions of the form \fIAy + bt\fR.)
.Sp
\&\fIrk4_auto\fR needs 14 function evaluations per double-timestep, and
it has to re-do 13 of those every time it adjusts the timestep.
.Sp
\&\fIrk4_auto\fR returns ($t, \f(CW$dt\fR, \f(CW@y\fR) where \f(CW$t\fR, \f(CW$dt\fR and \f(CW@y\fR
are now the new values at the completion of the timestep,
or ($t, \f(CW$dt\fR, \f(CW%y\fR) accordingly.
.IP "\fIrk4_auto_midpoint\fR()" 3
.IX Item "rk4_auto_midpoint()"
\&\fIrk4_auto\fR performs a double timestep within \f(CW$dt\fR, and returns
the final values; the values as they were at the midpoint do
not normally get returned.  However, if you want to draw a
nice smooth graph, or to update a nice smoothly-moving display,
those values as they were at the midpoint would be useful to you.
Therefore, \fIrk4_auto_midpoint\fR provides a way of retrieving them.
.Sp
Note that you must call \fIrk4_auto\fR first, which returns the values at
time \f(CW$t\fR+$dt, then \fIrk4_auto_midpoint\fR subsequently, which returns the
values at \f(CW$t\fR+$dt/2, in other words you get the two sets of values out
of their chronological order. Sorry about this.  For example,
.Sp
.Vb 6
\& while ($t<$tfinal) {
\&   ($t, $dt, @y) = &rk4_auto(\e@y, \e&dydt, $t, $dt, $epsilon);
\&   ($t_midpoint, @y_midpoint) = &rk4_auto_midpoint();
\&   &update_display($t_midpoint, @y_midpoint);
\&   &update_display($t, @y);
\& }
.Ve
.Sp
\&\fIrk4_auto_midpoint\fR returns ($t, \f(CW@y\fR) where \f(CW$t\fR and \f(CW@y\fR were the
values at the midpoint of the previous call to \fIrk4_auto\fR;
or ($t, \f(CW%y\fR) accordingly.
.SH "CALLER-SUPPLIED SUBROUTINES"
.IX Header "CALLER-SUPPLIED SUBROUTINES"
.ie n .IP "\fIdydt\fR( $t, @y );" 3
.el .IP "\fIdydt\fR( \f(CW$t\fR, \f(CW@y\fR );" 3
.IX Item "dydt( $t, @y );"
.PD 0
.ie n .IP "\fIdydt\fR( $t, %y );" 3
.el .IP "\fIdydt\fR( \f(CW$t\fR, \f(CW%y\fR );" 3
.IX Item "dydt( $t, %y );"
.PD
You will pass this subroutine by reference as the second argument to
\&\fIrk2\fR, \fIrk4\fR and \fIrk4_auto\fR. The name doesn't matter of course.
It must expect the following arguments:
 \fI\f(CI$t\fI\fR the time (in case the equations are time-dependent),
 \fI\f(CI@y\fI\fR the array of values of variables or
 \fI\f(CI%y\fI\fR the hash of values of variables.
.Sp
It must return an array (or hash, accordingly)
of the derivatives of the variables with respect to time.
.SH "EXPORT_OK SUBROUTINES"
.IX Header "EXPORT_OK SUBROUTINES"
The following routines are not exported by default, but are
exported under the \fI\s-1ALL\s0\fR tag, so if you need them you should:
.PP
.Vb 1
\& import Math::RungeKutta qw(:ALL);
.Ve
.ie n .IP "\fIrk4_classical\fR( \e@y, \e&dydt, $t, $dt )" 3
.el .IP "\fIrk4_classical\fR( \e@y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR )" 3
.IX Item "rk4_classical( @y, &dydt, $t, $dt )"
.PD 0
.ie n .IP "\fIrk4_classical\fR( \e%y, \e&dydt, $t, $dt )" 3
.el .IP "\fIrk4_classical\fR( \e%y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR )" 3
.IX Item "rk4_classical( %y, &dydt, $t, $dt )"
.PD
The arguments and the return values are the same as in \fIrk2\fR and \fIrk4\fR.
.Sp
The algorithm used is the classic, elegant, 4th\-order Runge-Kutta
method, using four function evaluations per timestep:
 k0 = dt * F(y(n))
 k1 = dt * F(y(n) + 0.5*k0)
 k2 = dt * F(y(n) + 0.5*k1)
 k3 = dt * F(y(n) + k2)
 y(n+1) = y(n) + (k0 + 2*k1 + 2*k2 + k3) / 6
.ie n .IP "\fIrk4_ralston\fR( \e@y, \e&dydt, $t, $dt )" 3
.el .IP "\fIrk4_ralston\fR( \e@y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR )" 3
.IX Item "rk4_ralston( @y, &dydt, $t, $dt )"
.PD 0
.ie n .IP "\fIrk4_ralston\fR( \e%y, \e&dydt, $t, $dt )" 3
.el .IP "\fIrk4_ralston\fR( \e%y, \e&dydt, \f(CW$t\fR, \f(CW$dt\fR )" 3
.IX Item "rk4_ralston( %y, &dydt, $t, $dt )"
.PD
The arguments and the return values are the same as in \fIrk2\fR and \fIrk4\fR.
.Sp
The algorithm used is that developed by Ralston, which optimises
\&\fIrk4_classical\fR to minimise the error bound on each timestep.
This module does not use it as the default 4th\-order method \fIrk4\fR,
because Merson's algorithm generates greater accuracy, which allows
the timestep to be increased, which more than compensates for
the extra function evaluation.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
There are a couple of example scripts in the \fIexamples/\fR
subdirectory of the build directory.
You can use their code to help you get your first application going.
.IP "\fIsine-cosine\fR" 3
.IX Item "sine-cosine"
This script uses \fITerm::Clui\fR (arrow keys and Return, or q to quit)
to offer a selection of algorithms, timesteps and error criteria for
the integration of a simple sine/cosine wave around one complete cycle.
This was the script used as a testbed during development.
.IP "\fIthree-body\fR" 3
.IX Item "three-body"
This script uses the vt100 or xterm 'moveto' and 'reverse'
sequences to display a little simulation of three-body gravity.
It uses \fIrk4_auto\fR because a shorter timestep is needed when
two bodies are close to each other. It also uses \fIrk4_auto_midpoint\fR
to smooth the display.  By changing the initial conditions you
can experience how sensitively the outcome depends on them.
.SH "TRAPS FOR THE UNWARY"
.IX Header "TRAPS FOR THE UNWARY"
Alas, things can go wrong in numerical integration.
.PP
One of the most fundamental is \fBinstability\fR. If you choose a timestep
\&\fI\f(CI$dt\fI\fR much larger than time-constants implied in your derivative
function \fI&dydt\fR, then the numerical solution will oscillate wildy,
and bear no relation to the real behaviour of the equations.
If this happens, choose a shorter \fI\f(CI$dt\fI\fR.
.PP
Some of the most difficult problems involve so-called \fBstiff\fR
derivative functions. These arise when \fI&dydt\fR introduces a wide
range of time-constants, from very short to long. In order to avoid
instability, you will have to set \fI\f(CI$dt\fI\fR to correspond to the shortest
time-constant; but this makes it impossibly slow to follow the
evolution of the system over longer times.  You should try to separate
out the long-term part of the problem, by expressing the short-term
process as the finding of some equilibrium, and then assume that that
equilibrium is present and solve the long-term problem on its own.
.PP
Similarly, numerical integration doesn't enjoy problems where
time-constants change suddenly, such as balls bouncing off hard
surfaces, etc. You can often tackle these by intervening directly
in the \fI\f(CI@y\fI\fR array between each timestep. For example, if \fI\f(CI$y\fI[17]\fR
is the height of the ball above the floor, and \fI\f(CI$y\fI[20]\fR is the
vertical component of the velocity, do something like
.PP
.Vb 1
\& if ($y[17]<0.0) { $y[17]*=\-0.9; $y[20]*=\-0.9; }
.Ve
.PP
and thus, again, let the numerical integration solve just the
smooth part of the problem.
.SH "JAVASCRIPT"
.IX Header "JAVASCRIPT"
In the \f(CW\*(C`js/\*(C'\fR subdirectory of the install directory there is \fIRungeKutta.js\fR,
which is an exact translation of this Perl code into JavaScript.
The function names and arguments are unchanged.
Brief Synopsis:
.PP
.Vb 6
\& <SCRIPT type="text/javascript" src="RungeKutta.js"> </SCRIPT>
\& <SCRIPT type="text/javascript">
\& var dydt = function (t, y) {  // the derivative function
\&    var dydt_array = new Array(y.length); ... ; return dydt_array;
\& }
\& var y = new Array();
\&
\& // For automatic timestep adjustment ...
\& y = initial_y(); var t=0; var dt=0.4;  // the initial conditions
\& // Arrays of return vaules:
\& var tmp_end = new Array(3);  var tmp_mid = new Array(2);
\& while (t < tfinal) {
\&    tmp_end = rk4_auto(y, dydt, t, dt, 0.00001);
\&    tmp_mid = rk4_auto_midpoint();
\&    t=tmp_mid[0]; y=tmp_mid[1];
\&    display(t, y);   // e.g. could use wz_jsgraphics.js or SVG
\&    t=tmp_end[0]; dt=tmp_end[1]; y=tmp_end[2];
\&    display(t, y);
\& }
\&
\& // Or, for fixed timesteps ...
\& y = post_ww2_y(); var t=1945; var dt=1;  // start in 1945
\& var tmp = new Array(2);  // Array of return values
\& while (t <= 2100) {
\&    tmp = rk4(y, dydt, t, dt);  // Merson\*(Aqs 4th\-order method
\&    t=tmp[0]; y=tmp[1];
\&    display(t, y);
\& }
\& </SCRIPT>
.Ve
.PP
\&\fIRungeKutta.js\fR uses several global variables
which all begin with the letters \f(CW\*(C`_rk_\*(C'\fR so you should
avoid introducing variables beginning with these characters.
.SH "LUA"
.IX Header "LUA"
In the \f(CW\*(C`lua/\*(C'\fR subdirectory of the install directory there is
\&\fIRungeKutta.lua\fR, which is an exact translation of this Perl code into Lua.
The function names and arguments are unchanged.
Brief Synopsis:
.PP
.Vb 11
\& local RK = require \*(AqRungeKutta\*(Aq
\& function dydt(t, y) \-\- the derivative function
\&   \-\- y is the table of the values, dydt the table of the derivatives
\&   local dydt = {}; ... ; return dydt
\& end
\& y = initial_y(); t=0; dt=0.4;  \-\- the initial conditions
\& \-\- For automatic timestep adjustment ...
\& while t < tfinal do
\&    t, dt, y = RK.rk4_auto(y, dydt, t, dt, 0.00001)
\&    display(t, y)
\& end
\&
\& \-\- Or, for fixed timesteps ...
\& while t < tfinal do
\&   t, y = RK.rk4(y, dydt, t, dt)  \-\- Merson\*(Aqs 4th\-order method
\&   display(t, y)
\& end
\& \-\- alternatively, though not so accurate ...
\& t, y = RK.rk2(y, dydt, t, dt)   \-\- Heun\*(Aqs 2nd\-order method
\&
\& \-\- or, also available ...
\& t, y = RK.rk4_classical(y, dydt, t, dt) \-\- Runge\-Kutta 4th\-order
\& t, y = RK.rk4_ralston(y, dydt, t, dt)   \-\- Ralston\*(Aqs 4th\-order
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter J Billam, http://www.pjb.com.au/comp/contact.html
.SH "REFERENCES"
.IX Header "REFERENCES"
\&\fIOn the Accuracy of Runge-Kutta's Method\fR,
M. Lotkin, \s-1MTAC\s0, vol 5, pp 128\-132, 1951
.PP
\&\fIAn Operational Method for the study of Integration Processes\fR,
R. H. Merson,
Proceedings of a Symposium on Data Processing,
Weapons Research Establishment, Salisbury, South Australia, 1957
.PP
\&\fINumerical Solution of Ordinary and Partial Differential Equations\fR,
L. Fox, Pergamon, 1962
.PP
\&\fIA First Course in Numerical Analysis\fR, A. Ralston, McGraw-Hill, 1965
.PP
\&\fINumerical Initial Value Problems in Ordinary Differential Equations\fR,
C. William Gear, Prentice-Hall, 1971
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See also the scripts examples/sine\-cosine and examples/three\-body,
http://www.pjb.com.au/,
http://www.pjb.com.au/comp/,
Math::WalshTransform,
Math::Evol,
Term::Clui,
Crypt::Tea_JS,
http://www.xmds.org/
