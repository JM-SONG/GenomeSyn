<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#PROCEDURAL-VS-OBJECT-ORIENTED-USAGE">PROCEDURAL VS OBJECT-ORIENTED USAGE</a></li>
      <li><a href="#USE-OF-XML">USE OF XML</a>
        <ul>
          <li><a href="#SAX">SAX</a></li>
          <li><a href="#PERL-REPRESENTATION">PERL REPRESENTATION</a></li>
          <li><a href="#PARSING">PARSING</a></li>
          <li><a href="#OBJECT-ORIENTED">OBJECT ORIENTED</a></li>
          <li><a href="#IN-A-STREAM">IN A STREAM</a></li>
        </ul>
      </li>
      <li><a href="#STRUCTURED-TAGS-TREE-DATA-STRUCTURE">STRUCTURED TAGS TREE DATA STRUCTURE</a></li>
      <li><a href="#MANIPULATION-AND-QUERYING">MANIPULATION AND QUERYING</a></li>
      <li><a href="#S-Expression-Lisp-representation">S-Expression (Lisp) representation</a>
        <ul>
          <li><a href="#TIPS-FOR-EMACS-USERS-AND-LISP-PROGRAMMERS">TIPS FOR EMACS USERS AND LISP PROGRAMMERS</a></li>
        </ul>
      </li>
      <li><a href="#INDENTED-TEXT-REPRESENTATION">INDENTED TEXT REPRESENTATION</a></li>
      <li><a href="#NESTED-ARRAY-SPECIFICATION-II">NESTED ARRAY SPECIFICATION II</a></li>
    </ul>
  </li>
  <li><a href="#NODES-AS-DATA-OBJECTS">NODES AS DATA OBJECTS</a></li>
  <li><a href="#INDEXING-STAG-TREES">INDEXING STAG TREES</a></li>
  <li><a href="#STAG-METHODS">STAG METHODS</a>
    <ul>
      <li><a href="#INITIALIZATION-METHODS">INITIALIZATION METHODS</a>
        <ul>
          <li><a href="#new">new</a></li>
          <li><a href="#stagify-nodify-">stagify (nodify)</a></li>
          <li><a href="#parse">parse</a></li>
          <li><a href="#parsestr">parsestr</a></li>
          <li><a href="#from">from</a></li>
          <li><a href="#unflatten">unflatten</a></li>
          <li><a href="#makehandler">makehandler</a></li>
          <li><a href="#getformathandler">getformathandler</a></li>
          <li><a href="#chainhandler">chainhandler</a></li>
        </ul>
      </li>
      <li><a href="#RECURSIVE-SEARCHING">RECURSIVE SEARCHING</a>
        <ul>
          <li><a href="#find-f-">find (f)</a></li>
          <li><a href="#findnode-fn-">findnode (fn)</a></li>
          <li><a href="#findval-fv-">findval (fv)</a></li>
          <li><a href="#sfindval-sfv-">sfindval (sfv)</a></li>
          <li><a href="#findvallist-fvl-">findvallist (fvl)</a></li>
        </ul>
      </li>
      <li><a href="#DATA-ACCESSOR-METHODS">DATA ACCESSOR METHODS</a>
        <ul>
          <li><a href="#get-g-">get (g)</a></li>
          <li><a href="#sget-sg-">sget (sg)</a></li>
          <li><a href="#getl-gl-getlist-">getl (gl getlist)</a></li>
          <li><a href="#getn-gn-getnode-">getn (gn getnode)</a></li>
          <li><a href="#sgetmap-sgm-">sgetmap (sgm)</a></li>
          <li><a href="#set-s-">set (s)</a></li>
          <li><a href="#unset-u-">unset (u)</a></li>
          <li><a href="#free">free</a></li>
          <li><a href="#add-a-">add (a)</a></li>
          <li><a href="#element-e-name-">element (e name)</a></li>
          <li><a href="#kids-k-children-">kids (k children)</a></li>
          <li><a href="#addkid-ak-addchild-">addkid (ak addchild)</a></li>
          <li><a href="#subnodes">subnodes</a></li>
          <li><a href="#ntnodes">ntnodes</a></li>
          <li><a href="#tnodes">tnodes</a></li>
        </ul>
      </li>
      <li><a href="#QUERYING-AND-ADVANCED-DATA-MANIPULATION">QUERYING AND ADVANCED DATA MANIPULATION</a>
        <ul>
          <li><a href="#ijoin-j-">ijoin (j)</a></li>
          <li><a href="#qmatch-qm-">qmatch (qm)</a></li>
          <li><a href="#tmatch-tm-">tmatch (tm)</a></li>
          <li><a href="#tmatchhash-tmh-">tmatchhash (tmh)</a></li>
          <li><a href="#tmatchnode-tmn-">tmatchnode (tmn)</a></li>
          <li><a href="#cmatch-cm-">cmatch (cm)</a></li>
          <li><a href="#where-w-">where (w)</a></li>
          <li><a href="#iterate-i-">iterate (i)</a></li>
          <li><a href="#maptree">maptree</a></li>
        </ul>
      </li>
      <li><a href="#MISCELLANEOUS-METHODS">MISCELLANEOUS METHODS</a>
        <ul>
          <li><a href="#duplicate-d-">duplicate (d)</a></li>
          <li><a href="#isanode">isanode</a></li>
          <li><a href="#hash">hash</a></li>
          <li><a href="#pairs">pairs</a></li>
          <li><a href="#write">write</a></li>
          <li><a href="#xml2">xml</a></li>
        </ul>
      </li>
      <li><a href="#XML-METHODS">XML METHODS</a>
        <ul>
          <li><a href="#xslt">xslt</a></li>
          <li><a href="#xsltstr">xsltstr</a></li>
          <li><a href="#sax">sax</a></li>
          <li><a href="#xpath-xp-tree2xpath-">xpath (xp tree2xpath)</a></li>
          <li><a href="#xpquery-xpq-xpathquery-">xpquery (xpq xpathquery)</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#STAG-SCRIPTS">STAG SCRIPTS</a></li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#WEBSITE">WEBSITE</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<pre><code><code>  Data::Stag - Structured Tags datastructures</code></code></pre>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>  <span class="comment"># PROCEDURAL USAGE</span>
  <span class="keyword">use</span> <span class="variable">Data::Stag</span> <span class="string">qw(:all)</span><span class="operator">;</span>
  <span class="variable">$doc</span> <span class="operator">=</span> <span class="variable">stag_parse</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">);</span>
  <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">stag_find</span><span class="operator">(</span><span class="variable">$doc</span><span class="operator">,</span> <span class="string">"person"</span><span class="operator">);</span>
  <span class="keyword">foreach</span> <span class="variable">$p</span> <span class="operator">(</span><span class="variable">@persons</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">printf</span> <span class="string">"%s, %s phone: %s\n"</span><span class="operator">,</span>
      <span class="variable">stag_sget</span><span class="operator">(</span><span class="variable">$p</span><span class="operator">,</span> <span class="string">"family_name"</span><span class="operator">),</span>
      <span class="variable">stag_sget</span><span class="operator">(</span><span class="variable">$p</span><span class="operator">,</span> <span class="string">"given_name"</span><span class="operator">),</span>
      <span class="variable">stag_sget</span><span class="operator">(</span><span class="variable">$p</span><span class="operator">,</span> <span class="string">"phone_no"</span><span class="operator">),</span>
    <span class="operator">;</span>
  <span class="operator">}</span> 
  
  <span class="comment"># OBJECT-ORIENTED USAGE</span>
  <span class="keyword">use</span> <span class="variable">Data::Stag</span><span class="operator">;</span>
  <span class="variable">$doc</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">);</span>
  <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">$doc</span><span class="operator">-&gt;</span><span class="variable">find</span><span class="operator">(</span><span class="string">"person"</span><span class="operator">);</span>
  <span class="keyword">foreach</span> <span class="variable">$p</span> <span class="operator">(</span><span class="variable">@person</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">printf</span> <span class="string">"%s, %s phone:%s\n"</span><span class="operator">,</span>
      <span class="variable">$p</span><span class="operator">-&gt;</span><span class="variable">sget</span><span class="operator">(</span><span class="string">"family_name"</span><span class="operator">),</span>
      <span class="variable">$p</span><span class="operator">-&gt;</span><span class="variable">sget</span><span class="operator">(</span><span class="string">"given_name"</span><span class="operator">),</span>
      <span class="variable">$p</span><span class="operator">-&gt;</span><span class="variable">sget</span><span class="operator">(</span><span class="string">"phone_no"</span><span class="operator">),</span>
    <span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module is for manipulating data as hierarchical tag/value pairs (Structured TAGs or Simple Tree AGgreggates). These datastructures can be represented as nested arrays, which have the advantage of being native to perl. A simple example is shown below:</p>

<pre><code><code>  [ person=&gt; [  [ family_name =&gt; $family_name ],
                [ given_name  =&gt; $given_name  ],
                [ phone_no    =&gt; $phone_no    ] ] ],</code></code></pre>

<p><a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag.html">Data::Stag</a> uses a subset of XML for import and export. This means the module can also be used as a general XML parser/writer (with certain caveats).</p>

<p>The above set of structured tags can be represented in XML as</p>

<pre><code><code>  &lt;person&gt;
    &lt;family_name&gt;...&lt;/family_name&gt;
    &lt;given_name&gt;...&lt;/given_name&gt;
    &lt;phone_no&gt;...&lt;/phone_no&gt;
  &lt;/person&gt;</code></code></pre>

<p>This datastructure can be examined, manipulated and exported using Stag functions or methods:</p>

<pre><code><code>  <span class="variable">$document</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">);</span>
  <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">$document</span><span class="operator">-&gt;</span><span class="variable">find</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">);</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$person</span> <span class="operator">(</span><span class="variable">@person</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">'full_name'</span><span class="operator">,</span>
                 <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">sget</span><span class="operator">(</span><span class="string">'given_name'</span><span class="operator">)</span> <span class="operator">.</span> <span class="string">' '</span> <span class="operator">.</span>
                 <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">sget</span><span class="operator">(</span><span class="string">'family_name'</span><span class="operator">));</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Advanced querying is performed by passing functions, for example:</p>

<pre><code><code>  <span class="comment"># get all people in dataset with name starting 'A'</span>
  <span class="variable">@persons</span> <span class="operator">=</span> 
    <span class="variable">$document</span><span class="operator">-&gt;</span><span class="variable">where</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">,</span>
                     <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">-&gt;</span><span class="variable">sget</span><span class="operator">(</span><span class="string">'family_name'</span><span class="operator">)</span> <span class="operator">=~</span> <span class="regex">/^A/</span><span class="operator">});</span>
</code></code></pre>

<p>One of the things that marks this module out against other XML modules is this emphasis on a <b>functional</b> approach as an obect-oriented or procedural approach.</p>

<p>For full information on the stag project, see <a href="http://stag.sourceforge.net">http://stag.sourceforge.net</a></p>

<h2 id="PROCEDURAL-VS-OBJECT-ORIENTED-USAGE">PROCEDURAL VS OBJECT-ORIENTED USAGE</h2>

<p>Depending on your preference, this module can be used a set of procedural subroutine calls, or as method calls upon Data::Stag objects, or both.</p>

<p>In procedural mode, all the subroutine calls are prefixed &quot;stag_&quot; to avoid namespace clashes. The following three calls are equivalent:</p>

<pre><code><code>  <span class="variable">$person</span> <span class="operator">=</span> <span class="variable">stag_find</span><span class="operator">(</span><span class="variable">$doc</span><span class="operator">,</span> <span class="string">"person"</span><span class="operator">);</span>
  <span class="variable">$person</span> <span class="operator">=</span> <span class="variable">$doc</span><span class="operator">-&gt;</span><span class="variable">find</span><span class="operator">(</span><span class="string">"person"</span><span class="operator">);</span>
  <span class="variable">$person</span> <span class="operator">=</span> <span class="variable">$doc</span><span class="operator">-&gt;</span><span class="variable">find_person</span><span class="operator">;</span>
</code></code></pre>

<p>In object mode, you can treat any tree element as if it is an object with automatically defined methods for getting/setting the tag values.</p>

<h2 id="USE-OF-XML">USE OF XML</h2>

<p>Nested arrays can be imported and exported as XML, as well as other formats. XML can be slurped into memory all at once (using less memory than an equivalent DOM tree), or a simplified SAX style event handling model can be used. Similarly, data can be exported all at once, or as a series of events.</p>

<p>Although this module can be used as a general XML tool, it is intended primarily as a tool for manipulating hierarchical data using nested tag/value pairs.</p>

<p>This module is more suited to dealing with data-oriented documents than text-oriented documents.</p>

<p>By using a simpler subset of XML equivalent to a basic data tree structure, we can write simpler, cleaner code.</p>

<p>This module is ideally suited to element-only XML (that is, XML without attributes or mixed elements).</p>

<p>If you are using attributes or mixed elements, it is useful to know what is going on under the hood.</p>

<p>All attributes are turned into elements; they are nested inside an element with name <b>&#39;@&#39;</b>.</p>

<p>For example, the following piece of XML</p>

<pre><code><code>  &lt;foo id=&quot;x&quot;&gt;
    &lt;bar&gt;ugh&lt;/bar&gt;
  &lt;/foo&gt;</code></code></pre>

<p>Gets represented internally as</p>

<pre><code><code>  &lt;foo&gt;
    &lt;@&gt;
      &lt;id&gt;x&lt;/id&gt;
    &lt;/@&gt;
    &lt;bar&gt;ugh&lt;/bar&gt;
  &lt;/foo&gt;</code></code></pre>

<p>Of course, this is not valid XML. However, it is just an internal representation - when exporting back to XML it will look like normal XML with attributes again.</p>

<p>Mixed content cannot be represented in a simple tree format, so this is also expanded.</p>

<p>The following piece of XML</p>

<pre><code><code>  &lt;paragraph id=&quot;1&quot; color=&quot;green&quot;&gt;
    example of &lt;bold&gt;mixed&lt;/bold&gt;content
  &lt;/paragraph&gt;</code></code></pre>

<p>gets parsed as if it were actually:</p>

<pre><code><code>  &lt;paragraph&gt;
    &lt;@&gt;
      &lt;id&gt;1&lt;/id&gt;
      &lt;color&gt;green&lt;/color&gt;
    &lt;/@&gt;
    &lt;.&gt;example of&lt;/.&gt;
    &lt;bold&gt;mixed&lt;/bold&gt;
    &lt;.&gt;content&lt;/.&gt;
  &lt;/paragraph&gt;</code></code></pre>

<p>When using stag with attribute or mixed attribute xml, you can treat <b>&#39;@&#39;</b> and <b>&#39;.&#39;</b> as normal elements</p>

<h3 id="SAX">SAX</h3>

<p>This module can also be used as part of a SAX-style event generation / handling framework - see <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/BaseHandler.html">Data::Stag::BaseHandler</a></p>

<h3 id="PERL-REPRESENTATION">PERL REPRESENTATION</h3>

<p>Because nested arrays are native to perl, we can specify an XML datastructure directly in perl without going through multiple object calls.</p>

<p>For example, instead of using <a>XML::Writer</a> for the lengthy</p>

<pre><code><code>  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">startTag</span><span class="operator">(</span><span class="string">"record"</span><span class="operator">);</span>
  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">startTag</span><span class="operator">(</span><span class="string">"field1"</span><span class="operator">);</span>
  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">characters</span><span class="operator">(</span><span class="string">"foo"</span><span class="operator">);</span>
  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">endTag</span><span class="operator">(</span><span class="string">"field1"</span><span class="operator">);</span>
  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">startTag</span><span class="operator">(</span><span class="string">"field2"</span><span class="operator">);</span>
  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">characters</span><span class="operator">(</span><span class="string">"bar"</span><span class="operator">);</span>
  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">endTag</span><span class="operator">(</span><span class="string">"field2"</span><span class="operator">);</span>
  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">end</span><span class="operator">(</span><span class="string">"record"</span><span class="operator">);</span>
</code></code></pre>

<p>We can instead write</p>

<pre><code><code>  <span class="variable">$struct</span> <span class="operator">=</span> <span class="operator">[</span> <span class="string">record</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
              <span class="operator">[</span> <span class="string">field1</span> <span class="operator">=&gt;</span> <span class="string">'foo'</span><span class="operator">]</span><span class="operator">,</span>
              <span class="operator">[</span> <span class="string">field2</span> <span class="operator">=&gt;</span> <span class="string">'bar'</span><span class="operator">]]]</span><span class="operator">;</span>
</code></code></pre>

<h3 id="PARSING">PARSING</h3>

<p>The following example is for parsing out subsections of a tree and changing sub-elements</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Data::Stag</span> <span class="string">qw(:all)</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$tree</span> <span class="operator">=</span> <span class="variable">stag_parse</span><span class="operator">(</span><span class="variable">$xmlfile</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$subtree</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">stag_findnode</span><span class="operator">(</span><span class="variable">$tree</span><span class="operator">,</span> <span class="variable">$element</span><span class="operator">);</span>
  <span class="variable">stag_set</span><span class="operator">(</span><span class="variable">$element</span><span class="operator">,</span> <span class="variable">$sub_element</span><span class="operator">,</span> <span class="variable">$new_val</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="variable">stag_xml</span><span class="operator">(</span><span class="variable">$subtree</span><span class="operator">);</span>
</code></code></pre>

<h3 id="OBJECT-ORIENTED">OBJECT ORIENTED</h3>

<p>The same can be done in a more OO fashion</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Data::Stag</span> <span class="string">qw(:all)</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$tree</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="variable">$xmlfile</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$subtree</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$tree</span><span class="operator">-&gt;</span><span class="variable">findnode</span><span class="operator">(</span><span class="variable">$element</span><span class="operator">);</span>
  <span class="variable">$element</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="variable">$sub_element</span><span class="operator">,</span> <span class="variable">$new_val</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="variable">$subtree</span><span class="operator">-&gt;</span><span class="variable">xml</span><span class="operator">;</span>
</code></code></pre>

<h3 id="IN-A-STREAM">IN A STREAM</h3>

<p>Rather than parsing in a whole file into memory all at once (which may not be suitable for very large files), you can take an <b>event handling</b> approach. The easiest way to do this to register which nodes in the file you are interested in using the <b>makehandler</b> method. The parser will sweep through the file, building objects as it goes, and handing the object to a subroutine that you specify.</p>

<p>For example:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Data::Stag</span><span class="operator">;</span>
  <span class="comment"># catch the end of 'person' elements</span>
  <span class="keyword">my</span> <span class="variable">$h</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">makehandler</span><span class="operator">(</span> <span class="string">person</span><span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
                                               <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span> <span class="variable">$person</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
                                               <span class="keyword">printf</span> <span class="string">"name:%s phone:%s\n"</span><span class="operator">,</span>
                                                 <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">get_name</span><span class="operator">,</span>
                                                 <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">get_phone</span><span class="operator">;</span>
                                               <span class="keyword">return</span><span class="operator">;</span>   <span class="comment"># clear node</span>
                                                <span class="operator">});</span>
  <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="string">-handler</span><span class="operator">=&gt;</span><span class="variable">$h</span><span class="operator">,</span>
                    <span class="string">-file</span><span class="operator">=&gt;</span><span class="variable">$f</span><span class="operator">);</span>
</code></code></pre>

<p>see <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/BaseHandler.html">Data::Stag::BaseHandler</a> for writing handlers</p>

<p>See the Stag website at <a href="http://stag.sourceforge.net">http://stag.sourceforge.net</a> for more examples.</p>

<h2 id="STRUCTURED-TAGS-TREE-DATA-STRUCTURE">STRUCTURED TAGS TREE DATA STRUCTURE</h2>

<p>A tree of structured tags is represented as a recursively nested array, the elements of the array represent nodes in the tree.</p>

<p>A node is a name/data pair, that can represent tags and values. A node is represented using a reference to an array, where the first element of the array is the <b>tagname</b>, or <b>element</b>, and the second element is the <b>data</b></p>

<p>This can be visualised as a box:</p>

<pre><code><code>  +-----------+
  |Name | Data|
  +-----------+</code></code></pre>

<p>In perl, we represent this pair as a reference to an array</p>

<pre><code><code>  [ Name =&gt; $Data ]</code></code></pre>

<p>The <b>Data</b> can either be a list of child nodes (subtrees), or a data value.</p>

<p>The terminal nodes (leafs of the tree) contain data values; this is represented in perl using primitive scalars.</p>

<p>For example:</p>

<pre><code><code>  [ Name =&gt; &#39;Fred&#39; ]</code></code></pre>

<p>For non-terminal nodes, the Data is a reference to an array, where each element of the the array is a new node.</p>

<pre><code><code>  +-----------+
  |Name | Data|
  +-----------+
          |||   +-----------+
          ||+--&gt;|Name | Data|
          ||    +-----------+
          ||    
          ||    +-----------+
          |+---&gt;|Name | Data|
          |     +-----------+
          |     
          |     +-----------+
          +----&gt;|Name | Data|
                +-----------+</code></code></pre>

<p>In perl this would be:</p>

<pre><code><code>  <span class="operator">[</span> <span class="string">Name</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
              <span class="operator">[</span><span class="string">Name1</span> <span class="operator">=&gt;</span> <span class="variable">$Data1</span><span class="operator">]</span><span class="operator">,</span>
              <span class="operator">[</span><span class="string">Name2</span> <span class="operator">=&gt;</span> <span class="variable">$Data2</span><span class="operator">]</span><span class="operator">,</span>
              <span class="operator">[</span><span class="string">Name3</span> <span class="operator">=&gt;</span> <span class="variable">$Data3</span><span class="operator">]</span><span class="operator">,</span>
            <span class="operator">]</span>
  <span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>The extra level of nesting is required to be able to store any node in the tree using a single variable. This representation has lots of advantages over others, eg hashes and mixed hash/array structures.</p>

<h2 id="MANIPULATION-AND-QUERYING">MANIPULATION AND QUERYING</h2>

<p>The following example is taken from biology; we have a list of species (mouse, human, fly) and a list of genes found in that species. These are cross-referenced by an identifier called <b>tax_id</b>. We can do a relational-style inner join on this identifier, as follows -</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Data::Stag</span> <span class="string">qw(:all)</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$tree</span> <span class="operator">=</span>
  <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span>
    <span class="string">'db'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
    <span class="operator">[</span> <span class="string">'species_set'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
      <span class="operator">[</span> <span class="string">'species'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
        <span class="operator">[</span> <span class="string">'common_name'</span> <span class="operator">=&gt;</span> <span class="string">'house mouse'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'binomial'</span> <span class="operator">=&gt;</span> <span class="string">'Mus musculus'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'tax_id'</span> <span class="operator">=&gt;</span> <span class="string">'10090'</span> <span class="operator">]]]</span><span class="operator">,</span>
      <span class="operator">[</span> <span class="string">'species'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
        <span class="operator">[</span> <span class="string">'common_name'</span> <span class="operator">=&gt;</span> <span class="string">'fruit fly'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'binomial'</span> <span class="operator">=&gt;</span> <span class="string">'Drosophila melanogaster'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'tax_id'</span> <span class="operator">=&gt;</span> <span class="string">'7227'</span> <span class="operator">]]]</span><span class="operator">,</span>
      <span class="operator">[</span> <span class="string">'species'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
        <span class="operator">[</span> <span class="string">'common_name'</span> <span class="operator">=&gt;</span> <span class="string">'human'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'binomial'</span> <span class="operator">=&gt;</span> <span class="string">'Homo sapiens'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'tax_id'</span> <span class="operator">=&gt;</span> <span class="string">'9606'</span> <span class="operator">]]]]]</span><span class="operator">,</span>
    <span class="operator">[</span> <span class="string">'gene_set'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
      <span class="operator">[</span> <span class="string">'gene'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
        <span class="operator">[</span> <span class="string">'symbol'</span> <span class="operator">=&gt;</span> <span class="string">'HGNC'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'tax_id'</span> <span class="operator">=&gt;</span> <span class="string">'9606'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'phenotype'</span> <span class="operator">=&gt;</span> <span class="string">'Hemochromatosis'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'phenotype'</span> <span class="operator">=&gt;</span> <span class="string">'Porphyria variegata'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'GO_term'</span> <span class="operator">=&gt;</span> <span class="string">'iron homeostasis'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'map'</span> <span class="operator">=&gt;</span> <span class="string">'6p21.3'</span> <span class="operator">]]]</span><span class="operator">,</span>
      <span class="operator">[</span> <span class="string">'gene'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
        <span class="operator">[</span> <span class="string">'symbol'</span> <span class="operator">=&gt;</span> <span class="string">'Hfe'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'synonym'</span> <span class="operator">=&gt;</span> <span class="string">'MR2'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'tax_id'</span> <span class="operator">=&gt;</span> <span class="string">'10090'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'GO_term'</span> <span class="operator">=&gt;</span> <span class="string">'integral membrane protein'</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'map'</span> <span class="operator">=&gt;</span> <span class="string">'13 A2-A4'</span> <span class="operator">]]]]]]</span>
   <span class="operator">);</span>
  
  <span class="comment"># inner join of species and gene parts of tree,</span>
  <span class="comment"># based on 'tax_id' element</span>
  <span class="keyword">my</span> <span class="variable">$gene_set</span> <span class="operator">=</span> <span class="variable">$tree</span><span class="operator">-&gt;</span><span class="variable">find</span><span class="operator">(</span><span class="string">"gene_set"</span><span class="operator">);</span>       <span class="comment"># get &lt;gene_set&gt; element</span>
  <span class="keyword">my</span> <span class="variable">$species_set</span> <span class="operator">=</span> <span class="variable">$tree</span><span class="operator">-&gt;</span><span class="variable">find</span><span class="operator">(</span><span class="string">"species_set"</span><span class="operator">);</span> <span class="comment"># get &lt;species_set&gt; element</span>
  <span class="variable">$gene_set</span><span class="operator">-&gt;</span><span class="variable">ijoin</span><span class="operator">(</span><span class="string">"gene"</span><span class="operator">,</span> <span class="string">"tax_id"</span><span class="operator">,</span> <span class="variable">$species_set</span><span class="operator">);</span>   <span class="comment"># INNER JOIN</span>
  
  <span class="keyword">print</span> <span class="string">"Reorganised data:\n"</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="variable">$gene_set</span><span class="operator">-&gt;</span><span class="variable">xml</span><span class="operator">;</span>
  
  <span class="comment"># find all genes starting with letter 'H' in where species/common_name=human</span>
  <span class="keyword">my</span> <span class="variable">@genes</span> <span class="operator">=</span>
    <span class="variable">$gene_set</span><span class="operator">-&gt;</span><span class="variable">where</span><span class="operator">(</span><span class="string">'gene'</span><span class="operator">,</span>
                     <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$g</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
                           <span class="variable">$g</span><span class="operator">-&gt;</span><span class="variable">get_symbol</span> <span class="operator">=~</span> <span class="regex">/^H/</span> <span class="operator">&amp;&amp;</span>
                           <span class="variable">$g</span><span class="operator">-&gt;</span><span class="variable">findval</span><span class="operator">(</span><span class="string">"common_name"</span><span class="operator">)</span> <span class="keyword">eq</span> <span class="operator">(</span><span class="string">'human'</span><span class="operator">)});</span>
  
  <span class="keyword">print</span> <span class="string">"Human genes beginning 'H'\n"</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">xml</span> <span class="keyword">foreach</span> <span class="variable">@genes</span><span class="operator">;</span>
</code></code></pre>

<h2 id="S-Expression-Lisp-representation">S-Expression (Lisp) representation</h2>

<p>The data represented using this module can be represented as Lisp-style S-Expressions.</p>

<p>See <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/SxprParser.html">Data::Stag::SxprParser</a> and <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/SxprWriter.html">Data::Stag::SxprWriter</a></p>

<p>If we execute this code on the XML from the example above</p>

<pre><code><code>  <span class="variable">$stag</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="variable">$xmlfile</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">sxpr</span><span class="operator">;</span>
</code></code></pre>

<p>The following S-Expression will be printed:</p>

<pre><code><code>  &#39;(db
    (species_set
      (species
        (common_name &quot;house mouse&quot;)
        (binomial &quot;Mus musculus&quot;)
        (tax_id &quot;10090&quot;))
      (species
        (common_name &quot;fruit fly&quot;)
        (binomial &quot;Drosophila melanogaster&quot;)
        (tax_id &quot;7227&quot;))
      (species
        (common_name &quot;human&quot;)
        (binomial &quot;Homo sapiens&quot;)
        (tax_id &quot;9606&quot;)))
    (gene_set
      (gene
        (symbol &quot;HGNC&quot;)
        (tax_id &quot;9606&quot;)
        (phenotype &quot;Hemochromatosis&quot;)
        (phenotype &quot;Porphyria variegata&quot;)
        (GO_term &quot;iron homeostasis&quot;)
        (map
          (cytological
            (chromosome &quot;6&quot;)
            (band &quot;p21.3&quot;))))
      (gene
        (symbol &quot;Hfe&quot;)
        (synonym &quot;MR2&quot;)
        (tax_id &quot;10090&quot;)
        (GO_term &quot;integral membrane protein&quot;)))
    (similarity_set
      (pair
        (symbol &quot;HGNC&quot;)
        (symbol &quot;Hfe&quot;))
      (pair
        (symbol &quot;WNT3A&quot;)
        (symbol &quot;Wnt3a&quot;))))</code></code></pre>

<h3 id="TIPS-FOR-EMACS-USERS-AND-LISP-PROGRAMMERS">TIPS FOR EMACS USERS AND LISP PROGRAMMERS</h3>

<p>If you use emacs, you can save this as a file with the &quot;.el&quot; suffix and get syntax highlighting for editing this file. Quotes around the terminal node data items are optional.</p>

<p>If you know emacs lisp or any other lisp, this also turns out to be a very nice language for manipulating these datastructures. Try copying and pasting the above s-expression to the emacs scratch buffer and playing with it in lisp.</p>

<h2 id="INDENTED-TEXT-REPRESENTATION">INDENTED TEXT REPRESENTATION</h2>

<p>Data::Stag has its own text format for writing data trees. Again, this is only possible because we are working with a subset of XML (no attributes, no mixed elements). The data structure above can be written as follows -</p>

<pre><code><code>  db:
    species_set:
      species:
        common_name: house mouse
        binomial: Mus musculus
        tax_id: 10090
      species:
        common_name: fruit fly
        binomial: Drosophila melanogaster
        tax_id: 7227
      species:
        common_name: human
        binomial: Homo sapiens
        tax_id: 9606
    gene_set:
      gene:
        symbol: HGNC
        tax_id: 9606
        phenotype: Hemochromatosis
        phenotype: Porphyria variegata
        GO_term: iron homeostasis
        map: 6p21.3
      gene:
        symbol: Hfe
        synonym: MR2
        tax_id: 10090
        GO_term: integral membrane protein
        map: 13 A2-A4
    similarity_set:
      pair:
        symbol: HGNC
        symbol: Hfe
      pair:
        symbol: WNT3A
        symbol: Wnt3a</code></code></pre>

<p>See <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/ITextParser.html">Data::Stag::ITextParser</a> and <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/ITextWriter.html">Data::Stag::ITextWriter</a></p>

<h2 id="NESTED-ARRAY-SPECIFICATION-II">NESTED ARRAY SPECIFICATION II</h2>

<p>To avoid excessive square bracket usage, you can specify a structure like this:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Data::Stag</span> <span class="string">qw(:all)</span><span class="operator">;</span>
  
  <span class="variable">*N</span> <span class="operator">=</span> <span class="operator">\&amp;</span><span class="variable">stag_new</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$tree</span> <span class="operator">=</span>
    <span class="variable">N</span><span class="operator">(</span><span class="string">top</span><span class="operator">=&gt;</span><span class="operator">[</span>
            <span class="variable">N</span><span class="operator">(</span><span class="string">'personset'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                            <span class="variable">N</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">=&gt;</span><span class="string">'davey'</span><span class="operator">),</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'address'</span><span class="operator">=&gt;</span><span class="string">'here'</span><span class="operator">),</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'description'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                                           <span class="variable">N</span><span class="operator">(</span><span class="string">'hair'</span><span class="operator">=&gt;</span><span class="string">'green'</span><span class="operator">),</span>
                                                           <span class="variable">N</span><span class="operator">(</span><span class="string">'eyes'</span><span class="operator">=&gt;</span><span class="string">'two'</span><span class="operator">),</span>
                                                           <span class="variable">N</span><span class="operator">(</span><span class="string">'teeth'</span><span class="operator">=&gt;</span><span class="number">5</span><span class="operator">),</span>
                                                          <span class="operator">]</span>
                                          <span class="operator">),</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'pets'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                                    <span class="variable">N</span><span class="operator">(</span><span class="string">'petname'</span><span class="operator">=&gt;</span><span class="string">'igor'</span><span class="operator">),</span>
                                                    <span class="variable">N</span><span class="operator">(</span><span class="string">'petname'</span><span class="operator">=&gt;</span><span class="string">'ginger'</span><span class="operator">),</span>
                                                   <span class="operator">]</span>
                                          <span class="operator">),</span>
                                                                          
                                        <span class="operator">]</span><span class="operator">,</span>
                             <span class="operator">),</span>
                            <span class="variable">N</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">=&gt;</span><span class="string">'shuggy'</span><span class="operator">),</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'address'</span><span class="operator">=&gt;</span><span class="string">'there'</span><span class="operator">),</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'description'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                                           <span class="variable">N</span><span class="operator">(</span><span class="string">'hair'</span><span class="operator">=&gt;</span><span class="string">'red'</span><span class="operator">),</span>
                                                           <span class="variable">N</span><span class="operator">(</span><span class="string">'eyes'</span><span class="operator">=&gt;</span><span class="string">'three'</span><span class="operator">),</span>
                                                           <span class="variable">N</span><span class="operator">(</span><span class="string">'teeth'</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">),</span>
                                                          <span class="operator">]</span>
                                          <span class="operator">),</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'pets'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                                    <span class="variable">N</span><span class="operator">(</span><span class="string">'petname'</span><span class="operator">=&gt;</span><span class="string">'thud'</span><span class="operator">),</span>
                                                    <span class="variable">N</span><span class="operator">(</span><span class="string">'petname'</span><span class="operator">=&gt;</span><span class="string">'spud'</span><span class="operator">),</span>
                                                   <span class="operator">]</span>
                                          <span class="operator">),</span>
                                        <span class="operator">]</span>
                             <span class="operator">),</span>
                           <span class="operator">]</span>
             <span class="operator">),</span>
            <span class="variable">N</span><span class="operator">(</span><span class="string">'animalset'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                            <span class="variable">N</span><span class="operator">(</span><span class="string">'animal'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">=&gt;</span><span class="string">'igor'</span><span class="operator">),</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'class'</span><span class="operator">=&gt;</span><span class="string">'rat'</span><span class="operator">),</span>
                                         <span class="variable">N</span><span class="operator">(</span><span class="string">'description'</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                                           <span class="variable">N</span><span class="operator">(</span><span class="string">'fur'</span><span class="operator">=&gt;</span><span class="string">'white'</span><span class="operator">),</span>
                                                           <span class="variable">N</span><span class="operator">(</span><span class="string">'eyes'</span><span class="operator">=&gt;</span><span class="string">'red'</span><span class="operator">),</span>
                                                           <span class="variable">N</span><span class="operator">(</span><span class="string">'teeth'</span><span class="operator">=&gt;</span><span class="number">50</span><span class="operator">),</span>
                                                          <span class="operator">]</span><span class="operator">,</span>
                                          <span class="operator">),</span>
                                        <span class="operator">]</span><span class="operator">,</span>
                             <span class="operator">),</span>
                           <span class="operator">]</span>
             <span class="operator">),</span>
  
           <span class="operator">]</span>
     <span class="operator">);</span>
  
  <span class="comment"># find all people</span>
  <span class="keyword">my</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">stag_find</span><span class="operator">(</span><span class="variable">$tree</span><span class="operator">,</span> <span class="string">'person'</span><span class="operator">);</span>
  
  <span class="comment"># write xml for all red haired people</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$p</span> <span class="operator">(</span><span class="variable">@persons</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="variable">stag_xml</span><span class="operator">(</span><span class="variable">$p</span><span class="operator">)</span>
      <span class="keyword">if</span> <span class="variable">stag_tmatch</span><span class="operator">(</span><span class="variable">$p</span><span class="operator">,</span> <span class="string">"hair"</span><span class="operator">,</span> <span class="string">"red"</span><span class="operator">);</span>
  <span class="operator">}</span> <span class="operator">;</span>
  
  <span class="comment"># find all people that have name == shuggy</span>
  <span class="keyword">my</span> <span class="variable">@p</span> <span class="operator">=</span>
    <span class="variable">stag_qmatch</span><span class="operator">(</span><span class="variable">$tree</span><span class="operator">,</span> 
                <span class="string">"person"</span><span class="operator">,</span>
                <span class="string">"name"</span><span class="operator">,</span>
                <span class="string">"shuggy"</span><span class="operator">);</span>
</code></code></pre>

<h1 id="NODES-AS-DATA-OBJECTS">NODES AS DATA OBJECTS</h1>

<p>As well as the methods listed below, a node can be treated as if it is a data object of a class determined by the element.</p>

<p>For example, the following are equivalent.</p>

<pre><code><code>  <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">get_name</span><span class="operator">;</span>
  <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">);</span>
  
  <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">set_name</span><span class="operator">(</span><span class="string">'fred'</span><span class="operator">);</span>
  <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">,</span> <span class="string">'fred'</span><span class="operator">);</span>
</code></code></pre>

<p>This is really just syntactic sugar. The autoloaded methods are not checked against any schema, although this may be added in future.</p>

<h1 id="INDEXING-STAG-TREES">INDEXING STAG TREES</h1>

<p>A stag tree can be indexed as a hash for direct retrieval; see <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/HashDB.html">Data::Stag::HashDB</a></p>

<p>This index can be made persistent as a DB file; see <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/StagDB.html">Data::Stag::StagDB</a></p>

<p>If you wish to use Stag in conjunction with a relational database, you should install <a>DBIx::DBStag</a></p>

<h1 id="STAG-METHODS">STAG METHODS</h1>

<p>All method calls are also available as procedural subroutine calls; unless otherwise noted, the subroutine call is the same as the method call, but with the string <b>stag_</b> prefixed to the method name. The first argument should be a Data::Stag datastructure.</p>

<p>To import all subroutines into the current namespace, use this idiom:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Data::Stag</span> <span class="string">qw(:all)</span><span class="operator">;</span>
  <span class="variable">$doc</span> <span class="operator">=</span> <span class="variable">stag_parse</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">);</span>
  <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">stag_find</span><span class="operator">(</span><span class="variable">$doc</span><span class="operator">,</span> <span class="string">'person'</span><span class="operator">);</span>
</code></code></pre>

<p>If you wish to use this module procedurally, and you are too lazy to prefix all calls with <b>stag_</b>, use this idiom:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Data::Stag</span> <span class="string">qw(:lazy)</span><span class="operator">;</span>
  <span class="variable">$doc</span> <span class="operator">=</span> <span class="variable">parse</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">);</span>
  <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">find</span><span class="operator">(</span><span class="variable">$doc</span><span class="operator">,</span> <span class="string">'person'</span><span class="operator">);</span>
</code></code></pre>

<p>But beware of clashes!</p>

<p>Most method calls also have a handy short mnemonic. Use of these is optional. Software engineering types prefer longer names, in the belief that this leads to clearer code. Hacker types prefer shorter names, as this requires less keystrokes, and leads to a more compact representation of the code. It is expected that if you do use this module, then its usage will be fairly ubiquitous within your code, and the mnemonics will become familiar, much like the qw and s/ operators in perl. As always with perl, the decision is yours.</p>

<p>Some methods take a single parameter or list of parameters; some have large lists of parameters that can be passed in any order. If the documentation states:</p>

<pre><code><code>  Args: [x str], [y int], [z ANY]</code></code></pre>

<p>Then the method can be called like this:</p>

<pre><code><code>  <span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">foo</span><span class="operator">(</span><span class="string">"this is x"</span><span class="operator">,</span> <span class="number">55</span><span class="operator">,</span> <span class="variable">$ref</span><span class="operator">);</span>
</code></code></pre>

<p>or like this:</p>

<pre><code><code>  <span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">foo</span><span class="operator">(</span><span class="string">-z</span><span class="operator">=&gt;</span><span class="variable">$ref</span><span class="operator">,</span> <span class="string">-x</span><span class="operator">=&gt;</span><span class="string">"this is x"</span><span class="operator">,</span> <span class="string">-y</span><span class="operator">=&gt;</span><span class="number">55</span><span class="operator">);</span>
</code></code></pre>

<h2 id="INITIALIZATION-METHODS">INITIALIZATION METHODS</h2>

<h3 id="new">new</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">new</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">data</span> <span class="variable">STAG</span><span class="operator">-</span><span class="variable">DATA</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">Data::Stag</span> <span class="variable">node</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">stag_new</span><span class="operator">();</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">person</span> <span class="operator">=&gt;</span> <span class="operator">[[</span><span class="string">name</span><span class="operator">=&gt;</span><span class="variable">$n</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="string">phone</span><span class="operator">=&gt;</span><span class="variable">$p</span><span class="operator">]]</span><span class="operator">);</span>
</code></code></pre>

<p>creates a new instance of a Data::Stag node</p>

<h3 id="stagify-nodify-">stagify (nodify)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">stagify</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">nodify</span>
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">data</span> <span class="variable">ARRAY</span><span class="operator">-</span><span class="variable">REF</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">Data::Stag</span> <span class="variable">node</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">stag_stagify</span><span class="operator">(</span><span class="operator">[</span><span class="string">person</span> <span class="operator">=&gt;</span> <span class="operator">[[</span><span class="string">name</span><span class="operator">=&gt;</span><span class="variable">$n</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="string">phone</span><span class="operator">=&gt;</span><span class="variable">$p</span><span class="operator">]]]</span><span class="operator">);</span>
</code></code></pre>

<p>turns a perl array reference into a Data::Stag node.</p>

<p>similar to <b>new</b></p>

<h3 id="parse">parse</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">parse</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="operator">[</span><span class="variable">file</span> <span class="variable">str</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="keyword">format</span> <span class="variable">str</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="variable">handler</span> <span class="variable">obj</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="variable">fh</span> <span class="variable">FileHandle</span><span class="operator">]</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">Data::Stag</span> <span class="variable">node</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">stag_parse</span><span class="operator">(</span><span class="variable">$fn</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">stag_parse</span><span class="operator">(</span><span class="string">-fh</span><span class="operator">=&gt;</span><span class="variable">$fh</span><span class="operator">,</span> <span class="string">-handler</span><span class="operator">=&gt;</span><span class="variable">$h</span><span class="operator">,</span> <span class="string">-errhandler</span><span class="operator">=&gt;</span><span class="variable">$eh</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="string">-file</span><span class="operator">=&gt;</span><span class="variable">$fn</span><span class="operator">,</span> <span class="string">-handler</span><span class="operator">=&gt;</span><span class="variable">$myhandler</span><span class="operator">);</span>
</code></code></pre>

<p>slurps a file or string into a Data::Stag node structure. Will guess the format (xml, sxpr, itext, indent) from the suffix if it is not given.</p>

<p>The format can also be the name of a parsing module, or an actual parser object;</p>

<p>The handler is any object that can take nested Stag events (start_event, end_event, evbody) which are generated from the parse. If the handler is omitted, all events will be cached and the resulting tree will be returned.</p>

<p>See <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/BaseHandler.html">Data::Stag::BaseHandler</a> for writing your own handlers</p>

<p>See <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/BaseGenerator.html">Data::Stag::BaseGenerator</a> for details on parser classes, and error handling</p>

<h3 id="parsestr">parsestr</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">parsestr</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="operator">[</span><span class="variable">str</span> <span class="variable">str</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="keyword">format</span> <span class="variable">str</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="variable">handler</span> <span class="variable">obj</span><span class="operator">]</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">Data::Stag</span> <span class="variable">node</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">stag_parsestr</span><span class="operator">(</span><span class="string">'(a (b (c "1")))'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parsestr</span><span class="operator">(</span><span class="string">-str</span><span class="operator">=&gt;</span><span class="variable">$str</span><span class="operator">,</span> <span class="string">-handler</span><span class="operator">=&gt;</span><span class="variable">$myhandler</span><span class="operator">);</span>
</code></code></pre>

<p>Similar to parse(), except the first argument is a string</p>

<h3 id="from">from</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">from</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="keyword">format</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">source</span> <span class="variable">str</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">Data::Stag</span> <span class="variable">node</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">stag_from</span><span class="operator">(</span><span class="string">'xml'</span><span class="operator">,</span> <span class="variable">$fn</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">stag_from</span><span class="operator">(</span><span class="string">'xmlstr'</span><span class="operator">,</span> <span class="string">q[&lt;top&gt;&lt;x&gt;1&lt;/x&gt;&lt;/top&gt;]</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">from</span><span class="operator">(</span><span class="variable">$parser</span><span class="operator">,</span> <span class="variable">$fn</span><span class="operator">);</span>
</code></code></pre>

<p>Similar to <b>parse</b></p>

<p>slurps a file or string into a Data::Stag node structure.</p>

<p>The format can also be the name of a parsing module, or an actual parser object</p>

<h3 id="unflatten">unflatten</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">unflatten</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">data</span> <span class="variable">array</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">Data::Stag</span> <span class="variable">node</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">stag_unflatten</span><span class="operator">(</span><span class="string">person</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="string">name</span><span class="operator">=&gt;</span><span class="variable">$n</span><span class="operator">,</span> <span class="string">phone</span><span class="operator">=&gt;</span><span class="variable">$p</span><span class="operator">,</span> <span class="string">address</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="string">street</span><span class="operator">=&gt;</span><span class="variable">$s</span><span class="operator">,</span> <span class="string">city</span><span class="operator">=&gt;</span><span class="variable">$c</span><span class="operator">]]</span><span class="operator">);</span>
</code></code></pre>

<p>Creates a node structure from a semi-flattened representation, in which children of a node are represented as a flat list of data rather than a list of array references.</p>

<p>This means a structure can be specified as:</p>

<pre><code><code>  person=&gt;[name=&gt;$n,
           phone=&gt;$p, 
           address=&gt;[street=&gt;$s, 
                     city=&gt;$c]]</code></code></pre>

<p>Instead of:</p>

<pre><code><code>  [person=&gt;[ [name=&gt;$n],
             [phone=&gt;$p], 
             [address=&gt;[ [street=&gt;$s], 
                         [city=&gt;$c] ] ]
           ]
  ]</code></code></pre>

<p>The former gets converted into the latter for the internal representation</p>

<h3 id="makehandler">makehandler</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">makehandler</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">hash</span> <span class="variable">of</span> <span class="variable">CODEREFs</span> <span class="variable">keyed</span> <span class="variable">by</span> <span class="variable">element</span> <span class="variable">name</span>
              <span class="variable">OR</span> <span class="variable">a</span> <span class="variable">string</span> <span class="variable">containing</span> <span class="variable">the</span> <span class="variable">name</span> <span class="variable">of</span> <span class="variable">a</span> <span class="variable">module</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">L</span><span class="operator">&lt;</span><span class="variable">Data::Stag::BaseHandler</span><span class="operator">&gt;</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$h</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">makehandler</span><span class="operator">(</span><span class="variable">%subs</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$h</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">makehandler</span><span class="operator">(</span><span class="string">"My::FooHandler"</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$h</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">makehandler</span><span class="operator">(</span><span class="string">'xml'</span><span class="operator">);</span>
</code></code></pre>

<p>This creates a Stag event handler. The argument is a hash of subroutines keyed by element/node name. After each node is fired by the parser/generator, the subroutine is called, passing the handler object and the stag node as arguments. whatever the subroutine returns is placed back into the tree</p>

<p>For example, for a a parser/generator that fires events with the following tree form</p>

<pre><code><code>  &lt;person&gt;
    &lt;name&gt;foo&lt;/name&gt;
    ...
  &lt;/person&gt;</code></code></pre>

<p>we can create a handler that writes person/name like this:</p>

<pre><code><code>  <span class="variable">$h</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">makehandler</span><span class="operator">(</span>
                               <span class="string">person</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span><span class="variable">$stag</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
                                               <span class="keyword">print</span> <span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">;</span>
                                               <span class="keyword">return</span> <span class="variable">$stag</span><span class="operator">;</span> <span class="comment"># dont change tree</span>
                                             <span class="operator">});</span>
  <span class="variable">$stag</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="string">-str</span><span class="operator">=&gt;</span><span class="string">"(...)"</span><span class="operator">,</span> <span class="string">-handler</span><span class="operator">=&gt;</span><span class="variable">$h</span><span class="operator">)</span>
</code></code></pre>

<p>See <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/BaseHandler.html">Data::Stag::BaseHandler</a> for details on handlers</p>

<h3 id="getformathandler">getformathandler</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">getformathandler</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="keyword">format</span> <span class="variable">str</span> <span class="variable">OR</span> <span class="variable">L</span><span class="operator">&lt;</span><span class="variable">Data::Stag::BaseHandler</span><span class="operator">&gt;</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">L</span><span class="operator">&lt;</span><span class="variable">Data::Stag::BaseHandler</span><span class="operator">&gt;</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$h</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">getformathandler</span><span class="operator">(</span><span class="string">'xml'</span><span class="operator">);</span>
              <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">file</span><span class="operator">(</span><span class="string">"my.xml"</span><span class="operator">);</span>
              <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="string">-fn</span><span class="operator">=&gt;</span><span class="variable">$fn</span><span class="operator">,</span> <span class="string">-handler</span><span class="operator">=&gt;</span><span class="variable">$h</span><span class="operator">);</span>
</code></code></pre>

<p>Creates a Stag event handler - this handler can be passed to an event generator / parser. Built in handlers include:</p>

<dl>

<dt id="xml">xml</dt>
<dd>

<p>Generates xml tags from events</p>

</dd>
<dt id="sxpr">sxpr</dt>
<dd>

<p>Generates S-Expressions from events</p>

</dd>
<dt id="itext">itext</dt>
<dd>

<p>Generates itext format from events</p>

</dd>
<dt id="indent">indent</dt>
<dd>

<p>Generates indent format from events</p>

</dd>
</dl>

<p>All the above are kinds of <a href="../../../../.cpan/build/Data-Stag-0.11-NlX_Og/blib/lib/Data/Stag/Writer.html">Data::Stag::Writer</a></p>

<h3 id="chainhandler">chainhandler</h3>

<pre><code><code>       Title: chainhandler

        Args: blocked events - str or str[]
              initial handler - handler object
              final handler - handler object
     Returns: 
     Example: $h = Data::Stag-&gt;chainhandler(&#39;foo&#39;, $processor, &#39;xml&#39;)</code></code></pre>

<p>chains handlers together - for example, you may want to make transforms on an event stream, and then pass the event stream to another handler - for example, and xml handler</p>

<pre><code><code>  <span class="variable">$processor</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">makehandler</span><span class="operator">(</span>
                                       <span class="string">a</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span><span class="variable">$stag</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
                                                  <span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">set_foo</span><span class="operator">(</span><span class="string">"bar"</span><span class="operator">);</span>
                                                  <span class="keyword">return</span> <span class="variable">$stag</span>
                                                <span class="operator">},</span>
                                       <span class="string">b</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span><span class="variable">$stag</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
                                                  <span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">set_blah</span><span class="operator">(</span><span class="string">"eek"</span><span class="operator">);</span>
                                                  <span class="keyword">return</span> <span class="variable">$stag</span>
                                                <span class="operator">},</span>
                                       <span class="operator">);</span>
  <span class="variable">$chainh</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">chainhandler</span><span class="operator">(</span><span class="operator">[</span><span class="string">'a'</span><span class="operator">,</span> <span class="string">'b'</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">$processor</span><span class="operator">,</span> <span class="string">'xml'</span><span class="operator">);</span>
  <span class="variable">$stag</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">parse</span><span class="operator">(</span><span class="string">-str</span><span class="operator">=&gt;</span><span class="string">"(...)"</span><span class="operator">,</span> <span class="string">-handler</span><span class="operator">=&gt;</span><span class="variable">$chainh</span><span class="operator">)</span>
</code></code></pre>

<p>If the inner handler has a method CONSUMES(), this method will determine the blocked events if none are specified.</p>

<p>see also the script <b>stag-handle.pl</b></p>

<h2 id="RECURSIVE-SEARCHING">RECURSIVE SEARCHING</h2>

<h3 id="find-f-">find (f)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">find</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">f</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">node</span><span class="operator">[]</span> <span class="keyword">or</span> <span class="variable">ANY</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">stag_find</span><span class="operator">(</span><span class="variable">$struct</span><span class="operator">,</span> <span class="string">'person'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">$struct</span><span class="operator">-&gt;</span><span class="variable">find</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">);</span>
</code></code></pre>

<p>recursively searches tree for all elements of the given type, and returns all nodes or data elements found.</p>

<p>if the element found is a non-terminal node, will return the node if the element found is a terminal (leaf) node, will return the data value</p>

<p>the element argument can be a path</p>

<pre><code><code>  <span class="variable">@names</span> <span class="operator">=</span> <span class="variable">$struct</span><span class="operator">-&gt;</span><span class="variable">find</span><span class="operator">(</span><span class="string">'department/person/name'</span><span class="operator">);</span>
</code></code></pre>

<p>will find name in the nested structure below:</p>

<pre><code><code>  (department
   (person
    (name &quot;foo&quot;)))</code></code></pre>

<h3 id="findnode-fn-">findnode (fn)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">findnode</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">fn</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">node</span><span class="operator">[]</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">stag_findnode</span><span class="operator">(</span><span class="variable">$struct</span><span class="operator">,</span> <span class="string">'person'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">$struct</span><span class="operator">-&gt;</span><span class="variable">findnode</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">);</span>
</code></code></pre>

<p>recursively searches tree for all elements of the given type, and returns all nodes found.</p>

<p>paths can also be used (see <b>find</b>)</p>

<h3 id="findval-fv-">findval (fv)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">findval</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">fv</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">ANY</span><span class="operator">[]</span> <span class="keyword">or</span> <span class="variable">ANY</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@names</span> <span class="operator">=</span> <span class="variable">stag_findval</span><span class="operator">(</span><span class="variable">$struct</span><span class="operator">,</span> <span class="string">'name'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@names</span> <span class="operator">=</span> <span class="variable">$struct</span><span class="operator">-&gt;</span><span class="variable">findval</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$firstname</span> <span class="operator">=</span> <span class="variable">$struct</span><span class="operator">-&gt;</span><span class="variable">findval</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">);</span>
</code></code></pre>

<p>recursively searches tree for all elements of the given type, and returns all data values found. the data values could be primitive scalars or nodes.</p>

<p>paths can also be used (see <b>find</b>)</p>

<h3 id="sfindval-sfv-">sfindval (sfv)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">sfindval</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">sfv</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">ANY</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="variable">stag_sfindval</span><span class="operator">(</span><span class="variable">$struct</span><span class="operator">,</span> <span class="string">'name'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="variable">$struct</span><span class="operator">-&gt;</span><span class="variable">sfindval</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">);</span>
</code></code></pre>

<p>as findval, but returns the first value found</p>

<p>paths can also be used (see <b>find</b>)</p>

<h3 id="findvallist-fvl-">findvallist (fvl)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">findvallist</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">fvl</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span><span class="operator">[]</span>
            <span class="variable">Returns</span><span class="operator">:</span> <span class="variable">ANY</span><span class="operator">[]</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="operator">(</span><span class="variable">$name</span><span class="operator">,</span> <span class="variable">$phone</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">stag_findvallist</span><span class="operator">(</span><span class="variable">$personstruct</span><span class="operator">,</span> <span class="string">'name'</span><span class="operator">,</span> <span class="string">'phone'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="operator">(</span><span class="variable">$name</span><span class="operator">,</span> <span class="variable">$phone</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$personstruct</span><span class="operator">-&gt;</span><span class="variable">findvallist</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">,</span> <span class="string">'phone'</span><span class="operator">);</span>
</code></code></pre>

<p>recursively searches tree for all elements in the list</p>

<p>DEPRECATED</p>

<h2 id="DATA-ACCESSOR-METHODS">DATA ACCESSOR METHODS</h2>

<p>these allow getting and setting of elements directly underneath the current one</p>

<h3 id="get-g-">get (g)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">get</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">g</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">node</span><span class="operator">[]</span> <span class="keyword">or</span> <span class="variable">ANY</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@phone_nos</span> <span class="operator">=</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'phone_no'</span><span class="operator">);</span>
</code></code></pre>

<p>gets the value of the named sub-element</p>

<p>if the sub-element is a non-terminal, will return a node(s) if the sub-element is a terminal (leaf) it will return the data value(s)</p>

<p>the examples above would work on a data structure like this:</p>

<pre><code><code>  [person =&gt; [ [name =&gt; &#39;fred&#39;],
               [phone_no =&gt; &#39;1-800-111-2222&#39;],
               [phone_no =&gt; &#39;1-415-555-5555&#39;]]]</code></code></pre>

<p>will return an array or single value depending on the context</p>

<p>[equivalent to findval(), except that only direct children (as opposed to all descendents) are checked]</p>

<p>paths can also be used, like this:</p>

<pre><code><code> @phones_nos = $struct-&gt;get(&#39;person/phone_no&#39;)</code></code></pre>

<h3 id="sget-sg-">sget (sg)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">sget</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">sg</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">ANY</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">sget</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$phone</span> <span class="operator">=</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">sget</span><span class="operator">(</span><span class="string">'phone_no'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$phone</span> <span class="operator">=</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">sget</span><span class="operator">(</span><span class="string">'department/person/name'</span><span class="operator">);</span>
</code></code></pre>

<p>as <b>get</b> but always returns a single value</p>

<p>[equivalent to sfindval(), except that only direct children (as opposed to all descendents) are checked]</p>

<h3 id="getl-gl-getlist-">getl (gl getlist)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">gl</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">getl</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">getlist</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span><span class="operator">[]</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">node</span><span class="operator">[]</span> <span class="keyword">or</span> <span class="variable">ANY</span><span class="operator">[]</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="operator">(</span><span class="variable">$name</span><span class="operator">,</span> <span class="variable">@phone</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">getl</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">,</span> <span class="string">'phone_no'</span><span class="operator">);</span>
</code></code></pre>

<p>returns the data values for a list of sub-elements of a node</p>

<p>[equivalent to findvallist(), except that only direct children (as opposed to all descendents) are checked]</p>

<h3 id="getn-gn-getnode-">getn (gn getnode)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">getn</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">gn</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">getnode</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">node</span><span class="operator">[]</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$namestruct</span> <span class="operator">=</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">getn</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@pstructs</span> <span class="operator">=</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">getn</span><span class="operator">(</span><span class="string">'phone_no'</span><span class="operator">);</span>
</code></code></pre>

<p>as <b>get</b> but returns the whole node rather than just the data value</p>

<p>[equivalent to findnode(), except that only direct children (as opposed to all descendents) are checked]</p>

<h3 id="sgetmap-sgm-">sgetmap (sgm)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">sgetmap</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">sgm</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">hash</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">hash</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">%h</span> <span class="operator">=</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">sgetmap</span><span class="operator">(</span><span class="string">'social-security-no'</span><span class="operator">=&gt;</span><span class="string">'id'</span><span class="operator">,</span> 
                                    <span class="string">'name'</span>              <span class="operator">=&gt;</span><span class="string">'label'</span><span class="operator">,</span>
                                    <span class="string">'job'</span>               <span class="operator">=&gt;</span><span class="number">0</span><span class="operator">,</span>
                                    <span class="string">'address'</span>           <span class="operator">=&gt;</span><span class="string">'location'</span><span class="operator">);</span>
</code></code></pre>

<p>returns a hash of key/val pairs based on the values of the data values of the subnodes in the current element; keys are mapped according to the hash passed (a value of &#39;&#39; or 0 will map an identical key/val).</p>

<p>no multivalued data elements are allowed</p>

<h3 id="set-s-">set (s)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">set</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="keyword">s</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">datavalue</span> <span class="variable">ANY</span> <span class="operator">(</span><span class="variable">list</span><span class="operator">)</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">ANY</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">,</span> <span class="string">'fred'</span><span class="operator">);</span>    <span class="comment"># single val</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">'phone_no'</span><span class="operator">,</span> <span class="variable">$cellphone</span><span class="operator">,</span> <span class="variable">$homephone</span><span class="operator">);</span>
</code></code></pre>

<p>sets the data value of an element for any node. if the element is multivalued, all the old values will be replaced with the new ones specified.</p>

<p>ordering will be preserved, unless the element specified does not exist, in which case, the new tag/value pair will be placed at the end.</p>

<p>for example, if we have a stag node $person</p>

<pre><code><code>  person:
    name: shuggy
    job:  bus driver</code></code></pre>

<p>if we do this</p>

<pre><code><code>  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">,</span> <span class="operator">());</span>
</code></code></pre>

<p>we will end up with</p>

<pre><code><code>  person:
    job:  bus driver</code></code></pre>

<p>then if we do this</p>

<pre><code><code>  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">,</span> <span class="string">'shuggy'</span><span class="operator">);</span>
</code></code></pre>

<p>the &#39;name&#39; node will be placed as the last attribute</p>

<pre><code><code>  person:
    job:  bus driver
    name: shuggy</code></code></pre>

<p>You can also use <b>magic methods</b>, for example</p>

<pre><code><code>  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">set_name</span><span class="operator">(</span><span class="string">'shuggy'</span><span class="operator">);</span>
  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">set_job</span><span class="operator">(</span><span class="string">'bus driver'</span><span class="operator">,</span> <span class="string">'poet'</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">itext</span><span class="operator">;</span>
</code></code></pre>

<p>will print</p>

<pre><code><code>  person:
    name: shuggy
    job:  bus driver
    job:  poet

  </code></code></pre>

<p>note that if the datavalue is a non-terminal node as opposed to a primitive value, then you have to do it like this:</p>

<pre><code><code>  <span class="variable">$people</span>  <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">people</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                      <span class="operator">[</span><span class="string">person</span><span class="operator">=&gt;</span><span class="operator">[[</span><span class="string">name</span><span class="operator">=&gt;</span><span class="string">'Sherlock Holmes'</span><span class="operator">]]]</span><span class="operator">,</span>
                                      <span class="operator">[</span><span class="string">person</span><span class="operator">=&gt;</span><span class="operator">[[</span><span class="string">name</span><span class="operator">=&gt;</span><span class="string">'Moriarty'</span><span class="operator">]]]</span><span class="operator">,</span>
                                     <span class="operator">]</span><span class="operator">);</span>
  <span class="variable">$address</span> <span class="operator">=</span> <span class="variable">Data::Stag</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">address</span><span class="operator">=&gt;</span><span class="operator">[</span>
                                       <span class="operator">[</span><span class="string">address_line</span><span class="operator">=&gt;</span><span class="string">"221B Baker Street"</span><span class="operator">]</span><span class="operator">,</span>
                                       <span class="operator">[</span><span class="string">city</span><span class="operator">=&gt;</span><span class="string">"London"</span><span class="operator">]</span><span class="operator">,</span>
                                       <span class="operator">[</span><span class="string">country</span><span class="operator">=&gt;</span><span class="string">"Great Britain"</span><span class="operator">]]</span><span class="operator">);</span>
  <span class="operator">(</span><span class="variable">$person</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$people</span><span class="operator">-&gt;</span><span class="variable">qmatch</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">,</span> <span class="operator">(</span><span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">"Sherlock Holmes"</span><span class="operator">));</span>
  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">"address"</span><span class="operator">,</span> <span class="variable">$address</span><span class="operator">-&gt;</span><span class="variable">data</span><span class="operator">);</span>
</code></code></pre>

<p>If you are using XML data, you can set attributes like this:</p>

<pre><code><code>  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">'@'</span><span class="operator">=&gt;</span><span class="operator">[[</span><span class="string">id</span><span class="operator">=&gt;</span><span class="variable">$id</span><span class="operator">]</span><span class="operator">,</span><span class="operator">[</span><span class="string">foo</span><span class="operator">=&gt;</span><span class="variable">$foo</span><span class="operator">]]</span><span class="operator">);</span>
</code></code></pre>

<h3 id="unset-u-">unset (u)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">unset</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">u</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">datavalue</span> <span class="variable">ANY</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">ANY</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">unset</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">unset</span><span class="operator">(</span><span class="string">'phone_no'</span><span class="operator">);</span>
</code></code></pre>

<p>prunes all nodes of the specified element from the current node</p>

<p>You can use <b>magic methods</b>, like this</p>

<pre><code><code>  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">unset_name</span><span class="operator">;</span>
  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">unset_phone_no</span><span class="operator">;</span>
</code></code></pre>

<h3 id="free">free</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">free</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">u</span>
       
        <span class="variable">Args</span><span class="operator">:</span> 
             <span class="variable">Return</span><span class="operator">:</span> 
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">free</span><span class="operator">;</span>
</code></code></pre>

<p>removes all data from a node. If that node is a subnode of another node, it is removed altogether</p>

<p>for instance, if we had the data below:</p>

<pre><code><code>  &lt;person&gt;
    &lt;name&gt;fred&lt;/name&gt;
    &lt;address&gt;
    ..
    &lt;/address&gt;
  &lt;/person&gt;</code></code></pre>

<p>and called</p>

<pre><code><code>  $person-&gt;get_address-&gt;free</code></code></pre>

<p>then the person node would look like this:</p>

<pre><code><code>  &lt;person&gt;
    &lt;name&gt;fred&lt;/name&gt;
  &lt;/person&gt;</code></code></pre>

<h3 id="add-a-">add (a)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">add</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">a</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">datavalues</span> <span class="variable">ANY</span><span class="operator">[]</span>
              <span class="variable">OR</span>
              <span class="variable">Data::Stag</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">ANY</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">add</span><span class="operator">(</span><span class="string">'phone_no'</span><span class="operator">,</span> <span class="variable">$cellphone</span><span class="operator">,</span> <span class="variable">$homephone</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">add_phone_no</span><span class="operator">(</span><span class="string">'1-555-555-5555'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$dataset</span><span class="operator">-&gt;</span><span class="variable">add</span><span class="operator">(</span><span class="variable">$person</span><span class="operator">)</span>
</code></code></pre>

<p>adds a datavalue or list of datavalues. appends if already existing, creates new element value pairs if not already existing.</p>

<p>if the argument is a stag node, it will add this node under the current one.</p>

<p>For example, if we have the following node in $dataset</p>

<pre><code><code> &lt;dataset&gt;
   &lt;person&gt;
     &lt;name&gt;jim&lt;/name&gt;
   &lt;/person&gt;
 &lt;/dataset&gt;</code></code></pre>

<p>And then we add data to it:</p>

<pre><code><code>  <span class="operator">(</span><span class="variable">$person</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$dataset</span><span class="operator">-&gt;</span><span class="variable">qmatch</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">,</span> <span class="string">name</span><span class="operator">=&gt;</span><span class="string">'jim'</span><span class="operator">);</span>
  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">add</span><span class="operator">(</span><span class="string">'phone_no'</span><span class="operator">,</span> <span class="string">'555-1111'</span><span class="operator">,</span> <span class="string">'555-2222'</span><span class="operator">);</span>
</code></code></pre>

<p>We will be left with:</p>

<pre><code><code> &lt;dataset&gt;
   &lt;person&gt;
     &lt;name&gt;jim&lt;/name&gt;
     &lt;phone_no&gt;555-1111&lt;/phone_no&gt;
     &lt;phone_no&gt;555-2222&lt;/phone_no&gt;
   &lt;/person&gt;
 &lt;/dataset&gt;</code></code></pre>

<p>The above call is equivalent to:</p>

<pre><code><code>  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">add_phone_no</span><span class="operator">(</span><span class="string">'555-1111'</span><span class="operator">,</span> <span class="string">'555-2222'</span><span class="operator">);</span>
</code></code></pre>

<p>As well as adding data values, we can add whole nodes:</p>

<pre><code><code>  <span class="variable">$dataset</span><span class="operator">-&gt;</span><span class="variable">add</span><span class="operator">(</span><span class="string">person</span><span class="operator">=&gt;</span><span class="operator">[[</span><span class="string">name</span><span class="operator">=&gt;</span><span class="string">"fred"</span><span class="operator">]</span><span class="operator">,</span>
                         <span class="operator">[</span><span class="string">phone_no</span><span class="operator">=&gt;</span><span class="string">"555-3333"</span><span class="operator">]]</span><span class="operator">);</span>
</code></code></pre>

<p>Which is equivalent to</p>

<pre><code><code>  <span class="variable">$dataset</span><span class="operator">-&gt;</span><span class="variable">add_person</span><span class="operator">(</span><span class="operator">[[</span><span class="string">name</span><span class="operator">=&gt;</span><span class="string">"fred"</span><span class="operator">]</span><span class="operator">,</span>
                        <span class="operator">[</span><span class="string">phone_no</span><span class="operator">=&gt;</span><span class="string">"555-3333"</span><span class="operator">]]</span><span class="operator">);</span>
</code></code></pre>

<p>Remember, the value has to be specified as an array reference of nodes. In general, you should use the addkid() method to add nodes and used add() to add values</p>

<h3 id="element-e-name-">element (e name)</h3>

<pre><code><code>       Title: element
     Synonym: e
     Synonym: name

        Args:
      Return: element str
     Example: $element = $struct-&gt;element</code></code></pre>

<p>returns the <b>element name</b> of the current node.</p>

<p>This is illustrated in the different representation formats below</p>

<dl>

<dt id="sxpr1">sxpr</dt>
<dd>

<pre><code><code>  (element &quot;data&quot;)</code></code></pre>

<p>or</p>

<pre><code><code>  (element
   (sub_element &quot;...&quot;))</code></code></pre>

</dd>
<dt id="xml1">xml</dt>
<dd>

<pre><code><code>  &lt;element&gt;data&lt;/element&gt;</code></code></pre>

<p>or</p>

<pre><code><code>  &lt;element&gt;
    &lt;sub_element&gt;...&lt;/sub_element&gt;
  &lt;/element&gt;</code></code></pre>

</dd>
<dt id="perl">perl</dt>
<dd>

<pre><code><code>  [element =&gt; $data ]</code></code></pre>

<p>or</p>

<pre><code><code>  [element =&gt; [
                [sub_element =&gt; &quot;...&quot; ]]]</code></code></pre>

</dd>
<dt id="itext1">itext</dt>
<dd>

<pre><code><code>  element: data</code></code></pre>

<p>or</p>

<pre><code><code>  element:
    sub_element: ...</code></code></pre>

</dd>
<dt id="indent1">indent</dt>
<dd>

<pre><code><code>  element &quot;data&quot;</code></code></pre>

<p>or</p>

<pre><code><code>  element
    sub_element &quot;...&quot;</code></code></pre>

</dd>
</dl>

<h3 id="kids-k-children-">kids (k children)</h3>

<pre><code><code>       Title: kids
     Synonym: k
     Synonym: children

        Args:
      Return: ANY or ANY[]
     Example: @nodes = $person-&gt;kids
     Example: $name = $namestruct-&gt;kids</code></code></pre>

<p>returns the data value(s) of the current node; if it is a terminal node, returns a single value which is the data. if it is non-terminal, returns an array of nodes</p>

<h3 id="addkid-ak-addchild-">addkid (ak addchild)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">addkid</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">ak</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">addchild</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">kid</span> <span class="variable">node</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">ANY</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">addkid</span><span class="operator">(</span><span class="variable">$job</span><span class="operator">);</span>
</code></code></pre>

<p>adds a new child node to a non-terminal node, after all the existing child nodes</p>

<p>You can use this method/procedure to add XML attribute data to a node:</p>

<pre><code><code>  <span class="variable">$person</span><span class="operator">-&gt;</span><span class="variable">addkid</span><span class="operator">(</span><span class="operator">[</span><span class="string">'@'</span><span class="operator">=&gt;</span><span class="operator">[[</span><span class="string">id</span><span class="operator">=&gt;</span><span class="variable">$id</span><span class="operator">]]]</span><span class="operator">);</span>
</code></code></pre>

<h3 id="subnodes">subnodes</h3>

<pre><code><code>       Title: subnodes

        Args: 
      Return: ANY[]
     Example: @nodes = $person-&gt;subnodes</code></code></pre>

<p>returns the child nodes; returns empty list if this is a terminal node</p>

<h3 id="ntnodes">ntnodes</h3>

<pre><code><code>       Title: ntnodes

        Args: 
      Return: ANY[]
     Example: @nodes = $person-&gt;ntnodes</code></code></pre>

<p>returns all non-terminal children of current node</p>

<h3 id="tnodes">tnodes</h3>

<pre><code><code>       Title: tnodes

        Args: 
      Return: ANY[]
     Example: @nodes = $person-&gt;tnodes</code></code></pre>

<p>returns all terminal children of current node</p>

<h2 id="QUERYING-AND-ADVANCED-DATA-MANIPULATION">QUERYING AND ADVANCED DATA MANIPULATION</h2>

<h3 id="ijoin-j-">ijoin (j)</h3>

<pre><code><code>       Title: ijoin
     Synonym: j
     Synonym: ij

        Args: element str, key str, data Node
      Return: undef</code></code></pre>

<p>does a relational style inner join - see previous example in this doc</p>

<p>key can either be a single node name that must be shared (analagous to SQL INNER JOIN .. USING), or a key1=key2 equivalence relation (analagous to SQL INNER JOIN ... ON)</p>

<h3 id="qmatch-qm-">qmatch (qm)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">qmatch</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">qm</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="keyword">return</span><span class="operator">-</span><span class="variable">element</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">match</span><span class="operator">-</span><span class="variable">element</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">match</span><span class="operator">-</span><span class="variable">value</span> <span class="variable">str</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">node</span><span class="operator">[]</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">$s</span><span class="operator">-&gt;</span><span class="variable">qmatch</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">,</span> <span class="string">'name'</span><span class="operator">,</span> <span class="string">'fred'</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="variable">$s</span><span class="operator">-&gt;</span><span class="variable">qmatch</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">,</span> <span class="operator">(</span><span class="string">job</span><span class="operator">=&gt;</span><span class="string">'bus driver'</span><span class="operator">));</span>
</code></code></pre>

<p>queries the node tree for all elements that satisfy the specified key=val match - see previous example in this doc</p>

<p>for those inclined to thinking relationally, this can be thought of as a query that returns a stag object:</p>

<pre><code><code>  SELECT &lt;return-element&gt; FROM &lt;stag-node&gt; WHERE &lt;match-element&gt; = &lt;match-value&gt;</code></code></pre>

<p>this always returns an array; this means that calling in a scalar context will return the number of elements; for example</p>

<pre><code><code>  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">$s</span><span class="operator">-&gt;</span><span class="variable">qmatch</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">,</span> <span class="operator">(</span><span class="string">name</span><span class="operator">=&gt;</span><span class="string">'fred'</span><span class="operator">));</span>
</code></code></pre>

<p>the value of $n will be equal to the number of persons called fred</p>

<h3 id="tmatch-tm-">tmatch (tm)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">tmatch</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">tm</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">value</span> <span class="variable">str</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">bool</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="keyword">grep</span> <span class="operator">{</span><span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">tmatch</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">,</span> <span class="string">'fred'</span><span class="operator">)}</span> <span class="variable">@persons</span>
</code></code></pre>

<p>returns true if the the value of the specified element matches - see previous example in this doc</p>

<h3 id="tmatchhash-tmh-">tmatchhash (tmh)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">tmatchhash</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">tmh</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">match</span> <span class="variable">hashref</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">bool</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="keyword">grep</span> <span class="operator">{</span><span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">tmatchhash</span><span class="operator">(</span><span class="operator">{</span><span class="string">name</span><span class="operator">=&gt;</span><span class="string">'fred'</span><span class="operator">,</span> <span class="string">hair_colour</span><span class="operator">=&gt;</span><span class="string">'green'</span><span class="operator">}</span><span class="operator">)}</span> <span class="variable">@persons</span>
</code></code></pre>

<p>returns true if the node matches a set of constraints, specified as hash.</p>

<h3 id="tmatchnode-tmn-">tmatchnode (tmn)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">tmatchnode</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">tmn</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">match</span> <span class="variable">node</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">bool</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@persons</span> <span class="operator">=</span> <span class="keyword">grep</span> <span class="operator">{</span><span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">tmatchnode</span><span class="operator">(</span><span class="operator">[</span><span class="string">person</span><span class="operator">=&gt;</span><span class="operator">[[</span><span class="string">name</span><span class="operator">=&gt;</span><span class="string">'fred'</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="string">hair_colour</span><span class="operator">=&gt;</span><span class="string">'green'</span><span class="operator">]]]</span><span class="operator">)}</span> <span class="variable">@persons</span>
</code></code></pre>

<p>returns true if the node matches a set of constraints, specified as node</p>

<h3 id="cmatch-cm-">cmatch (cm)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">cmatch</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">cm</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">value</span> <span class="variable">str</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">bool</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$n_freds</span> <span class="operator">=</span> <span class="variable">$personset</span><span class="operator">-&gt;</span><span class="variable">cmatch</span><span class="operator">(</span><span class="string">'name'</span><span class="operator">,</span> <span class="string">'fred'</span><span class="operator">);</span>
</code></code></pre>

<p>counts the number of matches</p>

<h3 id="where-w-">where (w)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">where</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">w</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">element</span> <span class="variable">str</span><span class="operator">,</span> <span class="variable">test</span> <span class="variable">CODE</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">Node</span><span class="operator">[]</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@rich_persons</span> <span class="operator">=</span> <span class="variable">$data</span><span class="operator">-&gt;</span><span class="variable">where</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">,</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">-&gt;</span><span class="variable">get_salary</span> <span class="operator">&gt;</span> <span class="number">100000</span><span class="operator">});</span>
</code></code></pre>

<p>the tree is queried for all elements of the specified type that satisfy the coderef (must return a boolean)</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">@rich_dog_or_cat_owners</span> <span class="operator">=</span>
    <span class="variable">$data</span><span class="operator">-&gt;</span><span class="variable">where</span><span class="operator">(</span><span class="string">'person'</span><span class="operator">,</span>
                 <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">my</span> <span class="variable">$p</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
                      <span class="variable">$p</span><span class="operator">-&gt;</span><span class="variable">get_salary</span> <span class="operator">&gt;</span> <span class="number">100000</span> <span class="operator">&amp;&amp;</span>
                      <span class="variable">$p</span><span class="operator">-&gt;</span><span class="variable">where</span><span class="operator">(</span><span class="string">'pet'</span><span class="operator">,</span>
                                <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">-&gt;</span><span class="variable">get_type</span> <span class="operator">=~</span> <span class="regex">/(dog|cat)/</span><span class="operator">})});</span>
</code></code></pre>

<h3 id="iterate-i-">iterate (i)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">iterate</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">i</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">CODE</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">Node</span><span class="operator">[]</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$data</span><span class="operator">-&gt;</span><span class="variable">iterate</span><span class="operator">(</span><span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
                                 <span class="keyword">my</span> <span class="variable">$stag</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
                                 <span class="keyword">my</span> <span class="variable">$parent</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
                                 <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">element</span> <span class="keyword">eq</span> <span class="string">'pet'</span><span class="operator">)</span> <span class="operator">{</span>
                                     <span class="variable">$parent</span><span class="operator">-&gt;</span><span class="variable">set_pet_name</span><span class="operator">(</span><span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">get_name</span><span class="operator">);</span>
                                 <span class="operator">}</span>
                             <span class="operator">});</span>
</code></code></pre>

<p>iterates through whole tree calling the specified subroutine.</p>

<p>the first arg passed to the subroutine is the stag node representing the tree at that point; the second arg is for the parent.</p>

<p>for instance, the example code above would turn this</p>

<pre><code><code>  (person
   (name &quot;jim&quot;)
   (pet
    (name &quot;fluffy&quot;)))</code></code></pre>

<p>into this</p>

<pre><code><code>  (person
   (name &quot;jim&quot;)
   (pet_name &quot;fluffy&quot;)
   (pet
    (name &quot;fluffy&quot;)))</code></code></pre>

<h3 id="maptree">maptree</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">maptree</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">CODE</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">Node</span><span class="operator">[]</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$data</span><span class="operator">-&gt;</span><span class="variable">maptree</span><span class="operator">(</span><span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
                                 <span class="keyword">my</span> <span class="variable">$stag</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
                                 <span class="keyword">my</span> <span class="variable">$parent</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
                                 <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">element</span> <span class="keyword">eq</span> <span class="string">'pet'</span><span class="operator">)</span> <span class="operator">{</span>
                                     <span class="operator">[</span><span class="string">pet</span><span class="operator">=&gt;</span><span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">sget_foo</span><span class="operator">]</span>
                                 <span class="operator">}</span>
                                 <span class="keyword">else</span> <span class="operator">{</span>
                                     <span class="variable">$stag</span>
                                 <span class="operator">}</span>
                             <span class="operator">});</span>
</code></code></pre>

<h2 id="MISCELLANEOUS-METHODS">MISCELLANEOUS METHODS</h2>

<h3 id="duplicate-d-">duplicate (d)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">duplicate</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">d</span>
       
        <span class="variable">Args</span><span class="operator">:</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">Node</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node2</span> <span class="operator">=</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">duplicate</span><span class="operator">;</span>
</code></code></pre>

<p>does a deep copy of a stag structure</p>

<h3 id="isanode">isanode</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">isanode</span>
       
        <span class="variable">Args</span><span class="operator">:</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">bool</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="keyword">if</span> <span class="operator">(</span><span class="variable">stag_isanode</span><span class="operator">(</span><span class="variable">$node</span><span class="operator">))</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</code></code></pre>

<h3 id="hash">hash</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">hash</span>
       
        <span class="variable">Args</span><span class="operator">:</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">hash</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$h</span> <span class="operator">=</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">hash</span><span class="operator">;</span>
        
</code></code></pre>

<p>turns a tree into a hash. all data values will be arrayrefs</p>

<h3 id="pairs">pairs</h3>

<pre><code><code>       Title: pairs</code></code></pre>

<p>turns a tree into a hash. all data values will be scalar (IMPORTANT: this means duplicate values will be lost)</p>

<h3 id="write">write</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="keyword">write</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">filename</span> <span class="variable">str</span><span class="operator">,</span> <span class="keyword">format</span> <span class="variable">str</span><span class="operator">[</span><span class="variable">optional</span><span class="operator">]</span>
             <span class="variable">Return</span><span class="operator">:</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">write</span><span class="operator">(</span><span class="string">"myfile.xml"</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">write</span><span class="operator">(</span><span class="string">"myfile"</span><span class="operator">,</span> <span class="string">"itext"</span><span class="operator">);</span>
</code></code></pre>

<p>will try and guess the format from the extension if not specified</p>

<h3 id="xml2">xml</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">xml</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">filename</span> <span class="variable">str</span><span class="operator">,</span> <span class="keyword">format</span> <span class="variable">str</span><span class="operator">[</span><span class="variable">optional</span><span class="operator">]</span>
             <span class="variable">Return</span><span class="operator">:</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">write</span><span class="operator">(</span><span class="string">"myfile.xml"</span><span class="operator">);</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">write</span><span class="operator">(</span><span class="string">"myfile"</span><span class="operator">,</span> <span class="string">"itext"</span><span class="operator">);</span>
       
       
        <span class="variable">Args</span><span class="operator">:</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">xml</span> <span class="variable">str</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="keyword">print</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">xml</span><span class="operator">;</span>
</code></code></pre>

<h2 id="XML-METHODS">XML METHODS</h2>

<h3 id="xslt">xslt</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">xslt</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">xslt_file</span> <span class="variable">str</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">Node</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$new_stag</span> <span class="operator">=</span> <span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">xslt</span><span class="operator">(</span><span class="string">'mytransform.xsl'</span><span class="operator">);</span>
</code></code></pre>

<p>transforms a stag tree using XSLT</p>

<h3 id="xsltstr">xsltstr</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">xsltstr</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">xslt_file</span> <span class="variable">str</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">str</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="keyword">print</span> <span class="variable">$stag</span><span class="operator">-&gt;</span><span class="variable">xsltstr</span><span class="operator">(</span><span class="string">'mytransform.xsl'</span><span class="operator">);</span>
</code></code></pre>

<p>As above, but returns the string of the resulting transform, rather than a stag tree</p>

<h3 id="sax">sax</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">sax</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">saxhandler</span> <span class="variable">SAX</span><span class="operator">-</span><span class="variable">CLASS</span>
             <span class="variable">Return</span><span class="operator">:</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">sax</span><span class="operator">(</span><span class="variable">$mysaxhandler</span><span class="operator">);</span>
</code></code></pre>

<p>turns a tree into a series of SAX events</p>

<h3 id="xpath-xp-tree2xpath-">xpath (xp tree2xpath)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">xpath</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">xp</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">tree2xpath</span>
       
        <span class="variable">Args</span><span class="operator">:</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">xpath</span> <span class="variable">object</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">$xp</span> <span class="operator">=</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">xpath</span><span class="operator">;</span> <span class="variable">$q</span> <span class="operator">=</span> <span class="variable">$xp</span><span class="operator">-&gt;</span><span class="variable">find</span><span class="operator">(</span><span class="variable">$xpathquerystr</span><span class="operator">);</span>
</code></code></pre>

<h3 id="xpquery-xpq-xpathquery-">xpquery (xpq xpathquery)</h3>

<pre><code><code>       <span class="variable">Title</span><span class="operator">:</span> <span class="variable">xpquery</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">xpq</span>
            <span class="variable">Synonym</span><span class="operator">:</span> <span class="variable">xpathquery</span>
       
        <span class="variable">Args</span><span class="operator">:</span> <span class="variable">xpathquery</span> <span class="variable">str</span>
             <span class="variable">Return</span><span class="operator">:</span> <span class="variable">Node</span><span class="operator">[]</span>
            <span class="variable">Example</span><span class="operator">:</span> <span class="variable">@nodes</span> <span class="operator">=</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">xqp</span><span class="operator">(</span><span class="variable">$xpathquerystr</span><span class="operator">);</span>
</code></code></pre>

<h1 id="STAG-SCRIPTS">STAG SCRIPTS</h1>

<p>The following scripts come with the stag module</p>

<dl>

<dt id="stag-autoschema.pl">stag-autoschema.pl</dt>
<dd>

<p>writes the implicit stag-schema for a stag file</p>

</dd>
<dt id="stag-db.pl">stag-db.pl</dt>
<dd>

<p>persistent storage and retrieval for stag data (xml, sxpr, itext)</p>

</dd>
<dt id="stag-diff.pl">stag-diff.pl</dt>
<dd>

<p>finds the difference between two stag files</p>

</dd>
<dt id="stag-drawtree.pl">stag-drawtree.pl</dt>
<dd>

<p>draws a stag file (xml, itext, sxpr) as a PNG diagram</p>

</dd>
<dt id="stag-filter.pl">stag-filter.pl</dt>
<dd>

<p>filters a stag file (xml, itext, sxpr) for nodes of interest</p>

</dd>
<dt id="stag-findsubtree.pl">stag-findsubtree.pl</dt>
<dd>

<p>finds nodes in a stag file</p>

</dd>
<dt id="stag-flatten.pl">stag-flatten.pl</dt>
<dd>

<p>turns stag data into a flat table</p>

</dd>
<dt id="stag-grep.pl">stag-grep.pl</dt>
<dd>

<p>filters a stag file (xml, itext, sxpr) for nodes of interest</p>

</dd>
<dt id="stag-handle.pl">stag-handle.pl</dt>
<dd>

<p>streams a stag file through a handler into a writer</p>

</dd>
<dt id="stag-join.pl">stag-join.pl</dt>
<dd>

<p>joins two stag files together based around common key</p>

</dd>
<dt id="stag-mogrify.pl">stag-mogrify.pl</dt>
<dd>

<p>mangle stag files</p>

</dd>
<dt id="stag-parse.pl">stag-parse.pl</dt>
<dd>

<p>parses a file and fires events (e.g. sxpr to xml)</p>

</dd>
<dt id="stag-query.pl">stag-query.pl</dt>
<dd>

<p>aggregare queries</p>

</dd>
<dt id="stag-split.pl">stag-split.pl</dt>
<dd>

<p>splits a stag file (xml, itext, sxpr) into multiple files</p>

</dd>
<dt id="stag-splitter.pl">stag-splitter.pl</dt>
<dd>

<p>splits a stag file into multiple files</p>

</dd>
<dt id="stag-view.pl">stag-view.pl</dt>
<dd>

<p>draws an expandable Tk tree diagram showing stag data</p>

</dd>
</dl>

<p>To get more documentation, type</p>

<pre><code><code>  stag_&lt;script&gt; -h</code></code></pre>

<h1 id="BUGS">BUGS</h1>

<p>none known so far, possibly quite a few undocumented features!</p>

<p>Not a bug, but the underlying default datastructure of nested arrays is more heavyweight than it needs to be. More lightweight implementations are possible. Some time I will write a C implementation.</p>

<h1 id="WEBSITE">WEBSITE</h1>

<p><a href="http://stag.sourceforge.net">http://stag.sourceforge.net</a></p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Chris Mungall &lt;<i>cjm AT fruitfly DOT org</i>&gt;</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 2004 Chris Mungall</p>

<p>This module is free software. You may distribute this module under the same terms as perl itself</p>


</body>

</html>


