<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#Appetizers">Appetizers</a>
    <ul>
      <li><a href="#Hello-world">Hello, world</a></li>
      <li><a href="#One-Liner">One Liner</a></li>
    </ul>
  </li>
  <li><a href="#Meat-Potatoes">Meat &amp; Potatoes</a>
    <ul>
      <li><a href="#Data-Types">Data Types</a></li>
      <li><a href="#Variable-Argument-Lists">Variable Argument Lists</a></li>
      <li><a href="#Multiple-Return-Values">Multiple Return Values</a></li>
      <li><a href="#Multiple-Return-Values-Another-Way-">Multiple Return Values (Another Way)</a></li>
      <li><a href="#Using-Memory">Using Memory</a></li>
    </ul>
  </li>
  <li><a href="#Fast-Food">Fast Food</a>
    <ul>
      <li><a href="#Inline-CGI">Inline CGI</a></li>
      <li><a href="#mod_perl">mod_perl</a></li>
      <li><a href="#Object-Oriented-Inline">Object Oriented Inline</a></li>
    </ul>
  </li>
  <li><a href="#The-Main-Course">The Main Course</a>
    <ul>
      <li><a href="#Exposing-Shared-Libraries">Exposing Shared Libraries</a></li>
      <li><a href="#Automatic-Function-Wrappers">Automatic Function Wrappers</a></li>
      <li><a href="#Complex-Data">Complex Data</a></li>
      <li><a href="#Hash-of-Lists">Hash of Lists</a></li>
    </ul>
  </li>
  <li><a href="#Just-Desserts">Just Desserts</a>
    <ul>
      <li><a href="#Win32">Win32</a></li>
      <li><a href="#Embedding-Perl-in-C">Embedding Perl in C</a></li>
    </ul>
  </li>
  <li><a href="#Entertaining-Guests">Entertaining Guests</a>
    <ul>
      <li><a href="#Event-handling-with-Event.pm">Event handling with Event.pm</a></li>
    </ul>
  </li>
  <li><a href="#Food-for-Thought">Food for Thought</a>
    <ul>
      <li><a href="#Calling-C-from-both-Perl-and-C">Calling C from both Perl and C</a></li>
      <li><a href="#Calling-Perl-from-C">Calling Perl from C</a></li>
      <li><a href="#Evaling-C">Evaling C</a></li>
      <li><a href="#Providing-a-pure-perl-alternative">Providing a pure perl alternative</a></li>
      <li><a href="#Accessing-Fortran-subs-using-Inline::C">Accessing Fortran subs using Inline::C</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Inline::C-Cookbook - A Cornucopia of Inline C Recipes</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>It&#39;s a lot easier for most of us to cook a meal from a recipe, rather than just throwing things into a pot until something edible forms. So it is with programming as well. <code><code>Inline.pm</code></code> makes C programming for Perl as easy as possible. Having a set of easy to understand samples, makes it simpler yet.</p>

<p>This Cookbook is intended to be an evergrowing repository of small yet complete coding examples; each showing how to accomplish a particular task with Inline. Each example is followed by a short discussion, explaining in detail the particular features that are being demonstrated.</p>

<p>Many of these recipes are apdapted from email discussions I have had with Inline users around the world. It has been my experience so far, that Inline provides an elegant solution to almost all problems involving Perl and C.</p>

<p>Bon Appetit!</p>

<h1 id="Appetizers">Appetizers</h1>

<h2 id="Hello-world">Hello, world</h2>

<dl>

<dt id="Problem">Problem</dt>
<dd>

<p>It seems that the first thing any programmer wants to do when he learns a new programming technique is to use it to greet the Earth. How can I do this using Inline?</p>

</dd>
<dt id="Solution">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'END_C'</span><span class="operator">;</span><span class="string">
    
    void greet() {
        printf("Hello, world\n");
    }
    </span><span class="default">END_C</span>
    
    <span class="variable">greet</span><span class="operator">;</span>
</code></code></pre>

</dd>
<dt id="Discussion">Discussion</dt>
<dd>

<p>Nothing too fancy here. We define a single C function <code><code>greet()</code></code> which prints a message to STDOUT. One thing to note is that since the Inline code comes before the function call to <code><code>greet</code></code>, we can call it as a bareword (no parentheses).</p>

</dd>
<dt id="See-Also">See Also</dt>
<dd>

<p>See <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline.html">Inline</a> and <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline/C.html">Inline::C</a> for basic info about <code><code>Inline.pm</code></code>.</p>

</dd>
<dt id="Credits">Credits</dt>
<dd>

<p>Brian Kernigan</p>

<p>Dennis Ritchie</p>

</dd>
</dl>

<h2 id="One-Liner">One Liner</h2>

<dl>

<dt id="Problem1">Problem</dt>
<dd>

<p>A concept is valid in Perl only if it can be shown to work in one line. Can Inline reduce the complexities of Perl/C interaction to a one-liner?</p>

</dd>
<dt id="Solution1">Solution</dt>
<dd>

<pre><code><code>    <span class="variable">perl</span> <span class="keyword">-e</span> <span class="string">'use Inline C=&gt;q{void greet(){printf("Hello, world\n");}};greet'</span>
</code></code></pre>

</dd>
<dt id="Discussion1">Discussion</dt>
<dd>

<p>Try doing that in XS :-)</p>

</dd>
<dt id="See-Also1">See Also</dt>
<dd>

<p>My email signature of late is:</p>

<pre><code><code>    <span class="variable">perl</span> <span class="operator">-</span><span class="keyword">le</span> <span class="string">'use Inline C=&gt;q{SV*JAxH(char*x){return newSVpvf("Just Another %s Hacker",x);}};print JAxH+Perl'</span>
</code></code></pre>

<p>A bit fancier but a few bytes too long to qualify as a true one liner :-(</p>

</dd>
<dt id="Credits1">Credits</dt>
<dd>

<p>&quot;Eli the Bearded&quot; &lt;elijah@workspot.net&gt; gave me the idea that I should have an Inline one-liner as a signature.</p>

</dd>
</dl>

<h1 id="Meat-Potatoes">Meat &amp; Potatoes</h1>

<h2 id="Data-Types">Data Types</h2>

<dl>

<dt id="Problem2">Problem</dt>
<dd>

<p>How do I pass different types of data to and from Inline C functions; like strings, numbers and integers?</p>

</dd>
<dt id="Solution2">Solution</dt>
<dd>

<pre><code><code>    <span class="comment"># vowels.pl</span>
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="variable">C</span><span class="operator">;</span>
    
    <span class="variable">$filename</span> <span class="operator">=</span> <span class="variable">$ARGV</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">die</span> <span class="string">"Usage: perl vowels.pl filename\n"</span> <span class="keyword">unless</span> <span class="keyword">-f</span> <span class="variable">$filename</span><span class="operator">;</span>
    
    <span class="variable">$text</span> <span class="operator">=</span> <span class="keyword">join</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">&lt;&gt;;</span>           <span class="comment"># slurp input file</span>
    <span class="variable">$vp</span> <span class="operator">=</span> <span class="variable">vowel_scan</span><span class="operator">(</span><span class="variable">$text</span><span class="operator">);</span>       <span class="comment"># call our function</span>
    <span class="variable">$vp</span> <span class="operator">=</span> <span class="keyword">sprintf</span><span class="operator">(</span><span class="string">"%03.1f"</span><span class="operator">,</span> <span class="variable">$vp</span> <span class="operator">*</span> <span class="number">100</span><span class="operator">);</span>  <span class="comment"># format for printing</span>
    <span class="keyword">print</span> <span class="string">"The letters in </span><span class="variable">$filename</span><span class="string"> are </span><span class="variable">$vp</span><span class="string">% vowels.\n"</span><span class="operator">;</span>
    
    <span class="comment">__END__
    __C__
    
    /* Find percentage of vowels to letters */
    double vowel_scan(char* str) {
        int letters = 0;
        int vowels = 0;
        int i = 0;
        char c;
        char normalize = 'a' ^ 'A';
        /* normalize forces lower case in ASCII; upper in EBCDIC */
        char A = normalize | 'a';
        char E = normalize | 'e';
        char I = normalize | 'i';
        char O = normalize | 'o';
        char U = normalize | 'u';
        char Z = normalize | 'z';
    
        while(c = str[i++]) {
            c |= normalize;
            if (c &gt;= A &amp;&amp; c &lt;= Z) {
                 letters++;
                 if (c == A || c == E || c == I || c == O || c == U)
                     vowels++;
            }
        }
    
        return letters ? ((double) vowels / letters) : 0.0;
    }
    </span>
</code></code></pre>

</dd>
<dt id="Discussion2">Discussion</dt>
<dd>

<p>This script takes a file name from the command line and prints the ratio of vowels to letters in that file. <code><code>vowels.pl</code></code> uses an Inline C function called <code><code>vowel_scan</code></code>, that takes a string argument, and returns the percentage of vowels as a floating point number between 0 and 1. It handles upper and lower case letters, and works with ASCII and EBCDIC. It is also quite fast.</p>

<p>Running this script produces:</p>

<pre><code><code>    &gt; perl vowels.pl /usr/dict/words
    The letters in /usr/dict/words are 37.5% vowels.</code></code></pre>

</dd>
<dt id="See-Also2">See Also</dt>
<dd>

<p>The Perl Journal vol #19 has an article about Inline which uses this example.</p>

</dd>
<dt id="Credits2">Credits</dt>
<dd>

<p>This example was reprinted by permission of The Perl Journal. It was edited to work with Inline v0.30 and higher.</p>

</dd>
</dl>

<h2 id="Variable-Argument-Lists">Variable Argument Lists</h2>

<dl>

<dt id="Problem3">Problem</dt>
<dd>

<p>How do I pass a variable-sized list of arguments to an Inline C function?</p>

</dd>
<dt id="Solution3">Solution</dt>
<dd>

<pre><code><code>    <span class="variable">greet</span><span class="operator">(</span><span class="string">qw(Sarathy Jan Sparky Murray Mike)</span><span class="operator">);</span>
    
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'END_OF_C_CODE'</span><span class="operator">;</span><span class="string">
    
    void greet(SV* name1, ...) {
        Inline_Stack_Vars;
        int i;
    
        for (i = 0; i &lt; Inline_Stack_Items; i++)
            printf("Hello %s!\n", SvPV(Inline_Stack_Item(i), PL_na));
    
        Inline_Stack_Void;
    }
    
    </span><span class="default">END_OF_C_CODE</span>
</code></code></pre>

</dd>
<dt id="Discussion3">Discussion</dt>
<dd>

<p>This little program greets a group of people, such as my coworkers. We use the <code><code>C</code></code> ellipsis syntax: &quot;<code><code>...</code></code>&quot;, since the list can be of any size.</p>

<p>Since there are no types or names associated with each argument, we can&#39;t expect XS to handle the conversions for us. We&#39;ll need to pop them off the <b>Stack</b> ourselves. Luckily there are two functions (macros) that make this a very easy task.</p>

<p>First, we need to begin our function with a &quot;<code><code>Inline_Stack_Vars</code></code>&quot; statement. This defines a few internal variables that we need to access the <b>Stack</b>. Now we can use &quot;<code><code>Inline_Stack_Items</code></code>&quot;, which returns an integer containing the number of arguments passed to us from Perl.</p>

<p><b>NOTE:</b> It is important to <i>only</i> use &quot;<code><code>Inline_Stack_</code></code>&quot; macros when there is an ellipsis (<code><code>...</code></code>) in the argument list, <i>or</i> the function has a return type of void.</p>

<p>Second, we use the <code><code>Inline_Stack_Item(x)</code></code> function to access each argument where &quot;0 &lt;= x &lt; items&quot;.</p>

<p><b>NOTE:</b> When using a variable length argument list, you have to specify at least one argument before the ellipsis. (On my compiler, anyway.) When XS does it&#39;s argument checking, it will complain if you pass in less than the number of <i>defined</i> arguments. Therefore, there is currently no way to pass an empty list when a variable length list is expected.</p>

</dd>
<dt id="See-Also3">See Also</dt>
<dd>

</dd>
<dt id="Credits3">Credits</dt>
<dd>

</dd>
</dl>

<h2 id="Multiple-Return-Values">Multiple Return Values</h2>

<dl>

<dt id="Problem4">Problem</dt>
<dd>

<p>How do I return a list of values from a C function?</p>

</dd>
<dt id="Solution4">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">print</span> <span class="keyword">map</span> <span class="operator">{</span><span class="string">"</span><span class="variable">$_</span><span class="string">\n"</span><span class="operator">}</span> <span class="variable">get_localtime</span><span class="operator">(</span><span class="keyword">time</span><span class="operator">);</span>
    
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'END_OF_C_CODE'</span><span class="operator">;</span><span class="string">
    
    #include &lt;time.h&gt;
    
    void get_localtime(int utc) {
      struct tm *ltime = localtime(&amp;utc);
      Inline_Stack_Vars;
    
      Inline_Stack_Reset;
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_year)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_mon)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_mday)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_hour)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_min)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_sec)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_isdst)));
      Inline_Stack_Done;
    }
    </span><span class="default">END_OF_C_CODE</span>
</code></code></pre>

</dd>
<dt id="Discussion4">Discussion</dt>
<dd>

<p>Perl is a language where it is common to return a list of values from a subroutine call instead of just a single value. C is not such a language. In order to accomplish this in C we need to manipulate the Perl call stack by hand. Luckily, Inline provides macros to make this easy.</p>

<p>This example calls the system <code><code>localtime</code></code>, and returns each of the parts of the time struct; much like the perl builtin <code><code>localtime()</code></code>. On each stack push, we are creating a new Perl integer (SVIV) and mortalizing it. The sv_2mortal() call makes sure that the reference count is set properly. Without it, the program would leak memory.</p>

<p>NOTE: The <code><code><span class="comment">#include</span>
</code></code> statement is not really needed, because Inline automatically includes the Perl headers which include almost all standard system calls.</p>

</dd>
<dt id="See-Also4">See Also</dt>
<dd>

<p>For more information on the Inline stack macros, see <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline/C.html">Inline::C</a>.</p>

</dd>
<dt id="Credits4">Credits</dt>
<dd>

<p>Richard Anderson &lt;starfire@zipcon.net&gt; contributed the original idea for this snippet.</p>

</dd>
</dl>

<h2 id="Multiple-Return-Values-Another-Way-">Multiple Return Values (Another Way)</h2>

<dl>

<dt id="Problem5">Problem</dt>
<dd>

<p>How can I pass back more than one value without using the Perl Stack?</p>

</dd>
<dt id="Solution5">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline::Files</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="variable">C</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$foo</span><span class="operator">,</span> <span class="variable">$bar</span><span class="operator">);</span>
    <span class="variable">change</span><span class="operator">(</span><span class="variable">$foo</span><span class="operator">,</span> <span class="variable">$bar</span><span class="operator">);</span>
    
    <span class="keyword">print</span> <span class="string">"\$foo = </span><span class="variable">$foo</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"\$bar = </span><span class="variable">$bar</span><span class="string">\n"</span><span class="operator">;</span>
    
    <span class="variable">__C__</span>
    
    <span class="keyword">int</span> <span class="variable">change</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">var1</span><span class="operator">,</span> <span class="variable">SV</span><span class="operator">*</span> <span class="variable">var2</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">sv_setpvn</span><span class="operator">(</span><span class="variable">var1</span><span class="operator">,</span> <span class="string">"Perl Rocks!"</span><span class="operator">,</span> <span class="number">11</span><span class="operator">);</span>
        <span class="variable">sv_setpvn</span><span class="operator">(</span><span class="variable">var2</span><span class="operator">,</span> <span class="string">"Inline Rules!"</span><span class="operator">,</span> <span class="number">13</span><span class="operator">);</span>
        <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

</dd>
<dt id="Discussion5">Discussion</dt>
<dd>

<p>Most perl function interfaces return values as a list of one or more scalars. Very few like <code><code>chomp</code></code>, will modify an input scalar in place. On the other hand, in C you do this quite often. Values are passed in by reference and modified in place by the called function.</p>

<p>It turns out that we can do that with Inline as well. The secret is to use a type of &#39;<code><code>SV*</code></code>&#39; for each argument that is to be modified. This ensures passing by reference, because no typemapping is needed.</p>

<p>The function can then use the Perl5 API to operate on that argument. When control returns to Perl, the argument will retain the value set by the C function. In this example we passed in 2 empty scalars and assigned values directly to them.</p>

</dd>
<dt id="See-Also5">See Also</dt>
<dd>

</dd>
<dt id="Credits5">Credits</dt>
<dd>

<p>Ned Konz &lt;ned@bike-nomad.com&gt; brought this behavior to my attention. He also pointed out that he is not the world famous computer cyclist Steve Roberts (http://www.microship.com), but he is close (http://bike-nomad.com). Thanks Ned.</p>

</dd>
</dl>

<h2 id="Using-Memory">Using Memory</h2>

<dl>

<dt id="Problem6">Problem</dt>
<dd>

<p>How should I allocate buffers in my Inline C code?</p>

</dd>
<dt id="Solution6">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">print</span> <span class="variable">greeting</span><span class="operator">(</span><span class="string">'Ingy'</span><span class="operator">);</span>
    
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'END_OF_C_CODE'</span><span class="operator">;</span><span class="string">
    
    SV* greeting(SV* sv_name) {
        return (newSVpvf("Hello %s!\n", SvPV(sv_name, PL_na)));
    }
    
    </span><span class="default">END_OF_C_CODE</span>
</code></code></pre>

</dd>
<dt id="Discussion6">Discussion</dt>
<dd>

<p>In this example we will return the greeting to the caller, rather than printing it. This would seem mighty easy, except for the fact that we need to allocate a small buffer to create the greeting.</p>

<p>I would urge you to stay away from <code><code>malloc</code></code>ing your own buffer. Just use Perl&#39;s built in memory management. In other words, just create a new Perl string scalar. The function <code><code>newSVpv</code></code> does just that. And <code><code>newSVpvf</code></code> includes <code><code>sprintf</code></code> functionality.</p>

<p>The other problem is getting rid of this new scalar. How will the ref count get decremented after we pass the scalar back? Perl also provides a function called <code><code>sv_2mortal</code></code>. Mortal variables die when the context goes out of scope. In other words, Perl will wait until the new scalar gets passed back and then decrement the ref count for you, thereby making it eligible for garbage collection. See <code><code>perldoc perlguts</code></code>.</p>

<p>In this example the <code><code>sv_2mortal</code></code> call gets done under the hood by XS, because we declared the return type to be <code><code>SV*</code></code>.</p>

<p>To view the generated XS code, run the command &quot;<code><code>perl -MInline=INFO,FORCE,NOCLEAN example004.pl</code></code>&quot;. This will leave the build directory intact and tell you where to find it.</p>

</dd>
<dt id="See-Also6">See Also</dt>
<dd>

</dd>
<dt id="Credits6">Credits</dt>
<dd>

</dd>
</dl>

<h1 id="Fast-Food">Fast Food</h1>

<h2 id="Inline-CGI">Inline CGI</h2>

<dl>

<dt id="Problem7">Problem</dt>
<dd>

<p>How do I use Inline securely in a CGI environment?</p>

</dd>
<dt id="Solution7">Solution</dt>
<dd>

<pre><code><code>    <span class="comment">#!/usr/bin/perl</span>
    
    <span class="keyword">use</span> <span class="variable">CGI</span> <span class="string">qw(:standard)</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="operator">(</span><span class="string">Config</span> <span class="operator">=&gt;</span>
                <span class="string">DIRECTORY</span> <span class="operator">=&gt;</span> <span class="string">'/usr/local/apache/Inline'</span><span class="operator">,</span>
               <span class="operator">);</span>
    
    <span class="keyword">print</span> <span class="operator">(</span><span class="variable">header</span><span class="operator">,</span>
           <span class="variable">start_html</span><span class="operator">(</span><span class="string">'Inline CGI Example'</span><span class="operator">),</span>
           <span class="variable">h1</span><span class="operator">(</span><span class="variable">JAxH</span><span class="operator">(</span><span class="string">'Inline'</span><span class="operator">)),</span>
           <span class="variable">end_html</span>
          <span class="operator">);</span>
    
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">END</span><span class="operator">;</span><span class="string">
    SV* JAxH(char* x) {
        return newSVpvf("Just Another %s Hacker", x);
    }
    </span><span class="default">END</span>
</code></code></pre>

</dd>
<dt id="Discussion7">Discussion</dt>
<dd>

<p>The problem with running Inline code from a CGI script is that Inline <b>writes</b> to a build area on your disk whenever it compiles code. Most CGI scripts don&#39;t (and shouldn&#39;t) be able to create a directory and write into it.</p>

<p>The solution is to explicitly tell Inline which directory to use with the &#39;use Inline Config =&gt; DIRECTORY =&gt; ...&#39; line. Then you need to give write access to that directory from the web server (CGI script).</p>

<p>If you see this as a security hole, then there is another option. Give write access to yourself, but read-only access to the CGI script. Then run the script once by hand (from the command line). This will cause Inline to precompile the C code. That way the CGI will only need read access to the build directory (to load in the shared library from there).</p>

<p>Just remember that whenever you change the C code, you need to precompile it again.</p>

</dd>
<dt id="See-Also7">See Also</dt>
<dd>

<p>See <a href="../../../lib/CGI.html">CGI</a> for more information on using the <code><code>CGI.pm</code></code> module.</p>

</dd>
<dt id="Credits7">Credits</dt>
<dd>

</dd>
</dl>

<h2 id="mod_perl">mod_perl</h2>

<dl>

<dt id="Problem8">Problem</dt>
<dd>

<p>How do I use Inline with mod_perl?</p>

</dd>
<dt id="Solution8">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">Factorial</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">Config</span> <span class="operator">=&gt;</span>
               <span class="string">DIRECTORY</span> <span class="operator">=&gt;</span> <span class="string">'/usr/local/apache/Inline'</span><span class="operator">,</span>
               <span class="string">ENABLE</span> <span class="operator">=&gt;</span> <span class="string">'UNTAINT'</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">'C'</span><span class="operator">;</span>
    <span class="variable">Inline</span><span class="operator">-&gt;</span><span class="variable">init</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> handler </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$r</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="variable">$r</span><span class="operator">-&gt;</span><span class="variable">send_http_header</span><span class="operator">(</span><span class="string">'text/plain'</span><span class="operator">);</span>
        <span class="keyword">printf</span> <span class="string">"%3d! = %10d\n"</span><span class="operator">,</span> <span class="variable">$_</span><span class="operator">,</span> <span class="variable">factorial</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="number">1</span><span class="operator">..</span><span class="number">100</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="variable">Apache::Constants::OK</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="number">1</span><span class="operator">;</span>
    <span class="comment">__DATA__
    __C__
    double factorial(double x) {
        if (x &lt; 2)  return 1;
        return x * factorial(x - 1)
    }
    </span>
</code></code></pre>

</dd>
<dt id="Discussion8">Discussion</dt>
<dd>

<p>This is a fully functional mod_perl handler that prints out the factorial values for the numbers 1 to 100. Since we are using Inline under mod_perl, there are a few considerations to , um, consider.</p>

<p>First, mod_perl handlers are usually run with <code><code>-T</code></code> taint detection. Therefore, we need to enable the UNTAINT option. The next thing to deal with is the fact that this handler will most likely be loaded after Perl&#39;s compile time. Since we are using the DATA section, we need to use the special <code><code>init()</code></code> call. And of course we need to specify a DIRECTORY that mod_perl can compile into. <i>See the above CGI example for more info.</i></p>

<p>Other than that, this is a pretty straightforward mod_perl handler, tuned for even more speed!</p>

</dd>
<dt id="See-Also8">See Also</dt>
<dd>

<p>See Stas Bekman&#39;s upcoming O&#39;Reilly book on mod_perl to which this example was contributed.</p>

</dd>
<dt id="Credits8">Credits</dt>
<dd>

</dd>
</dl>

<h2 id="Object-Oriented-Inline">Object Oriented Inline</h2>

<dl>

<dt id="Problem9">Problem</dt>
<dd>

<p>How do I implement Object Oriented programming in Perl using C objects?</p>

</dd>
<dt id="Solution9">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$obj1</span> <span class="operator">=</span> <span class="variable">Soldier</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">'Benjamin'</span><span class="operator">,</span> <span class="string">'Private'</span><span class="operator">,</span> <span class="number">11111</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$obj2</span> <span class="operator">=</span> <span class="variable">Soldier</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">'Sanders'</span><span class="operator">,</span> <span class="string">'Colonel'</span><span class="operator">,</span> <span class="number">22222</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$obj3</span> <span class="operator">=</span> <span class="variable">Soldier</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">'Matt'</span><span class="operator">,</span> <span class="string">'Sergeant'</span><span class="operator">,</span> <span class="number">33333</span><span class="operator">);</span>
    
    <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$obj</span> <span class="operator">(</span><span class="variable">$obj1</span><span class="operator">,</span> <span class="variable">$obj2</span><span class="operator">,</span> <span class="variable">$obj3</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span>  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">get_serial</span><span class="operator">,</span> <span class="string">") "</span><span class="operator">,</span>
               <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">get_name</span><span class="operator">,</span> <span class="string">" is a "</span><span class="operator">,</span>
               <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">get_rank</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="comment">#---------------------------------------------------------</span>
    
    <span class="keyword">package</span> <span class="variable">Soldier</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'END'</span><span class="operator">;</span><span class="string">
    
    typedef struct {
      char* name;
      char* rank;
      long  serial;
      } Soldier;
    
    
    
    SV* new(char* class, char* name, char* rank, long serial) {
        Soldier* soldier;
        SV*      obj_ref = newSViv(0);
        SV*      obj = newSVrv(obj_ref, class);
    
        New(42, soldier, 1, Soldier);
    
        soldier-&gt;name = savepv(name);
        soldier-&gt;rank = savepv(rank);
        soldier-&gt;serial = serial;
    
        sv_setiv(obj, (IV)soldier);
        SvREADONLY_on(obj);
        return obj_ref;
     }
    
     char* get_name(SV* obj) {
           return ((Soldier*)SvIV(SvRV(obj)))-&gt;name;
     }
    
     char* get_rank(SV* obj) {
           return ((Soldier*)SvIV(SvRV(obj)))-&gt;rank;
     }
    
     long get_serial(SV* obj) {
          return ((Soldier*)SvIV(SvRV(obj)))-&gt;serial;
     }
    
     void DESTROY(SV* obj) {
          Soldier* soldier = (Soldier*)SvIV(SvRV(obj));
          Safefree(soldier-&gt;name);
          Safefree(soldier-&gt;rank);
          Safefree(soldier);
    }
    
    </span><span class="default">END</span>
</code></code></pre>

</dd>
<dt id="Discussion9">Discussion</dt>
<dd>

<p>Damian Conway has given us myriad ways of implementing OOP in Perl. This is one he might not have thought of.</p>

<p>The interesting thing about this example is that it uses Perl for all the OO bindings while using C for the attributes and methods.</p>

<p>If you examine the Perl code everything looks exactly like a regular OO example. There is a <code><code>new</code></code> method and several accessor methods. The familiar &#39;arrow syntax&#39; is used to invoke them.</p>

<p>In the class definition (second part) the Perl <code><code>package</code></code> statement is used to name the object class or namespace. But that&#39;s where the similarities end Inline takes over.</p>

<p>The idea is that we call a C subroutine called <code><code>new()</code></code> which returns a blessed scalar. The scalar contains a readonly integer which is a C pointer to a Soldier struct. This is our object.</p>

<p>The <code><code>new()</code></code> function needs to malloc the memory for the struct and then copy the initial values into it using <code><code>savepv()</code></code>. This also allocates more memory (which we have to keep track of).</p>

<p>Note that <code><code>newSVrv()</code></code> doesn&#39;t create a reference, but returns a new SV (&#39;obj&#39;) and makes &#39;obj_ref&#39; a reference to it. Ultimately, &#39;obj_ref&#39; (which is the SV that <code><code>new()</code></code> returns) holds a reference to the blessed scalar in &#39;obj&#39;, which in turn contains an integer that corresponds to the memory address of the C object.</p>

<p>The accessor methods are pretty straightforward. They return the current value of their attribute.</p>

<p>The last method <code><code>DESTROY()</code></code> is called automatically by Perl whenever an object goes out of scope. This is where we can free all the memory used by the object.</p>

<p>That&#39;s it. It&#39;s a very simplistic example. It doesn&#39;t show off any advanced OO features, but it is pretty cool to see how easy the implementation can be. The important Perl call is <code><code>newSVrv()</code></code> which creates a blessed scalar.</p>

</dd>
<dt id="See-Also9">See Also</dt>
<dd>

<p>Read &quot;Object Oriented Perl&quot; by Damian Conway, for more useful ways of doing OOP in Perl.</p>

<p>You can learn more Perl calls in <a href="../../../lib/pod/perlapi.html">perlapi</a>. If you don&#39;t have Perl 5.6.0 or higher, visit http://www.perldoc.com/perl5.6/pod/perlapi.html</p>

</dd>
<dt id="Credits9">Credits</dt>
<dd>

</dd>
</dl>

<h1 id="The-Main-Course">The Main Course</h1>

<h2 id="Exposing-Shared-Libraries">Exposing Shared Libraries</h2>

<dl>

<dt id="Problem10">Problem</dt>
<dd>

<p>You have this great C library and you want to be able to access parts of it with Perl.</p>

</dd>
<dt id="Solution10">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">print</span> <span class="variable">get</span><span class="operator">(</span><span class="string">'http://www.axkit.org'</span><span class="operator">);</span>
    
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">Config</span> <span class="operator">=&gt;</span>
               <span class="string">LIBS</span> <span class="operator">=&gt;</span> <span class="string">'-lghttp'</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'END_OF_C_CODE'</span><span class="operator">;</span><span class="string">
    
    #include &lt;ghttp.h&gt;
    
    char *get(SV* uri) {
       SV* buffer;
       ghttp_request* request;
    
       buffer = NEWSV(0,0);
       request = ghttp_request_new();
       ghttp_set_uri(request, SvPV(uri, PL_na));
    
       ghttp_set_header(request, http_hdr_Connection, "close");
    
       ghttp_prepare(request);
       ghttp_process(request);
    
       sv_catpv(buffer, ghttp_get_body(request));
    
       ghttp_request_destroy(request);
    
       return SvPV(buffer, PL_na);
    }
    
    </span><span class="default">END_OF_C_CODE</span>
</code></code></pre>

</dd>
<dt id="Discussion10">Discussion</dt>
<dd>

<p>This example fetches and prints the HTML from http://www.axkit.org It requires the GNOME http libraries. http://www.gnome.org</p>

<p>One of the most common questions I get is &quot;How can I use Inline to make use of some shared library?&quot;. Although it has always been possible to do so, the configuration was ugly, and there were no specific examples.</p>

<p>With version 0.30 and higher, you can specify the use of shared libraries easily with something like this:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">Config</span> <span class="operator">=&gt;</span> <span class="string">LIBS</span> <span class="operator">=&gt;</span> <span class="string">'-lghttp'</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">"code ..."</span><span class="operator">;</span>
</code></code></pre>

<p>or</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">"code ..."</span><span class="operator">,</span> <span class="string">LIBS</span> <span class="operator">=&gt;</span> <span class="string">'-lghttp'</span><span class="operator">;</span>
</code></code></pre>

<p>To specify a specific library path, use:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">"code ..."</span><span class="operator">,</span> <span class="string">LIBS</span> <span class="operator">=&gt;</span> <span class="string">'-L/your/lib/path -lyourlib'</span><span class="operator">;</span>
</code></code></pre>

<p>To specify an include path use:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">"code ..."</span><span class="operator">,</span>
               <span class="string">LIBS</span> <span class="operator">=&gt;</span> <span class="string">'-lghttp'</span><span class="operator">,</span>
               <span class="string">INC</span> <span class="operator">=&gt;</span> <span class="string">'-I/your/inc/path'</span><span class="operator">;</span>
</code></code></pre>

</dd>
<dt id="See-Also10">See Also</dt>
<dd>

<p>The <code><code>LIBS</code></code> and <code><code>INC</code></code> configuration options are formatted and passed into MakeMaker. For more info see <a href="../../../lib/ExtUtils/MakeMaker.html">ExtUtils::MakeMaker</a>. For more options see <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline/C.html">Inline::C</a>.</p>

</dd>
<dt id="Credits10">Credits</dt>
<dd>

<p>This code was written by Matt Sergeant &lt;matt@sergeant.org&gt;, author of many CPAN modules. The configuration syntax has been modified for use with Inline v0.30.</p>

</dd>
</dl>

<h2 id="Automatic-Function-Wrappers">Automatic Function Wrappers</h2>

<dl>

<dt id="Problem11">Problem</dt>
<dd>

<p>You have some functions in a C library that you want to access from Perl exactly as you would from C.</p>

</dd>
<dt id="Solution11">Solution</dt>
<dd>

<p>The error function <code><code>erf()</code></code> is probably defined in your standard math library. Annoyingly, Perl does not let you access it. To print out a small table of its values, just say:</p>

<pre><code><code>    <span class="variable">perl</span> <span class="operator">-</span><span class="keyword">le</span> <span class="string">'use Inline C =&gt; q{ double erf(double); }, ENABLE =&gt; "AUTOWRAP"; print "$_ @{[erf($_)]}" for (0..10)'</span>
</code></code></pre>

<p>The excellent <code><code>Term::ReadLine::Gnu</code></code> implements Term::ReadLine using the GNU ReadLine library. Here is an easy way to access just <code><code>readline()</code></code> from that library:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">MyTerm</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">Config</span> <span class="operator">=&gt;</span>
               <span class="string">ENABLE</span> <span class="operator">=&gt;</span> <span class="string">AUTOWRAP</span> <span class="operator">=&gt;</span>
               <span class="string">LIBS</span> <span class="operator">=&gt;</span> <span class="string">"-lreadline -lncurses -lterminfo -ltermcap "</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">q{ char * readline(char *); }</span><span class="operator">;</span>
    
    <span class="keyword">package</span> <span class="variable">main</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="variable">MyTerm::readline</span><span class="operator">(</span><span class="string">"xyz: "</span><span class="operator">);</span>
</code></code></pre>

<p>Note however that it fails to <code><code>free()</code></code> the memory returned by readline, and that <code><code>Term::ReadLine::Gnu</code></code> offers a much richer interface.</p>

</dd>
<dt id="Discussion11">Discussion</dt>
<dd>

<p>We access existing functions by merely showing Inline their declarations, rather than a full definition. Of course the function declared must exist, either in a library already linked to Perl or in a library specified using the <code><code>LIBS</code></code> option.</p>

<p>The first example wraps a function from the standard math library, so Inline requires no additional <code><code>LIBS</code></code> directive. The second uses the Config option to specify the libraries that contain the actual compiled C code.</p>

<p>This behavior is always disabled by default. You must enable the <code><code>AUTOWRAP</code></code> option to make it work.</p>

</dd>
<dt id="See-Also11">See Also</dt>
<dd>

<p><code><code>readline</code></code>, <code><code>Term::ReadLine::Gnu</code></code></p>

</dd>
<dt id="Credits11">Credits</dt>
<dd>

<p>GNU ReadLine was written by Brian Fox &lt;bfox@ai.mit.edu&gt; and Chet Ramey &lt;chet@ins.cwru.edu&gt;. Term::ReadLine::Gnu was written by Hiroo Hayashi &lt;hiroo.hayashi@computer.org&gt;. Both are far richer than the slim interface given here!</p>

<p>The idea of producing wrapper code given only a function declaration is taken from Swig by David M. Beazley &lt;beazley@cs.uchicago.edu&gt;.</p>

<p>Ingy&#39;s inline editorial insight:</p>

<p>This entire entry was contributed by Ariel Scolnicov &lt;ariels@compugen.co.il&gt;. Ariel also first suggested the idea for Inline to support function declaration processing.</p>

</dd>
</dl>

<h2 id="Complex-Data">Complex Data</h2>

<dl>

<dt id="Problem12">Problem</dt>
<dd>

<p>How do I deal with complex data types like hashes in Inline C?</p>

</dd>
<dt id="Solution12">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'END_OF_C_CODE'</span><span class="operator">;</span><span class="string">
    
    void dump_hash(SV* hash_ref) {
        HV* hash;
        HE* hash_entry;
        int num_keys, i;
        SV* sv_key;
        SV* sv_val;
    
        if (! SvROK(hash_ref))
            croak("hash_ref is not a reference");
    
        hash = (HV*)SvRV(hash_ref);
        num_keys = hv_iterinit(hash);
        for (i = 0; i &lt; num_keys; i++) {
            hash_entry = hv_iternext(hash);
            sv_key = hv_iterkeysv(hash_entry);
            sv_val = hv_iterval(hash, hash_entry);
            printf("%s =&gt; %s\n", SvPV(sv_key, PL_na), SvPV(sv_val, PL_na));
        }
        return;
    }
    
    </span><span class="default">END_OF_C_CODE</span>
    
    <span class="keyword">my</span> <span class="variable">%hash</span> <span class="operator">=</span> <span class="operator">(</span>
                <span class="string">Author</span> <span class="operator">=&gt;</span> <span class="string">"Brian Ingerson"</span><span class="operator">,</span>
                <span class="string">Nickname</span> <span class="operator">=&gt;</span> <span class="string">"INGY"</span><span class="operator">,</span>
                <span class="string">Module</span> <span class="operator">=&gt;</span> <span class="string">"Inline.pm"</span><span class="operator">,</span>
                <span class="string">Version</span> <span class="operator">=&gt;</span> <span class="string">"0.30"</span><span class="operator">,</span>
                <span class="string">Language</span> <span class="operator">=&gt;</span> <span class="string">"C"</span><span class="operator">,</span>
               <span class="operator">);</span>
    
    <span class="variable">dump_hash</span><span class="operator">(\</span><span class="variable">%hash</span><span class="operator">);</span>
</code></code></pre>

</dd>
<dt id="Discussion12">Discussion</dt>
<dd>

<p>The world is not made of scalars alone, although they are definitely the easiest creatures to deal with, when doing Inline stuff. Sometimes we need to deal with arrays, hashes, and code references, among other things.</p>

<p>Since Perl subroutine calls only pass scalars as arguments, we&#39;ll need to use the argument type <code><code>SV*</code></code> and pass references to more complex types.</p>

<p>The above program dumps the key/value pairs of a hash. To figure it out, just curl up with <a href="../../../lib/pod/perlapi.html">perlapi</a> for a couple hours. Actually, its fairly straight forward once you are familiar with the calls.</p>

<p>Note the <code><code>croak</code></code> function call. This is the proper way to die from your C extensions.</p>

</dd>
<dt id="See-Also12">See Also</dt>
<dd>

<p>See <a href="../../../lib/pod/perlapi.html">perlapi</a> for information about the Perl5 internal API.</p>

</dd>
<dt id="Credits12">Credits</dt>
<dd>

</dd>
</dl>

<h2 id="Hash-of-Lists">Hash of Lists</h2>

<dl>

<dt id="Problem13">Problem</dt>
<dd>

<p>How do I create a Hash of Lists from C?</p>

</dd>
<dt id="Solution13">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="variable">C</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Data::Dumper</span><span class="operator">;</span>
    
    <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">load_data</span><span class="operator">(</span><span class="string">"./cartoon.txt"</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="variable">Dumper</span> <span class="variable">$hash_ref</span><span class="operator">;</span>
    
    <span class="comment">__END__
    __C__
    
    static int next_word(char**, char*);
    
    SV* load_data(char* file_name) {
        char buffer[100], word[100], * pos;
        AV* array;
        HV* hash = newHV();
        FILE* fh = fopen(file_name, "r");
    
        while (fgets(pos = buffer, sizeof(buffer), fh)) {
            if (next_word(&amp;pos, word)) {
                hv_store(hash, word, strlen(word),
                        newRV_noinc((SV*)array = newAV()), 0);
                while (next_word(&amp;pos, word))
                    av_push(array, newSVpvf("%s", word));
            }
        }
        fclose(fh);
        return newRV_noinc((SV*) hash);
    }
    
    static int next_word(char** text_ptr, char* word) {
        char* text = *text_ptr;
        while(*text != '\0' &amp;&amp;
              *text &lt;= ' ')
            text++;
        if (*text &lt;= ' ')
            return 0;
        while(*text != '\0' &amp;&amp;
              *text &gt; ' ') {
            *word++ = *text++;
        }
        *word = '\0';
        *text_ptr = text;
        return 1;
    }
    </span>
</code></code></pre>

</dd>
<dt id="Discussion13">Discussion</dt>
<dd>

<p>This is one of the larger recipes. But when you consider the number of calories it has, it&#39;s not so bad. The function <code><code>load_data</code></code> takes the name of a file as it&#39;s input. The file <code><code>cartoon.text</code></code> might look like:</p>

<pre><code><code>    flintstones fred barney
    jetsons     george jane elroy
    simpsons    homer marge bart</code></code></pre>

<p>The function will read the file, parsing each line into words. Then it will create a new hash, whereby the first word in a line becomes a hash key and the remaining words are put into an array whose reference becomes the hash value. The output looks like this:</p>

<pre><code><code>    <span class="variable">$VAR1</span> <span class="operator">=</span> <span class="operator">{</span>
              <span class="string">'flintstones'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
                                 <span class="string">'fred'</span><span class="operator">,</span>
                                 <span class="string">'barney'</span>
                               <span class="operator">]</span><span class="operator">,</span>
              <span class="string">'simpsons'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
                              <span class="string">'homer'</span><span class="operator">,</span>
                              <span class="string">'marge'</span><span class="operator">,</span>
                              <span class="string">'bart'</span>
                            <span class="operator">]</span><span class="operator">,</span>
              <span class="string">'jetsons'</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
                             <span class="string">'george'</span><span class="operator">,</span>
                             <span class="string">'jane'</span><span class="operator">,</span>
                             <span class="string">'elroy'</span>
                           <span class="operator">]</span>
            <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

</dd>
<dt id="See-Also13">See Also</dt>
<dd>

<p>See <a href="../../../lib/pod/perlapi.html">perlapi</a> for information about the Perl5 internal API.</p>

</dd>
<dt id="Credits13">Credits</dt>
<dd>

<p>Al Danial &lt;alnd@pacbell.net&gt; requested a solution to this on comp.lang.perl.misc. He borrowed the idea from the &quot;Hash of Lists&quot; example in the Camel book.</p>

</dd>
</dl>

<h1 id="Just-Desserts">Just Desserts</h1>

<h2 id="Win32">Win32</h2>

<dl>

<dt id="Problem14">Problem</dt>
<dd>

<p>How do I access Win32 DLL-s using Inline?</p>

</dd>
<dt id="Solution14">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">DATA</span> <span class="operator">=&gt;</span>
               <span class="string">LIBS</span> <span class="operator">=&gt;</span> <span class="string">'-luser32'</span><span class="operator">;</span>
    
    <span class="variable">$text</span> <span class="operator">=</span> <span class="string">"</span><span class="variable">@ARGV</span><span class="string">"</span> <span class="operator">||</span> <span class="string">'Inline.pm works with MSWin32. Scary...'</span><span class="operator">;</span>
    
    <span class="variable">WinBox</span><span class="operator">(</span><span class="string">'Inline Text Box'</span><span class="operator">,</span> <span class="variable">$text</span><span class="operator">);</span>
    
    <span class="comment">__END__
    __C__
    
    #include &lt;windows.h&gt;
    
    int WinBox(char* Caption, char* Text) {
      return MessageBoxA(0, Text, Caption, 0);
    }
    </span>
</code></code></pre>

</dd>
<dt id="Discussion14">Discussion</dt>
<dd>

<p>This example runs on MS Windows. It makes a text box appear on the screen which contains a message of your choice.</p>

<p>The important thing is that its proof that you can use Inline to interact with Windows DLL-s. Very scary indeed. 8-o</p>

<p>To use Inline on Windows with ActivePerl ( http://www.ActiveState.com ) you&#39;ll need MS Visual Studio. You can also use the Cygwin environment, available at http://www.cygwin.com .</p>

</dd>
<dt id="See-Also14">See Also</dt>
<dd>

<p>See <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline-Support.html">Inline-Support</a> for more info on MSWin32 programming with Inline.</p>

</dd>
<dt id="Credits14">Credits</dt>
<dd>

<p>This example was adapted from some sample code written by Garrett Goebel &lt;garrett@scriptpro.com&gt;</p>

</dd>
</dl>

<h2 id="Embedding-Perl-in-C">Embedding Perl in C</h2>

<dl>

<dt id="Problem15">Problem</dt>
<dd>

<p>How do I use Perl from a regular C program?</p>

</dd>
<dt id="Solution15">Solution</dt>
<dd>

<pre><code><code>    <span class="comment">#!/usr/bin/cpr</span>
    
    <span class="keyword">int</span> <span class="variable">main</span><span class="operator">(</span><span class="variable">void</span><span class="operator">)</span> <span class="operator">{</span>
    
        <span class="keyword">printf</span><span class="operator">(</span><span class="string">"Using Perl version %s from a C program!\n\n"</span><span class="operator">,</span>
               <span class="variable">CPR_eval</span><span class="operator">(</span><span class="string">"use Config; </span><span class="variable">$Config</span><span class="string">{version};"</span><span class="operator">));</span>
    
        <span class="variable">CPR_eval</span><span class="operator">(</span><span class="string">"use Data::Dumper;"</span><span class="operator">);</span>
        <span class="variable">CPR_eval</span><span class="operator">(</span><span class="string">"print Dumper \\%INC;"</span><span class="operator">);</span>
    
        <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
    
    <span class="operator">}</span>
</code></code></pre>

</dd>
<dt id="Discussion15">Discussion</dt>
<dd>

<p>By using CPR. (C Perl Run)</p>

<p>This example uses another Inline module, <code><code>Inline::CPR</code></code>, available separately on CPAN. When you install this module it also installs a binary interpreter called <code><code>/usr/bin/cpr</code></code>. (The path may be different on your system)</p>

<p>When you feed a C program to the CPR interpreter, it automatically compiles and runs your code using Inline. This gives you full access to the Perl internals. CPR also provides a set of easy to use C macros for calling Perl internals.</p>

<p>This means that you can effectively &quot;run&quot; C source code by putting a CPR hashbang as the first line of your C program.</p>

</dd>
<dt id="See-Also15">See Also</dt>
<dd>

<p>See <a>Inline::CPR</a> for more information on using CPR.</p>

<p><code><code>Inline::CPR</code></code> can be obtained from http://search.cpan.org/search?dist=Inline-CPR</p>

</dd>
<dt id="Credits15">Credits</dt>
<dd>

<p>Randal Schwartz &lt;merlyn@stonehenge.com&gt;, Randolph Bentson &lt;bentson@grieg.holmsjoen.com&gt;, Richard Anderson &lt;starfire@zipcon.net&gt;, and Tim Maher &lt;tim@consultix-inc.com&gt; helped me figure out how to write a program that would work as a hashbang.</p>

</dd>
</dl>

<h1 id="Entertaining-Guests">Entertaining Guests</h1>

<p>As of version 0.30, Inline has the ability to work in cooperation with other modules that want to expose a C API of their own. The general syntax for doing this is:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">with</span> <span class="operator">=&gt;</span> <span class="string">'Module'</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">...</span> <span class="operator">;</span>
</code></code></pre>

<p>This tells <code><code>Module</code></code> to pass configuration options to Inline. Options like typemaps, include paths, and external libraries, are all resolved automatically so you can just concentrate on writing the functions.</p>

<h2 id="Event-handling-with-Event.pm">Event handling with Event.pm</h2>

<dl>

<dt id="Problem16">Problem</dt>
<dd>

<p>You need to write a C callback for the <code><code>Event.pm</code></code> module. Can this be done more easily with Inline?</p>

</dd>
<dt id="Solution16">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">with</span> <span class="operator">=&gt;</span> <span class="string">'Event'</span><span class="operator">;</span>
    
    <span class="variable">Event</span><span class="operator">-&gt;</span><span class="variable">timer</span><span class="operator">(</span><span class="string">desc</span>     <span class="operator">=&gt;</span> <span class="string">'Timer #1'</span><span class="operator">,</span>
                 <span class="string">interval</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">,</span>
                 <span class="string">cb</span>       <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">my_callback</span><span class="operator">,</span>
                <span class="operator">);</span>
    
    <span class="variable">Event</span><span class="operator">-&gt;</span><span class="variable">timer</span><span class="operator">(</span><span class="string">desc</span>     <span class="operator">=&gt;</span> <span class="string">'Timer #2'</span><span class="operator">,</span>
                 <span class="string">interval</span> <span class="operator">=&gt;</span> <span class="number">3</span><span class="operator">,</span>
                 <span class="string">cb</span>       <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">my_callback</span><span class="operator">,</span>
                <span class="operator">);</span>
    
    <span class="keyword">print</span> <span class="string">"Starting...\n"</span><span class="operator">;</span>
    <span class="variable">Event::loop</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'END'</span><span class="operator">;</span><span class="string">
    void my_callback(pe_event* event) {
        pe_timer * watcher = event-&gt;up;
    
        printf("%s\n\tEvent priority = %d\n\tWatcher priority = %d\n\n",
               SvPVX(watcher-&gt;base.desc),
               event-&gt;prio,
               watcher-&gt;base.prio
              );
    }
    </span><span class="default">END</span>
</code></code></pre>

</dd>
<dt id="Discussion16">Discussion</dt>
<dd>

<p>The first line tells Inline to load the <code><code>Event.pm</code></code> module. Inline then queries <code><code>Event</code></code> for configuration information. It gets the name and location of Event&#39;s header files, typemaps and shared objects. The parameters that <code><code>Event</code></code> returns look like:</p>

<pre><code><code>    <span class="string">INC</span> <span class="operator">=&gt;</span> <span class="string">"-I </span><span class="variable">$path</span><span class="string">/Event"</span><span class="operator">,</span>
    <span class="string">TYPEMAPS</span> <span class="operator">=&gt;</span> <span class="string">"</span><span class="variable">$path</span><span class="string">/Event/typemap"</span><span class="operator">,</span>
    <span class="string">MYEXTLIB</span> <span class="operator">=&gt;</span> <span class="string">"</span><span class="variable">$path</span><span class="string">/auto/Event/Event.</span><span class="variable">$so</span><span class="string">"</span><span class="operator">,</span>
    <span class="string">AUTO_INCLUDE</span> <span class="operator">=&gt;</span> <span class="string">'#include "EventAPI.h"'</span><span class="operator">,</span>
    <span class="string">BOOT</span> <span class="operator">=&gt;</span> <span class="string">'I_EVENT_API("Inline");'</span><span class="operator">,</span>
</code></code></pre>

<p>Doing all of this automatically allows you, the programmer, to simply write a function that receives a pointer of type <code><code>&#39;pe_event*&#39;</code></code>. This gives you access to the <code><code>Event</code></code> structure that was passed to you.</p>

<p>In this example, I simply print values out of the structure. The Perl code defines 2 timer events which each invoke the same callback. The first one, every two seconds, and the second one, every three seconds.</p>

<p>As of this writing, <code><code>Event.pm</code></code> is the only CPAN module that works in cooperation with Inline.</p>

</dd>
<dt id="See-Also16">See Also</dt>
<dd>

<p>Read the <code><code>Event.pm</code></code> documentation for more information. It contains a tutorial showing several examples of using Inline with <code><code>Event</code></code>.</p>

</dd>
<dt id="Credits16">Credits</dt>
<dd>

<p>Jochen Stenzel &lt;perl@jochen-stenzel.de&gt; originally came up with the idea of mixing Inline and <code><code>Event</code></code>. He also authored the <code><code>Event</code></code> tutorial.</p>

<p>Joshua Pritikin &lt;joshua.pritikin@db.com&gt; is the author of <code><code>Event.pm</code></code>.</p>

</dd>
</dl>

<h1 id="Food-for-Thought">Food for Thought</h1>

<h2 id="Calling-C-from-both-Perl-and-C">Calling C from both Perl and C</h2>

<dl>

<dt id="Problem17">Problem</dt>
<dd>

<p>I&#39;d like to be able to call the same C function from both Perl and C. Also I like to define a C function that <b>doesn&#39;t</b> get bound to Perl. How do I do that?</p>

</dd>
<dt id="Solution17">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">print</span> <span class="string">"9 + 5 = "</span><span class="operator">,</span> <span class="variable">add</span><span class="operator">(</span><span class="number">9</span><span class="operator">,</span> <span class="number">5</span><span class="operator">),</span> <span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"SQRT(9^2 + 5^2) = "</span><span class="operator">,</span> <span class="variable">pyth</span><span class="operator">(</span><span class="number">9</span><span class="operator">,</span> <span class="number">5</span><span class="operator">),</span> <span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"9 * 5 = "</span><span class="operator">,</span> <span class="variable">mult</span><span class="operator">(</span><span class="number">9</span><span class="operator">,</span> <span class="number">5</span><span class="operator">),</span> <span class="string">"\n"</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'END_C'</span><span class="operator">;</span><span class="string">
    int add(int x, int y) {
        return x + y;
    }
    static int mult(int x, int y) {
        return x * y;
    }
    double pyth(int x, int y) {
        return sqrt(add(mult(x, x), mult(y, y)));
    }
    </span><span class="default">END_C</span>
</code></code></pre>

</dd>
<dt id="Discussion17">Discussion</dt>
<dd>

<p>The program produces:</p>

<pre><code><code>    9 + 5 = 14
    SQRT(9^2 + 5^2) = 10.295630140987
    Can&#39;t locate auto/main/mult.al in @INC ...</code></code></pre>

<p>Every Inline function that is bound to Perl is also callable by C. You don&#39;t have to do anything special. Inline arranges it so that all the typemap code gets done by XS and is out of sight. By the time the C function receives control, everything has been converted from Perl to C.</p>

<p>Of course if your function manipulates the Perl Stack, you probably don&#39;t want to call it from C (unless you <i>really</i> know what you&#39;re doing).</p>

<p>If you declare a function as <code><code>static</code></code>, Inline won&#39;t bind it to Perl. That&#39;s why we were able to call <code><code>mult()</code></code> from C but the call failed from Perl.</p>

</dd>
<dt id="See-Also17">See Also</dt>
<dd>

</dd>
<dt id="Credits17">Credits</dt>
<dd>

</dd>
</dl>

<h2 id="Calling-Perl-from-C">Calling Perl from C</h2>

<dl>

<dt id="Problem18">Problem</dt>
<dd>

<p>So now that I can call C from Perl, how do I call a Perl subroutine from an Inline C function.</p>

</dd>
<dt id="Solution18">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span> <span class="variable">C</span><span class="operator">;</span>
    
    <span class="keyword">for</span><span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">5</span><span class="operator">)</span> <span class="operator">{</span>
       <span class="variable">c_func_1</span><span class="operator">(</span><span class="string">'This is the first line'</span><span class="operator">);</span>
       <span class="variable">c_func_2</span><span class="operator">(</span><span class="string">'This is the second line'</span><span class="operator">);</span>
       <span class="keyword">print</span> <span class="string">"\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> perl_sub_1 </span><span class="operator">{</span>
        <span class="keyword">print</span> <span class="keyword">map</span> <span class="string">"</span><span class="variable">$_</span><span class="string">\n"</span><span class="operator">,</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="comment">__DATA__
    __C__
    
    void c_func_2(SV* text) {
         dSP;
    
         ENTER;
         SAVETMPS;
    
         XPUSHs(sv_2mortal(newSVpvf("Plus an extra line")));
         PUTBACK;
    
         call_pv("perl_sub_1", G_DISCARD);
    
         FREETMPS;
         LEAVE;
    }
    
    void c_func_1(SV* text) {
         c_func_2(text);
    }
    </span>
</code></code></pre>

</dd>
<dt id="Discussion18">Discussion</dt>
<dd>

<p>This demo previously made use of Inline Stack macros only - but that&#39;s not the correct way to do it. Instead, base the callbacks on the perlcall documentation (as we&#39;re now doing).</p>

<p>Actually, this program demonstrates calling a C function which calls another C function which in turn calls a Perl subroutine.</p>

<p>The nice thing about Inline C functions is that you can call them from both Perl-space <b>and</b> C-space. That&#39;s because Inline creates a wrapper function around each C function. When you use Perl to call C you&#39;re actually calling that function&#39;s wrapper. The wrapper handles typemapping and Stack management, and then calls your C function.</p>

<p>The first time we call <code><code>c_func_1</code></code> which calls <code><code>c_func_2</code></code>. The second time we call <code><code>c_func_2</code></code> directly. <code><code>c_func_2</code></code> calls the Perl subroutine (<code><code>perl_sub_1</code></code>) using the internal <code><code>perl_call_pv</code></code> function. It has to put arguments on the stack by hand. Since there is already one argument on the stack when we enter the function, the <code><code>XPUSHs</code></code> ( which is equivalent to an <code><code>Inline_Stack_Push</code></code> ) adds a second argument.</p>

<p>We iterate through a &#39;for&#39; loop 5 times just to demonstrate that things still work correctly when we do that. (This was where the previous rendition, making use solely of Inline Stack macros, fell down.)</p>

</dd>
<dt id="See-Also18">See Also</dt>
<dd>

<p>See <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline/C.html">Inline::C</a> for more information about Stack macros.</p>

<p>See <a href="../../../lib/pod/perlapi.html">perlapi</a> for more information about the Perl5 internal API.</p>

</dd>
<dt id="Credits18">Credits</dt>
<dd>

</dd>
</dl>

<h2 id="Evaling-C">Evaling C</h2>

<dl>

<dt id="Problem19">Problem</dt>
<dd>

<p>I&#39;ve totally lost my marbles and I want to generate C code at run time, and <code><code>eval</code></code> it into Perl. How do I do this?</p>

</dd>
<dt id="Solution19">Solution</dt>
<dd>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Inline</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Code::Generator</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$c_code</span> <span class="operator">=</span> <span class="variable">generate</span><span class="operator">(</span><span class="string">'foo_function'</span><span class="operator">);</span>
    
    <span class="variable">Inline</span><span class="operator">-&gt;</span><span class="variable">bind</span><span class="operator">(</span><span class="string">C</span> <span class="operator">=&gt;</span> <span class="variable">$c_code</span><span class="operator">);</span>
    
    <span class="variable">foo_function</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">);</span>
</code></code></pre>

</dd>
<dt id="Discussion19">Discussion</dt>
<dd>

<p>I can&#39;t think of a real life application where you would want to generate C code on the fly, but at least I know how I would do it. :)</p>

<p>The <code><code>bind()</code></code> function of Inline let&#39;s you bind (compile/load/execute) C functions at run time. It takes all of the same arguments as &#39;use Inline C =&gt; ...&#39;.</p>

<p>The nice thing is that once a particular snippet is compiled, it remains cached so that it doesn&#39;t need to be compiled again. I can imagine that someday a mad scientist will dream up a self generating modeling system that would run faster and faster over time.</p>

<p>If you know such a person, have them drop me a line.</p>

</dd>
<dt id="See-Also19">See Also</dt>
<dd>

</dd>
<dt id="Credits19">Credits</dt>
<dd>

</dd>
</dl>

<h2 id="Providing-a-pure-perl-alternative">Providing a pure perl alternative</h2>

<dl>

<dt id="Problem20">Problem</dt>
<dd>

<p>I want to write a script that will use a C subroutine if Inline::C is installed, but will otherwise use an equivalent pure perl subroutine if Inline::C is not already installed. How do I do this?</p>

</dd>
<dt id="Solution20">Solution</dt>
<dd>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
   <span class="keyword">use</span> <span class="variable">warnings</span><span class="operator">;</span>
  
  <span class="keyword">eval</span> <span class="operator">{</span>
   <span class="keyword">require</span> <span class="variable">Inline</span><span class="operator">;</span>
   <span class="variable">Inline</span><span class="operator">-&gt;</span><span class="variable">import</span> <span class="operator">(</span><span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">Config</span> <span class="operator">=&gt;</span>
                   <span class="string">BUILD_NOISY</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">);</span>
   <span class="variable">Inline</span><span class="operator">-&gt;</span><span class="variable">import</span> <span class="operator">(</span><span class="string">C</span> <span class="operator">=&gt;&lt;&lt;</span><span class="default">'EOC'</span><span class="operator">);</span><span class="string">
  
   int foo() {
     warn("Using Inline\n");
     return 42;
   }
  
  </span><span class="default">EOC</span>
  <span class="operator">};</span>
  
  <span class="keyword">if</span><span class="operator">(</span><span class="variable">$@</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">*foo</span> <span class="operator">=\&amp;</span><span class="variable">bar</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="keyword">sub</span><span class="variable"> bar </span><span class="operator">{</span>
    <span class="keyword">warn</span><span class="operator">(</span><span class="string">"Using Pure Perl Implementation\n"</span><span class="operator">);</span>
    <span class="keyword">return</span> <span class="number">42</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="variable">foo</span><span class="operator">();</span>
  <span class="keyword">print</span> <span class="string">"</span><span class="variable">$x</span><span class="string">\n"</span><span class="operator">;</span>
</code></code></pre>

</dd>
<dt id="Discussion20">Discussion</dt>
<dd>

<p>If Inline::C is installed and functioning properly, the C sub foo is called by the perl code. Otherwise, $@ gets set, and the equivalent pure perl function bar is instead called.</p>

<p>Note, too, that the pure perl sub bar can still be explicitly called even if Inline::C is available.</p>

</dd>
</dl>

<h2 id="Accessing-Fortran-subs-using-Inline::C">Accessing Fortran subs using Inline::C</h2>

<dl>

<dt id="Problem21">Problem</dt>
<dd>

<p>I&#39;ve been given a neat little sub written in fortran that takes, as its args, two integers and returns their product. And I would like to use that sub as is from Inline::C. By way of example, let&#39;s say that the fortran source file is named &#39;prod.f&#39;, and that it looks like this:</p>

<pre><code><code>      integer function sqarea(r,s)
      integer r, s
      sqarea = r*s
      return
      end</code></code></pre>

</dd>
<dt id="Solution21">Solution</dt>
<dd>

<p>We can&#39;t access that code directly, but we can compile it into a library which we *can* then access from Inline::C. Using gcc we could run:</p>

<pre><code><code>  gfortran -c prod.f -o prod.o
  ar cru libprod.a prod.o</code></code></pre>

<p>The function is then accessible as follows:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">warnings</span><span class="operator">;</span>
  
  <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="string">Config</span> <span class="operator">=&gt;</span>
    <span class="string">LIBS</span> <span class="operator">=&gt;</span>
     <span class="string">'-L/full/path/to/libprod_location -lprod -lgfortran'</span><span class="operator">;</span>
  
  <span class="keyword">use</span> <span class="variable">Inline</span> <span class="string">C</span> <span class="operator">=&gt;</span> <span class="operator">&lt;&lt;</span><span class="default">'  EOC'</span><span class="operator">;</span><span class="string">
  
  int wrap_sqarea(int a, int b) {
      return sqarea_(&amp;a, &amp;b);
  }
  
  EOC
  
  $x = 15;
  $y = $x + 3;
  $ret = wrap_sqarea($x, $y);
  print "Product of $x and $y is $ret\n";
  </span>
</code></code></pre>

</dd>
<dt id="Discussion21">Discussion</dt>
<dd>

<p>Note firstly that, although the function is specified as &#39;sqarea&#39; in the source file, gfortran appends an underscore to the name when the source is compiled. (I don&#39;t know if *all* fortran compilers do this.) Therefore Inline::C needs to call the function as &#39;sqarea_&#39;.</p>

<p>Secondly, because fortran subs pass args by reference, we need to pass the *addresses* of the two integer args to sqarea() when we call it from our Inline::C sub.</p>

<p>If using g77 instead of gfortran, the only necessary change is that we specify &#39;-lg2c&#39; instead of &#39;-lgfortran&#39; in our &#39;LIBS&#39; setting.</p>

</dd>
</dl>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>For generic information about Inline, see <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline.html">Inline</a>.</p>

<p>For information about using Inline with C see <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline/C.html">Inline::C</a>.</p>

<p>For information on supported languages and platforms see <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline-Support.html">Inline-Support</a>.</p>

<p>For information on writing your own Inline language support module, see <a href="../../../../.cpan/build/Inline-0.53-96IrIa/blib/lib/Inline-API.html">Inline-API</a>.</p>

<p>Inline&#39;s mailing list is inline@perl.org</p>

<p>To subscribe, send email to inline-subscribe@perl.org</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Brian Ingerson &lt;INGY@cpan.org&gt;</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 2001, 2002. Brian Ingerson.</p>

<p>Copyright (c) 2008, 2010-2013. Sisyphus.</p>

<p>All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the terms of the Perl Artistic License.</p>

<p>See http://www.perl.com/perl/misc/Artistic.html</p>


</body>

</html>


