<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a>
    <ul>
      <li><a href="#Operator-overloads">Operator overloads</a></li>
    </ul>
  </li>
  <li><a href="#EXPORTS">EXPORTS</a>
    <ul>
      <li><a href="#"></a></li>
      <li><a href="#1"></a></li>
    </ul>
  </li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#SPANS">SPANS</a>
    <ul>
      <li><a href="#Finite-forms">Finite forms</a></li>
      <li><a href="#Infinite-forms">Infinite forms</a></li>
    </ul>
  </li>
  <li><a href="#SET-SPECIFICATIONS">SET SPECIFICATIONS</a>
    <ul>
      <li><a href="#Empty">Empty</a></li>
      <li><a href="#Object-reference">Object reference</a></li>
      <li><a href="#Run-list">Run list</a>
        <ul>
          <li><a href="#Finite-forms1">Finite forms</a></li>
          <li><a href="#Infinite-forms1">Infinite forms</a></li>
          <li><a href="#Empty-forms">Empty forms</a></li>
          <li><a href="#Restrictions">Restrictions</a></li>
          <li><a href="#Examples">Examples</a></li>
        </ul>
      </li>
      <li><a href="#Array-reference">Array reference</a>
        <ul>
          <li><a href="#Examples1">Examples</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#ITERATORS">ITERATORS</a></li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#Creation">Creation</a></li>
      <li><a href="#Set-operations">Set operations</a></li>
      <li><a href="#Mutators">Mutators</a></li>
      <li><a href="#Comparison">Comparison</a></li>
      <li><a href="#Cardinality">Cardinality</a></li>
      <li><a href="#Membership">Membership</a></li>
      <li><a href="#Extrema">Extrema</a></li>
      <li><a href="#Spans">Spans</a></li>
      <li><a href="#Iterators">Iterators</a></li>
      <li><a href="#Indexing">Indexing</a></li>
    </ul>
  </li>
  <li><a href="#OPERATOR-OVERLOADS">OPERATOR OVERLOADS</a>
    <ul>
      <li><a href="#set-operations">set operations</a></li>
      <li><a href="#equality">equality</a></li>
      <li><a href="#equivalence">equivalence</a></li>
      <li><a href="#conversion">conversion</a></li>
    </ul>
  </li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a></li>
  <li><a href="#CLASS-VARIABLES">CLASS VARIABLES</a></li>
  <li><a href="#DIAGNOSTICS">DIAGNOSTICS</a></li>
  <li><a href="#NOTES">NOTES</a>
    <ul>
      <li><a href="#Traps">Traps</a></li>
      <li><a href="#grep_set-and-map_set">grep_set and map_set</a></li>
      <li><a href="#Error-handling">Error handling</a></li>
      <li><a href="#Limitations">Limitations</a></li>
      <li><a href="#Extensions">Extensions</a></li>
      <li><a href="#Roots">Roots</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Set::IntSpan - Manages sets of integers</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>  <span class="comment"># BEGIN { $Set::IntSpan::integer = 1 }</span>
  <span class="keyword">use</span> <span class="variable">Set::IntSpan</span> <span class="string">qw(grep_set map_set grep_spans map_spans)</span><span class="operator">;</span>
  
  <span class="comment"># $Set::IntSpan::Empty_String = '-';   # or '';</span>
  
  <span class="variable">$set</span>    <span class="operator">=</span> <span class="variable">new</span>   <span class="variable">Set::IntSpan</span> <span class="variable">$set_spec</span><span class="operator">;</span>
  <span class="variable">$set</span>    <span class="operator">=</span> <span class="variable">new</span>   <span class="variable">Set::IntSpan</span> <span class="variable">@set_specs</span><span class="operator">;</span>
  <span class="variable">$valid</span>  <span class="operator">=</span> <span class="variable">valid</span> <span class="variable">Set::IntSpan</span> <span class="variable">$run_list</span><span class="operator">;</span>
  <span class="variable">$set</span>    <span class="operator">=</span> <span class="variable">copy</span>  <span class="variable">$set</span> <span class="variable">$set_spec</span><span class="operator">;</span>
  
  <span class="variable">$run_list</span> <span class="operator">=</span> <span class="variable">run_list</span> <span class="variable">$set</span><span class="operator">;</span>
  <span class="variable">@elements</span> <span class="operator">=</span> <span class="variable">elements</span> <span class="variable">$set</span><span class="operator">;</span>
  <span class="variable">@sets</span>     <span class="operator">=</span> <span class="variable">sets</span>     <span class="variable">$set</span><span class="operator">;</span>
  <span class="variable">@spans</span>    <span class="operator">=</span> <span class="variable">spans</span>    <span class="variable">$set</span><span class="operator">;</span>
  
  <span class="variable">$u_set</span> <span class="operator">=</span> <span class="variable">union</span>      <span class="variable">$set</span> <span class="variable">$set_spec</span><span class="operator">;</span>
  <span class="variable">$i_set</span> <span class="operator">=</span> <span class="variable">intersect</span>  <span class="variable">$set</span> <span class="variable">$set_spec</span><span class="operator">;</span>
  <span class="variable">$x_set</span> <span class="operator">=</span> <span class="keyword">xor</span>        <span class="variable">$set</span> <span class="variable">$set_spec</span><span class="operator">;</span>
  <span class="variable">$d_set</span> <span class="operator">=</span> <span class="variable">diff</span>       <span class="variable">$set</span> <span class="variable">$set_spec</span><span class="operator">;</span>
  <span class="variable">$c_set</span> <span class="operator">=</span> <span class="variable">complement</span> <span class="variable">$set</span><span class="operator">;</span>
  
  <span class="variable">$set</span><span class="operator">-&gt;</span>U<span class="operator">(</span><span class="variable">$set_spec</span><span class="operator">);</span>   <span class="comment"># Union</span>
  <span class="variable">$set</span><span class="operator">-&gt;</span>I<span class="operator">(</span><span class="variable">$set_spec</span><span class="operator">);</span>   <span class="comment"># Intersect</span>
  <span class="variable">$set</span><span class="operator">-&gt;</span>X<span class="operator">(</span><span class="variable">$set_spec</span><span class="operator">);</span>   <span class="comment"># Xor</span>
  <span class="variable">$set</span><span class="operator">-&gt;</span>D<span class="operator">(</span><span class="variable">$set_spec</span><span class="operator">);</span>   <span class="comment"># Diff</span>
  <span class="variable">$set</span><span class="operator">-&gt;</span>C<span class="operator">;</span>              <span class="comment"># Complement</span>
  
  <span class="variable">equal</span>      <span class="variable">$set</span> <span class="variable">$set_spec</span>
  <span class="variable">equivalent</span> <span class="variable">$set</span> <span class="variable">$set_spec</span>
  <span class="variable">superset</span>   <span class="variable">$set</span> <span class="variable">$set_spec</span>
  <span class="variable">subset</span>     <span class="variable">$set</span> <span class="variable">$set_spec</span>
  
  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">cardinality</span> <span class="variable">$set</span><span class="operator">;</span>
  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">size</span>        <span class="variable">$set</span><span class="operator">;</span>
  
  <span class="variable">empty</span>      <span class="variable">$set</span>
  <span class="variable">finite</span>     <span class="variable">$set</span>
  <span class="variable">neg_inf</span>    <span class="variable">$set</span>
  <span class="variable">pos_inf</span>    <span class="variable">$set</span>
  <span class="variable">infinite</span>   <span class="variable">$set</span>
  <span class="variable">universal</span>  <span class="variable">$set</span>
  
  <span class="variable">member</span>     <span class="variable">$set</span> <span class="variable">$n</span><span class="operator">;</span>
  <span class="variable">insert</span>     <span class="variable">$set</span> <span class="variable">$n</span><span class="operator">;</span>
  <span class="variable">remove</span>     <span class="variable">$set</span> <span class="variable">$n</span><span class="operator">;</span>
  
  <span class="variable">$min</span> <span class="operator">=</span> <span class="variable">min</span> <span class="variable">$set</span><span class="operator">;</span>
  <span class="variable">$max</span> <span class="operator">=</span> <span class="variable">max</span> <span class="variable">$set</span><span class="operator">;</span>
  
  <span class="variable">$holes</span>   <span class="operator">=</span> <span class="variable">holes</span> <span class="variable">$set</span><span class="operator">;</span>
  <span class="variable">$cover</span>   <span class="operator">=</span> <span class="variable">cover</span> <span class="variable">$set</span><span class="operator">;</span>
  <span class="variable">$inset</span>   <span class="operator">=</span> <span class="variable">inset</span> <span class="variable">$set</span> <span class="variable">$n</span><span class="operator">;</span>
  <span class="variable">$smaller</span> <span class="operator">=</span> <span class="variable">trim</span>  <span class="variable">$set</span> <span class="variable">$n</span><span class="operator">;</span>
  <span class="variable">$bigger</span>  <span class="operator">=</span> <span class="variable">pad</span>   <span class="variable">$set</span> <span class="variable">$n</span><span class="operator">;</span>
  
  <span class="variable">$subset</span>  <span class="operator">=</span> <span class="variable">grep_set</span>   <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span> <span class="variable">$set</span><span class="operator">;</span>
  <span class="variable">$mapset</span>  <span class="operator">=</span> <span class="variable">map_set</span>    <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span> <span class="variable">$set</span><span class="operator">;</span>
  
  <span class="variable">$subset</span>  <span class="operator">=</span> <span class="variable">grep_spans</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span> <span class="variable">$set</span><span class="operator">;</span>
  <span class="variable">$mapset</span>  <span class="operator">=</span> <span class="variable">map_spans</span>  <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span> <span class="variable">$set</span><span class="operator">;</span>
  
  <span class="keyword">for</span> <span class="operator">(</span><span class="variable">$element</span><span class="operator">=</span><span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">first</span><span class="operator">;</span> <span class="keyword">defined</span> <span class="variable">$element</span><span class="operator">;</span> <span class="variable">$element</span><span class="operator">=</span><span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">next</span><span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
  <span class="keyword">for</span> <span class="operator">(</span><span class="variable">$element</span><span class="operator">=</span><span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">last</span> <span class="operator">;</span> <span class="keyword">defined</span> <span class="variable">$element</span><span class="operator">;</span> <span class="variable">$element</span><span class="operator">=</span><span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">prev</span><span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
  
  <span class="variable">$element</span> <span class="operator">=</span> <span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">start</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="variable">$element</span> <span class="operator">=</span> <span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">current</span><span class="operator">;</span>
  
  <span class="variable">$n</span>       <span class="operator">=</span> <span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">at</span><span class="operator">(</span><span class="variable">$i</span><span class="operator">);</span>
  <span class="variable">$slice</span>   <span class="operator">=</span> <span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">slice</span><span class="operator">(</span><span class="variable">$from</span><span class="operator">,</span> <span class="variable">$to</span><span class="operator">);</span>
  <span class="variable">$i</span>       <span class="operator">=</span> <span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">ord</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="variable">$i</span>       <span class="operator">=</span> <span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">span_ord</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></code></pre>

<h2 id="Operator-overloads">Operator overloads</h2>

<pre><code><code>  <span class="variable">$u_set</span> <span class="operator">=</span>  <span class="variable">$set</span> <span class="operator">+</span> <span class="variable">$set_spec</span><span class="operator">;</span>   <span class="comment"># union</span>
  <span class="variable">$i_set</span> <span class="operator">=</span>  <span class="variable">$set</span> <span class="operator">*</span> <span class="variable">$set_spec</span><span class="operator">;</span>   <span class="comment"># intersect</span>
  <span class="variable">$x_set</span> <span class="operator">=</span>  <span class="variable">$set</span> <span class="operator">^</span> <span class="variable">$set_spec</span><span class="operator">;</span>   <span class="comment"># xor</span>
  <span class="variable">$d_set</span> <span class="operator">=</span>  <span class="variable">$set</span> <span class="operator">-</span> <span class="variable">$set_spec</span><span class="operator">;</span>   <span class="comment"># diff</span>
  <span class="variable">$c_set</span> <span class="operator">=</span> <span class="operator">~</span><span class="variable">$set</span><span class="operator">;</span>               <span class="comment"># complement</span>
  
  <span class="variable">$set</span> <span class="operator">+=</span> <span class="variable">$set_spec</span><span class="operator">;</span>            <span class="comment"># union</span>
  <span class="variable">$set</span> <span class="operator">*=</span> <span class="variable">$set_spec</span><span class="operator">;</span>            <span class="comment"># intersect</span>
  <span class="variable">$set</span> <span class="operator">^=</span> <span class="variable">$set_spec</span><span class="operator">;</span>            <span class="comment"># xor</span>
  <span class="variable">$set</span> <span class="operator">-=</span> <span class="variable">$set_spec</span><span class="operator">;</span>            <span class="comment"># diff</span>
  
  <span class="variable">$set</span> <span class="keyword">eq</span> <span class="variable">$set_spec</span>             <span class="comment"># equal</span>
  <span class="variable">$set</span> <span class="keyword">ne</span> <span class="variable">$set_spec</span>             <span class="comment"># not equal</span>
  <span class="variable">$set</span> <span class="keyword">le</span> <span class="variable">$set_spec</span>             <span class="comment"># subset</span>
  <span class="variable">$set</span> <span class="keyword">lt</span> <span class="variable">$set_spec</span>             <span class="comment"># proper subset</span>
  <span class="variable">$set</span> <span class="keyword">ge</span> <span class="variable">$set_spec</span>             <span class="comment"># superset</span>
  <span class="variable">$set</span> <span class="keyword">gt</span> <span class="variable">$set_spec</span>             <span class="comment"># proper superset</span>
  
  <span class="comment"># compare sets by cardinality</span>
  <span class="variable">$set1</span> <span class="operator">==</span>  <span class="variable">$set2</span>
  <span class="variable">$set1</span> <span class="operator">!=</span>  <span class="variable">$set2</span>
  <span class="variable">$set1</span> <span class="operator">&lt;=</span>  <span class="variable">$set2</span>
  <span class="variable">$set1</span> <span class="operator">&lt;</span>   <span class="variable">$set2</span>
  <span class="variable">$set1</span> <span class="operator">&gt;=</span>  <span class="variable">$set2</span>
  <span class="variable">$set1</span> <span class="operator">&gt;</span>   <span class="variable">$set2</span>
  <span class="variable">$set1</span> <span class="operator">&lt;=&gt;</span> <span class="variable">$set2</span>
  
  <span class="comment"># compare cardinality of set to an integer</span>
  <span class="variable">$set1</span> <span class="operator">==</span>  <span class="variable">$n</span>
  <span class="variable">$set1</span> <span class="operator">!=</span>  <span class="variable">$n</span>
  <span class="variable">$set1</span> <span class="operator">&lt;=</span>  <span class="variable">$n</span>
  <span class="variable">$set1</span> <span class="operator">&lt;</span>   <span class="variable">$n</span>
  <span class="variable">$set1</span> <span class="operator">&gt;=</span>  <span class="variable">$n</span>
  <span class="variable">$set1</span> <span class="operator">&gt;</span>   <span class="variable">$n</span>
  <span class="variable">$set1</span> <span class="operator">&lt;=&gt;</span> <span class="variable">$n</span>
  
  <span class="variable">@sorted</span> <span class="operator">=</span> <span class="keyword">sort</span> <span class="variable">@sets</span><span class="operator">;</span>         <span class="comment"># sort sets by cardinality</span>
  
  <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$set</span><span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>             <span class="comment"># true if $set is not empty</span>
  
  <span class="keyword">print</span> <span class="string">"</span><span class="variable">$set</span><span class="string">\n"</span><span class="operator">;</span>               <span class="comment"># stringizes to the run list</span>
</code></code></pre>

<h1 id="EXPORTS">EXPORTS</h1>

<h2 id=""><code><code>@EXPORT</code></code></h2>

<p>Nothing</p>

<h2 id="1"><code><code>@EXPORT_OK</code></code></h2>

<p><code><code>grep_set</code></code>, <code><code>map_set</code></code>, <code><code>grep_spans</code></code>, <code><code>map_spans</code></code></p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p><code><code>Set::IntSpan</code></code> manages sets of integers. It is optimized for sets that have long runs of consecutive integers. These arise, for example, in .newsrc files, which maintain lists of articles:</p>

<pre><code><code>  alt.foo: 1-21,28,31
  alt.bar: 1-14192,14194,14196-14221</code></code></pre>

<p>A run of consecutive integers is also called a <i>span</i>.</p>

<p>Sets are stored internally in a run-length coded form. This provides for both compact storage and efficient computation. In particular, set operations can be performed directly on the encoded representation.</p>

<p><code><code>Set::IntSpan</code></code> is designed to manage finite sets. However, it can also represent some simple infinite sets, such as { x | x&gt;n }. This allows operations involving complements to be carried out consistently, without having to worry about the actual value of INT_MAX on your machine.</p>

<h1 id="SPANS">SPANS</h1>

<p>A <i>span</i> is a run of consecutive integers. A span may be represented by an array reference, in any of 5 forms:</p>

<h2 id="Finite-forms">Finite forms</h2>

<pre><code><code>    <span class="variable">Span</span>                <span class="variable">Set</span>
      <span class="operator">[</span> <span class="variable">$n</span><span class="operator">,</span>    <span class="variable">$n</span>    <span class="operator">]</span>      <span class="operator">{</span> <span class="string">n</span> <span class="operator">}</span>
      <span class="operator">[</span> <span class="variable">$a</span><span class="operator">,</span>    <span class="variable">$b</span>    <span class="operator">]</span>      <span class="operator">{</span> <span class="string">x</span> <span class="operator">|</span> <span class="variable">a</span><span class="operator">&lt;=x</span> <span class="operator">&amp;&amp;</span> <span class="operator">x&lt;=</span><span class="variable">b</span><span class="operator">}</span>
</code></code></pre>

<h2 id="Infinite-forms">Infinite forms</h2>

<pre><code><code>    <span class="variable">Span</span>                <span class="variable">Set</span>
      <span class="operator">[</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$b</span>    <span class="operator">]</span>      <span class="operator">{</span> <span class="string">x</span> <span class="operator">|</span> <span class="operator">x&lt;=</span><span class="variable">b</span> <span class="operator">}</span>
      <span class="operator">[</span> <span class="variable">$a</span>   <span class="operator">,</span> <span class="keyword">undef</span> <span class="operator">]</span>      <span class="operator">{</span> <span class="string">x</span> <span class="operator">|</span> <span class="operator">x&gt;=</span><span class="variable">a</span> <span class="operator">}</span>
      <span class="operator">[</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="keyword">undef</span> <span class="operator">]</span>      <span class="variable">The</span> <span class="variable">set</span> <span class="variable">of</span> <span class="variable">all</span> <span class="variable">integers</span>
</code></code></pre>

<p>Some methods operate directly on spans.</p>

<h1 id="SET-SPECIFICATIONS">SET SPECIFICATIONS</h1>

<p>Many of the methods take a <i>set specification</i>. There are four kinds of set specifications.</p>

<h2 id="Empty">Empty</h2>

<p>If a set specification is omitted, then the empty set is assumed. Thus,</p>

<pre><code><code>  <span class="variable">$set</span> <span class="operator">=</span> <span class="variable">new</span> <span class="variable">Set::IntSpan</span><span class="operator">;</span>
</code></code></pre>

<p>creates a new, empty set. Similarly,</p>

<pre><code><code>  <span class="variable">copy</span> <span class="variable">$set</span><span class="operator">;</span>
</code></code></pre>

<p>removes all elements from $set.</p>

<h2 id="Object-reference">Object reference</h2>

<p>If an object reference is given, it is taken to be a <code><code>Set::IntSpan</code></code> object.</p>

<h2 id="Run-list">Run list</h2>

<p>If a string is given, it is taken to be a <i>run list</i>. A run list specifies a set using a syntax similar to that in newsrc files.</p>

<p>A run list is a comma-separated list of <i>runs</i>. Each run specifies a set of consecutive integers. The set is the union of all the runs.</p>

<p>Runs may be written in any of 5 forms.</p>

<h3 id="Finite-forms1">Finite forms</h3>

<dl>

<dt id="n">n</dt>
<dd>

<p>{ n }</p>

</dd>
<dt id="a-b">a-b</dt>
<dd>

<p>{ x | a&lt;=x &amp;&amp; x&lt;=b }</p>

</dd>
</dl>

<h3 id="Infinite-forms1">Infinite forms</h3>

<dl>

<dt id="n1">(-n</dt>
<dd>

<p>{ x | x&lt;=n }</p>

</dd>
<dt id="n--">n-)</dt>
<dd>

<p>{ x | x&gt;=n }</p>

</dd>
<dt id="pod---">(-)</dt>
<dd>

<p>The set of all integers</p>

</dd>
</dl>

<h3 id="Empty-forms">Empty forms</h3>

<p>The empty set is consistently written as &#39;&#39; (the null string). It is also denoted by the special form &#39;-&#39; (a single dash).</p>

<h3 id="Restrictions">Restrictions</h3>

<p>The runs in a run list must be disjoint, and must be listed in increasing order.</p>

<p>Valid characters in a run list are 0-9, &#39;(&#39;, &#39;)&#39;, &#39;-&#39; and &#39;,&#39;. White space and underscore (_) are ignored. Other characters are not allowed.</p>

<h3 id="Examples">Examples</h3>

<pre><code><code>  <span class="variable">Run</span> <span class="variable">list</span>          <span class="variable">Set</span>
  <span class="string">"-"</span>               <span class="operator">{</span> <span class="operator">}</span>
  <span class="string">"1"</span>               <span class="operator">{</span> <span class="number">1</span> <span class="operator">}</span>
  <span class="string">"1-2"</span>             <span class="operator">{</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span> <span class="operator">}</span>
  <span class="string">"-5--1"</span>           <span class="operator">{</span> <span class="operator">-</span><span class="number">5</span><span class="operator">,</span> <span class="operator">-</span><span class="number">4</span><span class="operator">,</span> <span class="operator">-</span><span class="number">3</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">}</span>
  <span class="string">"(-)"</span>             <span class="variable">the</span> <span class="variable">integers</span>
  <span class="string">"(--1"</span>            <span class="variable">the</span> <span class="variable">negative</span> <span class="variable">integers</span>
  <span class="string">"1-3, 4, 18-21"</span>   <span class="operator">{</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">18</span><span class="operator">,</span> <span class="number">19</span><span class="operator">,</span> <span class="number">20</span><span class="operator">,</span> <span class="number">21</span> <span class="operator">}</span>
</code></code></pre>

<h2 id="Array-reference">Array reference</h2>

<p>If an array reference is given, then the elements of the array specify the elements of the set. The array may contain</p>

<ul>

<li><p>integers</p>

</li>
<li><p><a href="#SPANS">spans</a></p>

</li>
</ul>

<p>The set is the union of all the integers and spans in the array. The integers and spans need not be disjoint. The integers and spans may be in any order.</p>

<h3 id="Examples1">Examples</h3>

<pre><code><code>  <span class="variable">Array</span> <span class="keyword">ref</span>                         <span class="variable">Set</span>
  <span class="operator">[</span> <span class="operator">]</span>                               <span class="operator">{</span> <span class="operator">}</span>
  <span class="operator">[</span> <span class="number">1</span><span class="operator">,</span> <span class="number">1</span> <span class="operator">]</span>                          <span class="operator">{</span> <span class="string">1</span> <span class="operator">}</span>
  <span class="operator">[</span> <span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">2</span> <span class="operator">]</span>                       <span class="operator">{</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span> <span class="operator">}</span>
  <span class="operator">[</span> <span class="number">1</span><span class="operator">,</span> <span class="operator">[</span> <span class="number">5</span><span class="operator">,</span> <span class="number">8</span> <span class="operator">]</span><span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="operator">[</span> <span class="number">7</span><span class="operator">,</span> <span class="number">9</span> <span class="operator">]</span><span class="operator">,</span> <span class="number">2</span> <span class="operator">]</span>   <span class="operator">{</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> <span class="number">8</span><span class="operator">,</span> <span class="number">9</span> <span class="operator">}</span>
  <span class="operator">[</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="keyword">undef</span> <span class="operator">]</span>                  <span class="variable">the</span> <span class="variable">integers</span>
  <span class="operator">[</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">]</span>                     <span class="variable">the</span> <span class="variable">negative</span> <span class="variable">integers</span>
</code></code></pre>

<h1 id="ITERATORS">ITERATORS</h1>

<p>Each set has a single <i>iterator</i>, which is shared by all calls to <code><code>first</code></code>, <code><code>last</code></code>, <code><code>start</code></code>, <code><code>next</code></code>, <code><code>prev</code></code>, and <code><code>current</code></code>. At all times, the iterator is either an element of the set, or <code><code>undef</code></code>.</p>

<p><code><code>first</code></code>, <code><code>last</code></code>, and <code><code>start</code></code> set the iterator; <code><code>next</code></code>, and <code><code>prev</code></code> move it; and <code><code>current</code></code> returns it. Calls to these methods may be freely intermixed.</p>

<p>Using <code><code>next</code></code> and <code><code>prev</code></code>, a single loop can move both forwards and backwards through a set. Using <code><code>start</code></code>, a loop can iterate over portions of an infinite set.</p>

<h1 id="METHODS">METHODS</h1>

<h2 id="Creation">Creation</h2>

<dl>

<dt id="set-new-Set::IntSpan-set_spec"><i>$set</i> = <code><code>new</code></code> <code><code>Set::IntSpan</code></code> <i>$set_spec</i></dt>
<dd>

</dd>
<dt id="set-new-Set::IntSpan-set_specs"><i>$set</i> = <code><code>new</code></code> <code><code>Set::IntSpan</code></code> <i>@set_specs</i></dt>
<dd>

<p>Creates and returns a <code><code>Set::IntSpan</code></code> object.</p>

<p>The initial contents of the set are given by <i>$set_spec</i>, or by the union of all the <i>@set_specs</i>.</p>

</dd>
<dt id="ok-valid-Set::IntSpan-run_list"><i>$ok</i> = <code><code>valid</code></code> <code><code>Set::IntSpan</code></code> <i>$run_list</i></dt>
<dd>

<p>Returns true if <i>$run_list</i> is a valid run list. Otherwise, returns false and leaves an error message in $@.</p>

</dd>
<dt id="set-copy-set-set_spec"><i>$set</i> = <code><code>copy</code></code> <i>$set</i> <i>$set_spec</i></dt>
<dd>

<p>Copies <i>$set_spec</i> into <i>$set</i>. The previous contents of <i>$set</i> are lost. For convenience, <code><code>copy</code></code> returns <i>$set</i>.</p>

</dd>
<dt id="run_list-run_list-set"><i>$run_list</i> = <code><code>run_list</code></code> <i>$set</i></dt>
<dd>

<p>Returns a run list that represents <i>$set</i>. The run list will not contain white space. <i>$set</i> is not affected.</p>

<p>By default, the empty set is formatted as &#39;-&#39;; a different string may be specified in <code><code>$Set::IntSpan::Empty_String</code></code>.</p>

</dd>
<dt id="elements-elements-set"><i>@elements</i> = <code><code>elements</code></code> <i>$set</i></dt>
<dd>

<p>Returns an array containing the elements of <i>$set</i>. The elements will be sorted in numerical order. In scalar context, returns an array reference. <i>$set</i> is not affected.</p>

</dd>
<dt id="sets-sets-set"><i>@sets</i> = <code><code>sets</code></code> <i>$set</i></dt>
<dd>

<p>Returns the runs in <i>$set</i>, as a list of <code><code>Set::IntSpan</code></code> objects. The sets in the list are in order.</p>

</dd>
<dt id="spans-spans-set"><i>@spans</i> = <code><code>spans</code></code> <i>$set</i></dt>
<dd>

<p>Returns the runs in <i>$set</i>, as a list of the form</p>

<pre><code><code>  ([$a1, $b1],
   [$a2, $b2],
   ...
   [$aN, $bN])</code></code></pre>

<p>If a run contains only a single integer, then the upper and lower bounds of the corresponding span will be equal.</p>

<p>If the set has no lower bound, then $a1 will be <code><code>undef</code></code>. Similarly, if the set has no upper bound, then $bN will be <code><code>undef</code></code>.</p>

<p>The runs in the list are in order.</p>

</dd>
</dl>

<h2 id="Set-operations">Set operations</h2>

<p>For these operations, a new <code><code>Set::IntSpan</code></code> object is created and returned. The operands are not affected.</p>

<dl>

<dt id="u_set-union-set-set_spec"><i>$u_set</i> = <code><code>union</code></code> <i>$set</i> <i>$set_spec</i></dt>
<dd>

<p>Returns the set of integers in either <i>$set</i> or <i>$set_spec</i>.</p>

</dd>
<dt id="i_set-intersect-set-set_spec"><i>$i_set</i> = <code><code>intersect</code></code> <i>$set</i> <i>$set_spec</i></dt>
<dd>

<p>Returns the set of integers in both <i>$set</i> and <i>$set_spec</i>.</p>

</dd>
<dt id="x_set-xor-set-set_spec"><i>$x_set</i> = <code><code>xor</code></code> <i>$set</i> <i>$set_spec</i></dt>
<dd>

<p>Returns the set of integers in <i>$set</i> or <i>$set_spec</i>, but not both.</p>

</dd>
<dt id="d_set-diff-set-set_spec"><i>$d_set</i> = <code><code>diff</code></code> <i>$set</i> <i>$set_spec</i></dt>
<dd>

<p>Returns the set of integers in <i>$set</i> but not in <i>$set_spec</i>.</p>

</dd>
<dt id="c_set-complement-set"><i>$c_set</i> = <code><code>complement</code></code> <i>$set</i></dt>
<dd>

<p>Returns the set of integers that are not in <i>$set</i>.</p>

</dd>
</dl>

<h2 id="Mutators">Mutators</h2>

<p>By popular demand, <code><code>Set::IntSpan</code></code> now has mutating forms of the binary set operations. These methods alter the object on which they are called.</p>

<dl>

<dt id="set-U-set_spec-"><i>$set</i>-&gt;<code><code>U</code></code>(<i>$set_spec</i>)</dt>
<dd>

<p>Makes <i>$set</i> the union of <i>$set</i> and <i>$set_spec</i>. Returns <i>$set</i>.</p>

</dd>
<dt id="set-I-set_spec-"><i>$set</i>-&gt;<code><code>I</code></code>(<i>$set_spec</i>)</dt>
<dd>

<p>Makes <i>$set</i> the intersection of <i>$set</i> and <i>$set_spec</i>. Returns <i>$set</i>.</p>

</dd>
<dt id="set-X-set_spec-"><i>$set</i>-&gt;<code><code>X</code></code>(<i>$set_spec</i>)</dt>
<dd>

<p>Makes <i>$set</i> the symmetric difference of <i>$set</i> and <i>$set_spec</i>. Returns <i>$set</i>.</p>

</dd>
<dt id="set-D-set_spec-"><i>$set</i>-&gt;<code><code>D</code></code>(<i>$set_spec</i>)</dt>
<dd>

<p>Makes <i>$set</i> the difference of <i>$set</i> and <i>$set_spec</i>. Returns <i>$set</i>.</p>

</dd>
<dt id="set-C"><i>$set</i>-&gt;<code><code>C</code></code></dt>
<dd>

<p>Converts <i>$set</i> to its own complement. Returns <i>$set</i>.</p>

</dd>
</dl>

<h2 id="Comparison">Comparison</h2>

<dl>

<dt id="equal-set-set_spec"><code><code>equal</code></code> <i>$set</i> <i>$set_spec</i></dt>
<dd>

<p>Returns true iff <i>$set</i> and <i>$set_spec</i> contain the same elements.</p>

</dd>
<dt id="equivalent-set-set_spec"><code><code>equivalent</code></code> <i>$set</i> <i>$set_spec</i></dt>
<dd>

<p>Returns true iff <i>$set</i> and <i>$set_spec</i> contain the same number of elements. All infinite sets are equivalent.</p>

</dd>
<dt id="superset-set-set_spec"><code><code>superset</code></code> <i>$set</i> <i>$set_spec</i></dt>
<dd>

<p>Returns true iff <i>$set</i> is a superset of <i>$set_spec</i>.</p>

</dd>
<dt id="subset-set-set_spec"><code><code>subset</code></code> <i>$set</i> <i>$set_spec</i></dt>
<dd>

<p>Returns true iff <i>$set</i> is a subset of <i>$set_spec</i>.</p>

</dd>
</dl>

<h2 id="Cardinality">Cardinality</h2>

<dl>

<dt id="n-cardinality-set"><i>$n</i> = <code><code>cardinality</code></code> <i>$set</i></dt>
<dd>

</dd>
<dt id="n-size-set"><i>$n</i> = <code><code>size</code></code> <i>$set</i></dt>
<dd>

<p>Returns the number of elements in <i>$set</i>. Returns -1 for infinite sets. <code><code>size</code></code> is provided as an alias for <code><code>cardinality</code></code>.</p>

</dd>
<dt id="empty-set"><code><code>empty</code></code> <i>$set</i></dt>
<dd>

<p>Returns true iff <i>$set</i> is empty.</p>

</dd>
<dt id="finite-set"><code><code>finite</code></code> <i>$set</i></dt>
<dd>

<p>Returns true iff <i>$set</i> is finite.</p>

</dd>
<dt id="neg_inf-set"><code><code>neg_inf</code></code> <i>$set</i></dt>
<dd>

<p>Returns true iff <i>$set</i> contains {x | x&lt;n} for some n.</p>

</dd>
<dt id="pos_inf-set"><code><code>pos_inf</code></code> <i>$set</i></dt>
<dd>

<p>Returns true iff <i>$set</i> contains {x | x&gt;n} for some n.</p>

</dd>
<dt id="infinite-set"><code><code>infinite</code></code> <i>$set</i></dt>
<dd>

<p>Returns true iff <i>$set</i> is infinite.</p>

</dd>
<dt id="universal-set"><code><code>universal</code></code> <i>$set</i></dt>
<dd>

<p>Returns true iff <i>$set</i> contains all integers.</p>

</dd>
</dl>

<h2 id="Membership">Membership</h2>

<dl>

<dt id="member-set-n"><code><code>member</code></code> <i>$set</i> <i>$n</i></dt>
<dd>

<p>Returns true iff the integer <i>$n</i> is a member of <i>$set</i>.</p>

</dd>
<dt id="insert-set-n"><code><code>insert</code></code> <i>$set</i> <i>$n</i></dt>
<dd>

<p>Inserts the integer <i>$n</i> into <i>$set</i>. Does nothing if <i>$n</i> is already a member of <i>$set</i>.</p>

</dd>
<dt id="remove-set-n"><code><code>remove</code></code> <i>$set</i> <i>$n</i></dt>
<dd>

<p>Removes the integer <i>$n</i> from <i>$set</i>. Does nothing if <i>$n</i> is not a member of <i>$set</i>.</p>

</dd>
</dl>

<h2 id="Extrema">Extrema</h2>

<dl>

<dt id="min-set"><code><code>min</code></code> <i>$set</i></dt>
<dd>

<p>Returns the smallest element of <i>$set</i>, or <code><code>undef</code></code> if there is none.</p>

</dd>
<dt id="max-set"><code><code>max</code></code> <i>$set</i></dt>
<dd>

<p>Returns the largest element of <i>$set</i>, or <code><code>undef</code></code> if there is none.</p>

</dd>
</dl>

<h2 id="Spans">Spans</h2>

<dl>

<dt id="holes-holes-set"><i>$holes</i> = <code><code>holes</code></code> <i>$set</i></dt>
<dd>

<p>Returns a set containing all the holes in <i>$set</i>, that is, all the integers that are in-between spans of <i>$set</i>.</p>

<p><code><code>holes</code></code> is always a finite set.</p>

</dd>
<dt id="cover-cover-set"><i>$cover</i> = <code><code>cover</code></code> <i>$set</i></dt>
<dd>

<p>Returns a set consisting of a single span from <i>$set</i>-&gt;<code><code>min</code></code> to <i>$set</i>-&gt;<code><code>max</code></code>. This is the same as</p>

<pre><code><code>  union $set $set-&gt;holes</code></code></pre>

</dd>
<dt id="inset-inset-set-n"><i>$inset</i> = <code><code>inset</code></code> <i>$set</i> <i>$n</i></dt>
<dd>

</dd>
<dt id="smaller-trim-set-n"><i>$smaller</i> = <code><code>trim</code></code> <i>$set</i> <i>$n</i></dt>
<dd>

</dd>
<dt id="bigger-pad-set-n"><i>$bigger</i> = <code><code>pad</code></code> <i>$set</i> <i>$n</i></dt>
<dd>

<p><code><code>inset</code></code> returns a set constructed by removing <i>$n</i> integers from each end of each span of <i>$set</i>. If <i>$n</i> is negative, then -<i>$n</i> integers are added to each end of each span.</p>

<p>In the first case, spans may vanish from the set; in the second case, holes may vanish.</p>

<p><code><code>trim</code></code> is provided as a synonym for <code><code>inset</code></code>.</p>

<p><code><code>pad</code></code> <i>$set</i> <i>$n</i> is the same as <code><code>inset</code></code> <i>$set</i> -<i>$n</i>.</p>

</dd>
</dl>

<h2 id="Iterators">Iterators</h2>

<dl>

<dt id="set-first"><i>$set</i>-&gt;<code><code>first</code></code></dt>
<dd>

<p>Sets the iterator for <i>$set</i> to the smallest element of <i>$set</i>. If there is no smallest element, sets the iterator to <code><code>undef</code></code>. Returns the iterator.</p>

</dd>
<dt id="set-last"><i>$set</i>-&gt;<code><code>last</code></code></dt>
<dd>

<p>Sets the iterator for <i>$set</i> to the largest element of <i>$set</i>. If there is no largest element, sets the iterator to <code><code>undef</code></code>. Returns the iterator.</p>

</dd>
<dt id="set-start-n-"><i>$set</i>-&gt;<code><code>start</code></code>(<i>$n</i>)</dt>
<dd>

<p>Sets the iterator for <i>$set</i> to <i>$n</i>. If <i>$n</i> is not an element of <i>$set</i>, sets the iterator to <code><code>undef</code></code>. Returns the iterator.</p>

</dd>
<dt id="set-next"><i>$set</i>-&gt;<code><code>next</code></code></dt>
<dd>

<p>Sets the iterator for <i>$set</i> to the next element of <i>$set</i>. If there is no next element, sets the iterator to <code><code>undef</code></code>. Returns the iterator.</p>

<p><code><code>next</code></code> will return <code><code>undef</code></code> only once; the next call to <code><code>next</code></code> will reset the iterator to the smallest element of <i>$set</i>.</p>

</dd>
<dt id="set-prev"><i>$set</i>-&gt;<code><code>prev</code></code></dt>
<dd>

<p>Sets the iterator for <i>$set</i> to the previous element of <i>$set</i>. If there is no previous element, sets the iterator to <code><code>undef</code></code>. Returns the iterator.</p>

<p><code><code>prev</code></code> will return <code><code>undef</code></code> only once; the next call to <code><code>prev</code></code> will reset the iterator to the largest element of <i>$set</i>.</p>

</dd>
<dt id="set-current"><i>$set</i>-&gt;<code><code>current</code></code></dt>
<dd>

<p>Returns the iterator for <i>$set</i>.</p>

</dd>
</dl>

<h2 id="Indexing">Indexing</h2>

<p>The elements of a set are kept in numerical order. These methods index into the set based on this ordering.</p>

<dl>

<dt id="n-set-at-i-"><i>$n</i> = <i>$set</i>-&gt;<code><code>at</code></code>($i)</dt>
<dd>

<p>Returns the <i>$i</i>th element of <i>$set</i>, or <code><code>undef</code></code> if there is no <i>$i</i>th element. Negative indices count backwards from the end of the set.</p>

<p>Dies if</p>

<ul>

<li><p><i>$i</i> is non-negative and <i>$set</i> is <code><code>neg_inf</code></code></p>

</li>
<li><p><i>$i</i> is negative and <i>$set</i> is <code><code>pos_inf</code></code></p>

</li>
</ul>

</dd>
<dt id="slice-set-slice-from-to-"><i>$slice</i> = <i>$set</i>-&gt;<code><code>slice</code></code>(<i>$from</i>, <i>$to</i>)</dt>
<dd>

<p>Returns a <code><code>Set::IntSpan</code></code> object containing the elements of <i>$set</i> at indices <i>$from</i>..<i>$to</i>. Negative indices count backwards from the end of the set.</p>

<p>Dies if</p>

<ul>

<li><p><i>$from</i> is non-negative and <i>$set</i> is <code><code>neg_inf</code></code></p>

</li>
<li><p><i>$from</i> is negative and <i>$set</i> is <code><code>pos_inf</code></code></p>

</li>
</ul>

</dd>
<dt id="i-set-ord-n-"><i>$i</i> = <i>$set</i>-&gt;<code><code>ord</code></code>($n)</dt>
<dd>

<p>The inverse of <code><code>at</code></code>.</p>

<p>Returns the index <i>$i</i> of the integer <i>$n</i> in <i>$set</i>, or <code><code>undef</code></code> if <i>$n</i> if not an element of <i>$set</i>.</p>

<p>Dies if <i>$set</i> is <code><code>neg_inf</code></code>.</p>

</dd>
<dt id="i-set-span_ord-n-"><i>$i</i> = <i>$set</i>-&gt;<code><code>span_ord</code></code>($n)</dt>
<dd>

<p>Returns the index <i>$i</i> of the span containing the integer <i>$n</i>, or <code><code>undef</code></code> if <i>$n</i> if not an element of <i>$set</i>.</p>

<p>To recover the span containing <i>$n</i>, write</p>

<pre><code><code>  ($set-&gt;spans)[$i]</code></code></pre>

</dd>
</dl>

<h1 id="OPERATOR-OVERLOADS">OPERATOR OVERLOADS</h1>

<p>For convenience, some operators are overloaded on <code><code>Set::IntSpan</code></code> objects.</p>

<h2 id="set-operations">set operations</h2>

<p>One operand must be a <code><code>Set::IntSpan</code></code> object. The other operand may be a <code><code>Set::IntSpan</code></code> object or a set specification.</p>

<pre><code><code>  <span class="variable">$u_set</span> <span class="operator">=</span>  <span class="variable">$set</span> <span class="operator">+</span> <span class="variable">$set_spec</span><span class="operator">;</span>   <span class="comment"># union</span>
  <span class="variable">$i_set</span> <span class="operator">=</span>  <span class="variable">$set</span> <span class="operator">*</span> <span class="variable">$set_spec</span><span class="operator">;</span>   <span class="comment"># intersect</span>
  <span class="variable">$x_set</span> <span class="operator">=</span>  <span class="variable">$set</span> <span class="operator">^</span> <span class="variable">$set_spec</span><span class="operator">;</span>   <span class="comment"># xor</span>
  <span class="variable">$d_set</span> <span class="operator">=</span>  <span class="variable">$set</span> <span class="operator">-</span> <span class="variable">$set_spec</span><span class="operator">;</span>   <span class="comment"># diff</span>
  <span class="variable">$c_set</span> <span class="operator">=</span> <span class="operator">~</span><span class="variable">$set</span><span class="operator">;</span>               <span class="comment"># complement</span>
  
  <span class="variable">$set</span> <span class="operator">+=</span> <span class="variable">$set_spec</span><span class="operator">;</span>            <span class="comment"># union</span>
  <span class="variable">$set</span> <span class="operator">*=</span> <span class="variable">$set_spec</span><span class="operator">;</span>            <span class="comment"># intersect</span>
  <span class="variable">$set</span> <span class="operator">^=</span> <span class="variable">$set_spec</span><span class="operator">;</span>            <span class="comment"># xor</span>
  <span class="variable">$set</span> <span class="operator">-=</span> <span class="variable">$set_spec</span><span class="operator">;</span>            <span class="comment"># diff</span>
</code></code></pre>

<h2 id="equality">equality</h2>

<p>The string comparison operations are overloaded to compare sets for equality and containment. One operand must be a <code><code>Set::IntSpan</code></code> object. The other operand may be a <code><code>Set::IntSpan</code></code> object or a set specification.</p>

<pre><code><code>  $set eq $set_spec             # equal
  $set ne $set_spec             # not equal
  $set le $set_spec             # subset
  $set lt $set_spec             # proper subset
  $set ge $set_spec             # superset
  $set gt $set_spec             # proper superset</code></code></pre>

<h2 id="equivalence">equivalence</h2>

<p>The numerical comparison operations are overloaded to compare sets by cardinality. One operand must be a <code><code>Set::IntSpan</code></code> object. The other operand may be a <code><code>Set::IntSpan</code></code> object or an integer.</p>

<pre><code><code>  $set1 ==  $set2
  $set1 !=  $set2
  $set1 &lt;=  $set2
  $set1 &lt;   $set2
  $set1 &gt;=  $set2
  $set1 &gt;   $set2
  $set1 &lt;=&gt; $set2
  $set1 cmp $set2

  $set1 ==  $n
  $set1 !=  $n
  $set1 &lt;=  $n
  $set1 &lt;   $n
  $set1 &gt;=  $n
  $set1 &gt;   $n
  $set1 &lt;=&gt; $n
  $set1 cmp $n</code></code></pre>

<p>N.B. The <code><code>cmp</code></code> operator is overloaded to compare sets by cardinality, not containment. This is done so that</p>

<pre><code><code>  sort @sets</code></code></pre>

<p>will sort a list of sets by cardinality.</p>

<h2 id="conversion">conversion</h2>

<p>In boolean context, a <code><code>Set::IntSpan</code></code> object evaluates to true if it is not empty.</p>

<p>A <code><code>Set::IntSpan</code></code> object stringizes to its run list.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<dl>

<dt id="sub_set-grep_set-...-set"><i>$sub_set</i> = <code><code>grep_set</code></code> { ... } <i>$set</i></dt>
<dd>

<p>Evaluates the BLOCK for each integer in <i>$set</i> (locally setting <code><code>$_</code></code> to each integer) and returns a <code><code>Set::IntSpan</code></code> object containing those integers for which the BLOCK returns TRUE.</p>

<p>Returns <code><code>undef</code></code> if <i>$set</i> is infinite.</p>

</dd>
<dt id="map_set-map_set-...-set"><i>$map_set</i> = <code><code>map_set</code></code> { ... } <i>$set</i></dt>
<dd>

<p>Evaluates the BLOCK for each integer in <i>$set</i> (locally setting <code><code>$_</code></code> to each integer) and returns a <code><code>Set::IntSpan</code></code> object containing all the integers returned as results of all those evaluations.</p>

<p>Evaluates the BLOCK in list context, so each element of <i>$set</i> may produce zero, one, or more elements in the returned set. The elements may be returned in any order, and need not be disjoint.</p>

<p>Returns <code><code>undef</code></code> if <i>$set</i> is infinite.</p>

</dd>
<dt id="sub_set-grep_spans-...-set"><i>$sub_set</i> = <code><code>grep_spans</code></code> { ... } <i>$set</i></dt>
<dd>

<p>Evaluates the BLOCK for each span in <i>$set</i> and returns a <code><code>Set::IntSpan</code></code> object containing those spans for which the BLOCK returns TRUE.</p>

<p>Within BLOCK, <code><code>$_</code></code> is locally set to an array ref of the form</p>

<pre><code><code>  [ $lower, $upper ]</code></code></pre>

<p>where <i>$lower</i> and <i>$upper</i> are the bounds of the span. If the span contains only one integer, then <i>$lower</i> and <i>$upper</i> will be equal. If the span is unbounded, then the corresponding element(s) of the array will be <code><code>undef</code></code>.</p>

</dd>
<dt id="map_set-map_spans-...-set"><i>$map_set</i> = <code><code>map_spans</code></code> { ... } <i>$set</i></dt>
<dd>

<p>Evaluates the BLOCK for each span in <i>$set</i>, and returns a <code><code>Set::IntSpan</code></code> object consisting of the union of all the spans returned as results of all those evaluations.</p>

<p>Within BLOCK, <code><code>$_</code></code> is locally set to an array ref of the form</p>

<pre><code><code>  [ $lower, $upper ]</code></code></pre>

<p>as described above for <code><code>grep_spans</code></code>. Each evaluation of BLOCK must return a list of <a href="#SPANS">spans</a>. Each returned list may contain zero, one, or more spans. Spans may be returned in any order, and need not be disjoint. However, for each bounded span, the constraint</p>

<pre><code><code>  $lower &lt;= $upper</code></code></pre>

<p>must hold.</p>

</dd>
</dl>

<h1 id="CLASS-VARIABLES">CLASS VARIABLES</h1>

<dl>

<dt id="Set::IntSpan::Empty_String"><code><code>$Set::IntSpan::Empty_String</code></code></dt>
<dd>

<p><code><code>$Set::IntSpan::Empty_String</code></code> contains the string that is returned when <code><code>run_list</code></code> is called on the empty set. <code><code>$Empty_String</code></code> is initially &#39;-&#39;; alternatively, it may be set to &#39;&#39;. Other values should be avoided, to ensure that <code><code>run_list</code></code> always returns a valid run list.</p>

<p><code><code>run_list</code></code> accesses <code><code>$Empty_String</code></code> through a reference stored in <i>$set</i>-&gt;{<code><code>empty_string</code></code>}. Subclasses that wish to override the value of <code><code>$Empty_String</code></code> can reassign this reference.</p>

</dd>
<dt id="Set::IntSpan::integer"><code><code>$Set::IntSpan::integer</code></code></dt>
<dd>

<p>Up until version 1.16, <code><code>Set::IntSpan</code></code> specified <code><code>use integer</code></code>, because they were sets of...you know...integers. As of 2012, users are reporting newsgroups with article numbers above 0x7fffffff, which break <code><code>Set::IntSpan</code></code> on 32-bit processors.</p>

<p>Version 1.17 removes <code><code>use integer</code></code> by default. This extends the usable range of <code><code>Set::IntSpan</code></code> to the number of bits in the mantissa of your floating point representation. For IEEE 754 doubles, this is 53 bits, or around 9e15.</p>

<p>I benchmarked <code><code>Set::IntSpan</code></code> on a Pentium 4, and it looks like <code><code>use integer</code></code> provides a 2% to 4% speedup, depending on the application.</p>

<p>If you want <code><code>use integer</code></code> back, either for performance, or because you are somehow dependent on its semantics, write</p>

<pre><code><code>  <span class="keyword">BEGIN</span> <span class="operator">{</span> <span class="variable">$Set::IntSpan::integer</span> <span class="operator">=</span> <span class="number">1</span> <span class="operator">}</span>
  <span class="keyword">use</span> <span class="variable">Set::IntSpan</span><span class="operator">;</span>
</code></code></pre>

</dd>
</dl>

<h1 id="DIAGNOSTICS">DIAGNOSTICS</h1>

<p>Any method (except <code><code>valid</code></code>) will <code><code>die</code></code> if it is passed an invalid run list.</p>

<dl>

<dt id="Set::IntSpan::_copy_run_list:-Bad-syntax:-runList"><code><code>Set::IntSpan::_copy_run_list: Bad syntax:</code></code> <i>$runList</i></dt>
<dd>

<p>(F) <i>$run_list</i> has bad syntax</p>

</dd>
<dt id="Set::IntSpan::_copy_run_list:-Bad-order:-runList"><code><code>Set::IntSpan::_copy_run_list: Bad order:</code></code> <i>$runList</i></dt>
<dd>

<p>(F) <i>$run_list</i> has overlapping runs or runs that are out of order.</p>

</dd>
<dt id="Set::IntSpan::elements:-infinite-set"><code><code>Set::IntSpan::elements: infinite set</code></code></dt>
<dd>

<p>(F) An infinite set was passed to <code><code>elements</code></code>.</p>

</dd>
<dt id="Set::IntSpan::at:-negative-infinite-set"><code><code>Set::IntSpan::at: negative infinite set</code></code></dt>
<dd>

<p>(F) <code><code>at</code></code> was called with a non-negative index on a negative infinite set.</p>

</dd>
<dt id="Set::IntSpan::at:-positive-infinite-set"><code><code>Set::IntSpan::at: positive infinite set</code></code></dt>
<dd>

<p>(F) <code><code>at</code></code> was called with a negative index on a positive infinite set.</p>

</dd>
<dt id="Set::IntSpan::slice:-negative-infinite-set"><code><code>Set::IntSpan::slice: negative infinite set</code></code></dt>
<dd>

<p>(F) <code><code>slice</code></code> was called with <i>$from</i> non-negative on a negative infinite set.</p>

</dd>
<dt id="Set::IntSpan::slice:-positive-infinite-set"><code><code>Set::IntSpan::slice: positive infinite set</code></code></dt>
<dd>

<p>(F) <code><code>slice</code></code> was called with <i>$from</i> negative on a positive infinite set.</p>

</dd>
<dt id="Set::IntSpan::ord:-negative-infinite-set"><code><code>Set::IntSpan::ord: negative infinite set</code></code></dt>
<dd>

<p>(F) <code><code>ord</code></code> was called on a negative infinite set.</p>

</dd>
<dt id="Out-of-memory-">Out of memory!</dt>
<dd>

<p>(X) <code><code>elements</code></code> <i>$set</i> can generate an &quot;Out of memory!&quot; message on sufficiently large finite sets.</p>

</dd>
</dl>

<h1 id="NOTES">NOTES</h1>

<h2 id="Traps">Traps</h2>

<p>Beware of forms like</p>

<pre><code><code>  <span class="variable">union</span> <span class="variable">$set</span> <span class="operator">[</span><span class="number">1</span><span class="operator">..</span><span class="number">5</span><span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>This passes an element of @set to union, which is probably not what you want. To force interpretation of $set and [1..5] as separate arguments, use forms like</p>

<pre><code><code>    <span class="variable">union</span> <span class="variable">$set</span> <span class="operator">+</span><span class="operator">[</span><span class="number">1</span><span class="operator">..</span><span class="number">5</span><span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>or</p>

<pre><code><code>    <span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">union</span><span class="operator">(</span><span class="operator">[</span><span class="number">1</span><span class="operator">..</span><span class="number">5</span><span class="operator">]</span><span class="operator">);</span>
</code></code></pre>

<h2 id="grep_set-and-map_set">grep_set and map_set</h2>

<p><code><code>grep_set</code></code> and <code><code>map_set</code></code> make it easy to construct sets for which the internal representation used by <code><code>Set::IntSpan</code></code> is <i>not</i> small. Consider:</p>

<pre><code><code>  <span class="variable">$billion</span> <span class="operator">=</span> <span class="variable">new</span> <span class="variable">Set::IntSpan</span> <span class="string">'0-1_000_000_000'</span><span class="operator">;</span>   <span class="comment"># OK</span>
  <span class="variable">$odd</span>     <span class="operator">=</span> <span class="variable">grep_set</span> <span class="operator">{</span> <span class="variable">$_</span> <span class="operator">&amp;</span> <span class="number">1</span> <span class="operator">}</span> <span class="variable">$billion</span><span class="operator">;</span>         <span class="comment"># trouble</span>
  <span class="variable">$even</span>    <span class="operator">=</span> <span class="variable">map_set</span>  <span class="operator">{</span> <span class="variable">$_</span> <span class="operator">*</span> <span class="number">2</span> <span class="operator">}</span> <span class="variable">$billion</span><span class="operator">;</span>         <span class="comment"># double trouble</span>
</code></code></pre>

<h2 id="Error-handling">Error handling</h2>

<p>There are two common approaches to error handling: exceptions and return codes. There seems to be some religion on the topic, so <code><code>Set::IntSpan</code></code> provides support for both.</p>

<p>To catch exceptions, protect method calls with an eval:</p>

<pre><code><code>    <span class="variable">$run_list</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>
    <span class="keyword">eval</span> <span class="operator">{</span> <span class="variable">$set</span> <span class="operator">=</span> <span class="variable">new</span> <span class="variable">Set::IntSpan</span> <span class="variable">$run_list</span> <span class="operator">};</span>
    <span class="variable">$@</span> <span class="keyword">and</span> <span class="keyword">print</span> <span class="string">"$@: try again\n"</span><span class="operator">;</span>
</code></code></pre>

<p>To check return codes, use an appropriate method call to validate arguments:</p>

<pre><code><code>    <span class="variable">$run_list</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">valid</span> <span class="variable">Set::IntSpan</span> <span class="variable">$run_list</span><span class="operator">)</span>
       <span class="operator">{</span> <span class="variable">$set</span> <span class="operator">=</span> <span class="variable">new</span> <span class="variable">Set::IntSpan</span> <span class="variable">$run_list</span> <span class="operator">}</span>
    <span class="keyword">else</span>
       <span class="operator">{</span> <span class="keyword">print</span> <span class="string">"$@ try again\n"</span> <span class="operator">}</span>
</code></code></pre>

<p>Similarly, use <code><code>finite</code></code> to protect calls to <code><code>elements</code></code>:</p>

<pre><code><code>    <span class="variable">finite</span> <span class="variable">$set</span> <span class="keyword">and</span> <span class="variable">@elements</span> <span class="operator">=</span> <span class="variable">elements</span> <span class="variable">$set</span><span class="operator">;</span>
</code></code></pre>

<p>Calling <code><code>elements</code></code> on a large, finite set can generate an &quot;Out of memory!&quot; message, which cannot (easily) be trapped. Applications that must retain control after an error can use <code><code>intersect</code></code> to protect calls to <code><code>elements</code></code>:</p>

<pre><code><code>    <span class="variable">@elements</span> <span class="operator">=</span> <span class="variable">elements</span> <span class="operator">{</span> <span class="variable">intersect</span> <span class="variable">$set</span> <span class="string">"-1_000_000 - 1_000_000"</span> <span class="operator">};</span>
</code></code></pre>

<p>or check the size of $set first:</p>

<pre><code><code>    <span class="variable">finite</span> <span class="variable">$set</span> <span class="keyword">and</span> <span class="variable">cardinality</span> <span class="variable">$set</span> <span class="operator">&lt;</span> <span class="number">2_000_000</span> <span class="keyword">and</span> <span class="variable">@elements</span> <span class="operator">=</span> <span class="variable">elements</span> <span class="variable">$set</span><span class="operator">;</span>
</code></code></pre>

<h2 id="Limitations">Limitations</h2>

<p>Although <code><code>Set::IntSpan</code></code> can represent some infinite sets, it does <i>not</i> perform infinite-precision arithmetic. Therefore, finite elements are restricted to the range of integers on your machine.</p>

<h2 id="Extensions">Extensions</h2>

<p>Users report that you can construct Set::IntSpan objects on anything that behaves like an integer. For example:</p>

<pre><code><code>    <span class="variable">$x</span>   <span class="operator">=</span> <span class="variable">new</span> <span class="variable">Math::BigInt</span> <span class="operator">...;</span>
    <span class="variable">$set</span> <span class="operator">=</span> <span class="variable">new</span> <span class="variable">Set::Intspan</span> <span class="operator">[</span> <span class="operator">[</span> <span class="variable">$x</span><span class="operator">,</span> <span class="variable">$x</span><span class="operator">+</span><span class="number">5</span> <span class="operator">]</span> <span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>I&#39;m not documenting this as supported behavior, because I don&#39;t have the resources to test it, but I&#39;ll try not to break it. If anyone finds problems with it, let me know.</p>

<h2 id="Roots">Roots</h2>

<p>The sets implemented here are based on a Macintosh data structure called a <i>region</i>. See Inside Macintosh for more information.</p>

<p><code><code>Set::IntSpan</code></code> was originally written to manage run lists for the <a><code><code>News::Newsrc</code></code></a> module.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Steven McDougall &lt;swmcd@world.std.com&gt;</p>

<h1 id="ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</h1>

<ul>

<li><p>Malcolm Cook &lt;mec@stowers-institute.org&gt;</p>

</li>
<li><p>David Hawthorne &lt;dsrthorne@hotmail.com&gt;</p>

</li>
<li><p>Martin Krzywinski &lt;martink@bcgsc.ca&gt;</p>

</li>
<li><p>Marc Lehmann &lt;schmorp@schmorp.de&gt;</p>

</li>
<li><p>Andrew Olson &lt;aolson@me.com&gt;</p>

</li>
<li><p>Nicholas Redgrave &lt;baron@bologrew.net&gt;</p>

</li>
</ul>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 1996-2013 by Steven McDougall. This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>


</body>

</html>


