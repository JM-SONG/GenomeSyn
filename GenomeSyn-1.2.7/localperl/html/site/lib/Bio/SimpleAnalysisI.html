<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#FEEDBACK">FEEDBACK</a>
    <ul>
      <li><a href="#Mailing-Lists">Mailing Lists</a></li>
      <li><a href="#Support">Support</a></li>
      <li><a href="#Reporting-Bugs">Reporting Bugs</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
  <li><a href="#DISCLAIMER">DISCLAIMER</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#APPENDIX">APPENDIX</a>
    <ul>
      <li><a href="#analysis_name">analysis_name</a></li>
      <li><a href="#analysis_spec">analysis_spec</a></li>
      <li><a href="#input_spec">input_spec</a></li>
      <li><a href="#result_spec">result_spec</a></li>
      <li><a href="#run">run</a></li>
      <li><a href="#wait_for">wait_for</a></li>
      <li><a href="#status">status</a></li>
      <li><a href="#result">result</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Bio::SimpleAnalysisI - A simple interface to any (local or remote) analysis tool</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>This is an interface module - you do not instantiate it. Use other modules instead (those that implement this interface).</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This interface contains public methods for accessing and controlling local and remote analysis tools. It is meant to be used on the client side. The interface consists only of a necessary set of methods for synchronous invocation of analysis tools. For more complex set, including an asynchronous access, see interface <code><code>Bio::AnalysisI</code></code> (which inherits from this one, by the way).</p>

<h1 id="FEEDBACK">FEEDBACK</h1>

<h2 id="Mailing-Lists">Mailing Lists</h2>

<p>User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments and suggestions preferably to the Bioperl mailing list. Your participation is much appreciated.</p>

<pre><code><code>  bioperl-l@bioperl.org                  - General discussion
  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists</code></code></pre>

<h2 id="Support">Support</h2>

<p>Please direct usage questions or support issues to the mailing list:</p>

<p><i>bioperl-l@bioperl.org</i></p>

<p>rather than to the module maintainer directly. Many experienced and reponsive experts will be able look at the problem and quickly address it. Please include a thorough description of the problem with code and data examples if at all possible.</p>

<h2 id="Reporting-Bugs">Reporting Bugs</h2>

<p>Report bugs to the Bioperl bug tracking system to help us keep track of the bugs and their resolution. Bug reports can be submitted via the web:</p>

<pre><code><code>  https://redmine.open-bio.org/projects/bioperl/</code></code></pre>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Martin Senger (martin.senger@gmail.com)</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 2003, Martin Senger and EMBL-EBI. All Rights Reserved.</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1 id="DISCLAIMER">DISCLAIMER</h1>

<p>This software is provided &quot;as is&quot; without warranty of any kind.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<ul>

<li><p>http://www.ebi.ac.uk/Tools/webservices/soaplab/guide</p>

</li>
</ul>

<h1 id="APPENDIX">APPENDIX</h1>

<p>This is actually the main documentation...</p>

<p>If you try to call any of these methods directly on this <code><code>Bio::SimpleAnalysisI</code></code> object you will get a <i>not implemented</i> error message.</p>

<h2 id="analysis_name">analysis_name</h2>

<pre><code><code> <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$tool</span><span class="operator">-&gt;</span><span class="variable">analysis_name</span><span class="operator">;</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">a</span> <span class="variable">name</span> <span class="variable">of</span> <span class="variable">this</span> <span class="variable">analysis</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">none</span>
</code></code></pre>

<h2 id="analysis_spec">analysis_spec</h2>

<pre><code><code> <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$tool</span><span class="operator">-&gt;</span><span class="variable">analysis_spec</span><span class="operator">;</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">a</span> <span class="variable">hash</span> <span class="variable">reference</span> <span class="variable">describing</span> <span class="variable">this</span> <span class="variable">analysis</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">none</span>
</code></code></pre>

<p>The returned hash reference uses the following keys (not all of them always present, perhaps others present as well): <code><code>name</code></code>, <code><code>type</code></code>, <code><code>version</code></code>, <code><code>supplier</code></code>, <code><code>installation</code></code>, <code><code>description</code></code>.</p>

<h2 id="input_spec">input_spec</h2>

<pre><code><code> <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$tool</span><span class="operator">-&gt;</span><span class="variable">input_spec</span><span class="operator">;</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">an</span> <span class="variable">array</span> <span class="variable">reference</span> <span class="variable">with</span> <span class="variable">hashes</span> <span class="variable">as</span> <span class="variable">elements</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">none</span>
</code></code></pre>

<p>The analysis input data are named, and can be also associated with a default value, with allowed values and with few other attributes. The names are important for feeding the analysis with the input data (the inputs are given to methods <code><code>run</code></code> and <code><code>wait_for</code></code> as name/value pairs).</p>

<h2 id="result_spec">result_spec</h2>

<pre><code><code> <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$tool</span><span class="operator">-&gt;</span><span class="variable">result_spec</span><span class="operator">;</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">a</span> <span class="variable">hash</span> <span class="variable">reference</span> <span class="variable">with</span> <span class="variable">result</span> <span class="variable">names</span> <span class="variable">as</span> <span class="keyword">keys</span>
           <span class="keyword">and</span> <span class="variable">result</span> <span class="variable">types</span> <span class="variable">as</span> <span class="keyword">values</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">none</span>
</code></code></pre>

<p>An analysis can produce several results, or the same result in several different formats. All such results are named and can be retrieved using their names by metod <code><code>result</code></code>.</p>

<p>Here is an example of the result specification:</p>

<pre><code><code>  <span class="variable">$result_spec</span> <span class="operator">=</span> <span class="operator">{</span>
          <span class="string">'outseq'</span> <span class="operator">=&gt;</span> <span class="string">'String'</span><span class="operator">,</span>
          <span class="string">'report'</span> <span class="operator">=&gt;</span> <span class="string">'String'</span><span class="operator">,</span>
          <span class="string">'detailed_status'</span> <span class="operator">=&gt;</span> <span class="string">'String'</span>
        <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

<h2 id="run">run</h2>

<pre><code><code> Usage   : $tool-&gt;run ( [&#39;sequence=@my.seq&#39;, &#39;osformat=embl&#39;] )
 Returns : $self
 Args    : data and parameters for this execution
           (in various formats)</code></code></pre>

<p>Create a job, start it, and wait for its completion. The method is identical to the method <code><code>wait_for</code></code>. Why there are two methods doing the same? Because it is expected that the sub-classes may implement them differently (an example is an interface <code><code>Bio::AnalysisI</code></code> which uses method <code><code>run</code></code> for an asynchronous execution and method <code><code>wait_for</code></code> for a synchronous one.</p>

<p>Usually, after this call, you ask for results of the finished job:</p>

<pre><code><code>    <span class="variable">$analysis</span><span class="operator">-&gt;</span><span class="variable">run</span> <span class="operator">(...)-&gt;</span><span class="variable">result</span><span class="operator">;</span>
</code></code></pre>

<p>The input data and prameters for this execution can be specified in various ways:</p>

<dl>

<dt id="array-reference">array reference</dt>
<dd>

<p>The array has scalar elements of the form</p>

<pre><code><code>   name = [[@]value]</code></code></pre>

<p>where <code><code>name</code></code> is the name of an input data or input parameter (see method <code><code>input_spec</code></code> for finding what names are recognized by this analysis) and <code><code>value</code></code> is a value for this data/parameter. If <code><code>value</code></code> is missing a 1 is assumed (which is convenient for the boolean options). If <code><code>value</code></code> starts with <code><code>@</code></code> it is treated as a local filename, and its contents is used as the data/parameter value.</p>

</dd>
<dt id="hash-reference">hash reference</dt>
<dd>

<p>The same as with the array reference but now there is no need to use an equal sign. The hash keys are input names and hash values their data. The values can again start with a <code><code>@</code></code> sign indicating a local filename.</p>

</dd>
</dl>

<h2 id="wait_for">wait_for</h2>

<pre><code><code> <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$tool</span><span class="operator">-&gt;</span><span class="variable">wait_for</span> <span class="operator">(</span> <span class="operator">{</span> <span class="string">'sequence'</span> <span class="operator">=&gt;</span> <span class="string">'@my,file'</span> <span class="operator">}</span> <span class="operator">)</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">$self</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">the</span> <span class="variable">same</span> <span class="variable">as</span> <span class="keyword">for</span> <span class="variable">method</span> <span class="string">'run'</span>
</code></code></pre>

<p>Create a job, start it and wait for its completion. The method is identical to the method <code><code>run</code></code>. See details in the <code><code>run</code></code> method.</p>

<h2 id="status">status</h2>

<pre><code><code> Usage   : $tool-&gt;status
 Returns : string describing a status of the execution
 Args    : none</code></code></pre>

<p>It returns one of the following strings (and perhaps more if a server implementation extended possible job states):</p>

<pre><code><code>   CREATED              (not run yet)
   COMPLETED            (run and finished normally)
   TERMINATED_BY_ERROR  (run and finished with an error or a signal)</code></code></pre>

<h2 id="result">result</h2>

<pre><code><code> Usage   : $job-&gt;result (...)
 Returns : a result created by running an analysis
 Args    : none (but an implementation may choose
           to add arguments for instructions how to process
           the raw result)</code></code></pre>

<p>The method returns a scalar representing a result of an executed job. If the job was terminated by an error the result may contain an error message instead of the real data (or both, depending on the implementation).</p>


</body>

</html>


