<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Adaptors">Adaptors</a></li>
      <li><a href="#Serializers">Serializers</a></li>
      <li><a href="#Loaders-and-Normalized-Features">Loaders and Normalized Features</a></li>
    </ul>
  </li>
  <li><a href="#Methods-for-Connecting-and-Initializating-a-Database">Methods for Connecting and Initializating a Database</a>
    <ul>
      <li><a href="#new">new</a></li>
      <li><a href="#init_database">init_database</a></li>
      <li><a href="#post_init">post_init</a></li>
      <li><a href="#add_features">add_features</a></li>
      <li><a href="#store">store</a></li>
      <li><a href="#store_noindex">store_noindex</a></li>
      <li><a href="#no_blobs">no_blobs</a></li>
      <li><a href="#new_feature">new_feature</a></li>
      <li><a href="#delete">delete</a></li>
      <li><a href="#fetch-get_feature_by_id-get_feature_by_primary_id">fetch / get_feature_by_id / get_feature_by_primary_id</a></li>
      <li><a href="#fetch_many">fetch_many</a></li>
      <li><a href="#get_seq_stream">get_seq_stream</a></li>
      <li><a href="#get_features_by_name">get_features_by_name</a></li>
      <li><a href="#get_feature_by_name">get_feature_by_name</a></li>
      <li><a href="#get_features_by_alias">get_features_by_alias</a></li>
      <li><a href="#get_features_by_type">get_features_by_type</a></li>
      <li><a href="#get_features_by_location">get_features_by_location</a></li>
      <li><a href="#get_features_by_attribute">get_features_by_attribute</a></li>
      <li><a href="#features">features</a></li>
      <li><a href="#get_all_features">get_all_features</a></li>
      <li><a href="#seq_ids">seq_ids</a></li>
      <li><a href="#search_attributes">search_attributes</a></li>
      <li><a href="#search_notes">search_notes</a></li>
      <li><a href="#types">types</a></li>
      <li><a href="#insert_sequence">insert_sequence</a></li>
      <li><a href="#fetch_sequence">fetch_sequence</a></li>
      <li><a href="#segment">segment</a></li>
      <li><a href="#seqfeature_class">seqfeature_class</a></li>
      <li><a href="#reindex">reindex</a></li>
      <li><a href="#attributes">attributes</a></li>
      <li><a href="#start_bulk_update-finish_bulk_update">start_bulk_update,finish_bulk_update</a></li>
      <li><a href="#add_SeqFeature">add_SeqFeature</a></li>
      <li><a href="#fetch_SeqFeatures">fetch_SeqFeatures</a></li>
    </ul>
  </li>
  <li><a href="#Changing-the-Behavior-of-the-Database">Changing the Behavior of the Database</a>
    <ul>
      <li><a href="#debug">debug</a></li>
      <li><a href="#serializer">serializer</a></li>
      <li><a href="#dna_accessor">dna_accessor</a></li>
      <li><a href="#index_subfeatures">index_subfeatures</a></li>
      <li><a href="#clone">clone</a></li>
    </ul>
  </li>
  <li><a href="#TIE-Interface">TIE Interface</a>
    <ul>
      <li><a href="#init_database1">_init_database</a></li>
      <li><a href="#store1">_store</a></li>
      <li><a href="#fetch">_fetch</a></li>
      <li><a href="#fetch_many1">_fetch_many</a></li>
      <li><a href="#update_indexes">_update_indexes</a></li>
      <li><a href="#start_reindexing-_end_reindexing">_start_reindexing, _end_reindexing</a></li>
      <li><a href="#features1">_features</a></li>
      <li><a href="#search_attributes1">_search_attributes</a></li>
      <li><a href="#can_store_parentage">can_store_parentage</a></li>
      <li><a href="#add_SeqFeature1">_add_SeqFeature</a></li>
      <li><a href="#fetch_SeqFeatures1">_fetch_SeqFeatures</a></li>
      <li><a href="#insert_sequence1">_insert_sequence</a></li>
      <li><a href="#fetch_sequence1">_fetch_sequence</a></li>
      <li><a href="#seq_ids1">_seq_ids</a></li>
      <li><a href="#start_bulk_update-_finish_bulk_update">_start_bulk_update,_finish_bulk_update</a></li>
      <li><a href="#Optional-methods-needed-to-implement-full-TIEHASH-interface">Optional methods needed to implement full TIEHASH interface</a></li>
    </ul>
  </li>
  <li><a href="#Internal-Methods">Internal Methods</a>
    <ul>
      <li><a href="#new_instance">new_instance</a></li>
      <li><a href="#init">init</a></li>
      <li><a href="#default_settings">default_settings</a></li>
      <li><a href="#default_serializer">default_serializer</a></li>
      <li><a href="#setting">setting</a></li>
      <li><a href="#subfeatures_are_indexed">subfeatures_are_indexed</a></li>
      <li><a href="#subfeature_types_are_indexed">subfeature_types_are_indexed</a></li>
      <li><a href="#subfeature_locations_are_indexed">subfeature_locations_are_indexed</a></li>
      <li><a href="#setup_segment_args">setup_segment_args</a></li>
      <li><a href="#store_and_cache">store_and_cache</a></li>
      <li><a href="#init_cache">init_cache</a></li>
      <li><a href="#cache">cache</a></li>
      <li><a href="#load_class">load_class</a></li>
      <li><a href="#freeze">freeze</a></li>
      <li><a href="#thaw">thaw</a></li>
      <li><a href="#thaw_object">thaw_object</a></li>
      <li><a href="#feature_names">feature_names</a></li>
      <li><a href="#feature_summary">feature_summary</a></li>
      <li><a href="#coverage_array">coverage_array</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Bio::DB::SeqFeature::Store -- Storage and retrieval of sequence annotation data</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Bio::DB::SeqFeature::Store</span><span class="operator">;</span>
  
  <span class="comment"># Open the feature database</span>
  <span class="keyword">my</span> <span class="variable">$db</span> <span class="operator">=</span> <span class="variable">Bio::DB::SeqFeature::Store</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">-adaptor</span> <span class="operator">=&gt;</span> <span class="string">'DBI::mysql'</span><span class="operator">,</span>
                                            <span class="string">-dsn</span>     <span class="operator">=&gt;</span> <span class="string">'dbi:mysql:test'</span><span class="operator">,</span>
                                            <span class="string">-create</span>  <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">);</span>
  
  <span class="comment"># Get a feature from somewhere</span>
  <span class="keyword">my</span> <span class="variable">$feature</span> <span class="operator">=</span> <span class="variable">Bio::SeqFeature::Generic</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(...);</span>
  
  <span class="comment"># Store it</span>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">store</span><span class="operator">(</span><span class="variable">$feature</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Couldn't store!"</span><span class="operator">;</span>
  
  <span class="comment"># If absent, a primary ID is added to the feature when it is stored in the</span>
  <span class="comment"># database. Retrieve the primary ID</span>
  <span class="keyword">my</span> <span class="variable">$id</span> <span class="operator">=</span> <span class="variable">$feature</span><span class="operator">-&gt;</span><span class="variable">primary_id</span><span class="operator">;</span>
  
  <span class="comment"># Get the feature back out</span>
  <span class="keyword">my</span> <span class="variable">$feature</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">fetch</span><span class="operator">(</span><span class="variable">$id</span><span class="operator">);</span>
  
  <span class="comment"># .... which is identical to</span>
  <span class="keyword">my</span> <span class="variable">$feature</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_feature_by_primary_id</span><span class="operator">(</span><span class="variable">$id</span><span class="operator">);</span>
  
  <span class="comment"># Change the feature and update it</span>
  <span class="variable">$f</span><span class="operator">-&gt;</span><span class="variable">start</span><span class="operator">(</span><span class="number">100</span><span class="operator">);</span>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">store</span><span class="operator">(</span><span class="variable">$f</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Couldn't update!"</span><span class="operator">;</span>
  
  <span class="comment"># Get all features at once</span>
  <span class="keyword">my</span> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span> <span class="operator">);</span>
  
  <span class="comment"># Retrieve multiple features by primary id</span>
  <span class="keyword">my</span> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">fetch_many</span><span class="operator">(</span><span class="variable">@list_of_ids</span><span class="operator">);</span>
  
  <span class="comment"># ...by name</span>
  <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_features_by_name</span><span class="operator">(</span><span class="string">'ZK909'</span><span class="operator">);</span>
  
  <span class="comment"># ...by alias</span>
  <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_features_by_alias</span><span class="operator">(</span><span class="string">'sma-3'</span><span class="operator">);</span>
  
  <span class="comment"># ...by type</span>
  <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_features_by_type</span><span class="operator">(</span><span class="string">'gene'</span><span class="operator">);</span>
  
  <span class="comment"># ...by location</span>
  <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_features_by_location</span><span class="operator">(</span><span class="string">-seq_id</span><span class="operator">=&gt;</span><span class="string">'Chr1'</span><span class="operator">,</span><span class="string">-start</span><span class="operator">=&gt;</span><span class="number">4000</span><span class="operator">,</span><span class="string">-end</span><span class="operator">=&gt;</span><span class="number">600000</span><span class="operator">);</span>
  
  <span class="comment"># ...by attribute</span>
  <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_features_by_attribute</span><span class="operator">(</span><span class="operator">{</span><span class="string">description</span> <span class="operator">=&gt;</span> <span class="string">'protein kinase'</span><span class="operator">}</span><span class="operator">)</span>
  
  <span class="comment"># ...by the GFF "Note" field</span>
  <span class="variable">@result_list</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">search_notes</span><span class="operator">(</span><span class="string">'kinase'</span><span class="operator">);</span>
  
  <span class="comment"># ...by arbitrary combinations of selectors</span>
  <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">-name</span> <span class="operator">=&gt;</span> <span class="variable">$name</span><span class="operator">,</span>
                            <span class="string">-type</span> <span class="operator">=&gt;</span> <span class="variable">$types</span><span class="operator">,</span>
                            <span class="string">-seq_id</span> <span class="operator">=&gt;</span> <span class="variable">$seqid</span><span class="operator">,</span>
                            <span class="string">-start</span>  <span class="operator">=&gt;</span> <span class="variable">$start</span><span class="operator">,</span>
                            <span class="string">-end</span>    <span class="operator">=&gt;</span> <span class="variable">$end</span><span class="operator">,</span>
                            <span class="string">-attributes</span> <span class="operator">=&gt;</span> <span class="variable">$attributes</span><span class="operator">);</span>
  
  <span class="comment"># Loop through the features using an iterator</span>
  <span class="keyword">my</span> <span class="variable">$iterator</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_seq_stream</span><span class="operator">(</span><span class="string">-name</span> <span class="operator">=&gt;</span> <span class="variable">$name</span><span class="operator">,</span>
                                     <span class="string">-type</span> <span class="operator">=&gt;</span> <span class="variable">$types</span><span class="operator">,</span>
                                     <span class="string">-seq_id</span> <span class="operator">=&gt;</span> <span class="variable">$seqid</span><span class="operator">,</span>
                                     <span class="string">-start</span>  <span class="operator">=&gt;</span> <span class="variable">$start</span><span class="operator">,</span>
                                     <span class="string">-end</span>    <span class="operator">=&gt;</span> <span class="variable">$end</span><span class="operator">,</span>
                                     <span class="string">-attributes</span> <span class="operator">=&gt;</span> <span class="variable">$attributes</span><span class="operator">);</span>
  
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$feature</span> <span class="operator">=</span> <span class="variable">$iterator</span><span class="operator">-&gt;</span><span class="variable">next_seq</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="comment"># do something with the feature</span>
  <span class="operator">}</span>
  
  <span class="comment"># ...limiting the search to a particular region</span>
  <span class="keyword">my</span> <span class="variable">$segment</span>  <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="string">'Chr1'</span><span class="operator">,</span><span class="number">5000</span><span class="operator">=&gt;</span><span class="number">6000</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">-type</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="string">'mRNA'</span><span class="operator">,</span><span class="string">'match'</span><span class="operator">]</span><span class="operator">);</span>
  
  <span class="comment"># Getting coverage statistics across a region</span>
  <span class="keyword">my</span> <span class="variable">$summary</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">feature_summary</span><span class="operator">(</span><span class="string">'Chr1'</span><span class="operator">,</span><span class="number">10_000</span><span class="operator">=&gt;</span><span class="number">1_110_000</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$bins</span><span class="operator">)</span>  <span class="operator">=</span> <span class="variable">$summary</span><span class="operator">-&gt;</span><span class="variable">get_tag_values</span><span class="operator">(</span><span class="string">'coverage'</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$first_bin</span> <span class="operator">=</span> <span class="variable">$bins</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
  
  <span class="comment"># Getting &amp; storing sequence information</span>
  <span class="comment"># Warning: this returns a string, and not a PrimarySeq object</span>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">insert_sequence</span><span class="operator">(</span><span class="string">'Chr1'</span><span class="operator">,</span><span class="string">'GATCCCCCGGGATTCCAAAA...'</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$sequence</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">fetch_sequence</span><span class="operator">(</span><span class="string">'Chr1'</span><span class="operator">,</span><span class="number">5000</span><span class="operator">=&gt;</span><span class="number">6000</span><span class="operator">);</span>
  
  <span class="comment"># What feature types are defined in the database?</span>
  <span class="keyword">my</span> <span class="variable">@types</span>    <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">types</span><span class="operator">;</span>
  
  <span class="comment"># Create a new feature in the database</span>
  <span class="keyword">my</span> <span class="variable">$feature</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">new_feature</span><span class="operator">(</span><span class="string">-primary_tag</span> <span class="operator">=&gt;</span> <span class="string">'mRNA'</span><span class="operator">,</span>
                                 <span class="string">-seq_id</span>      <span class="operator">=&gt;</span> <span class="string">'chr3'</span><span class="operator">,</span>
                                 <span class="string">-start</span>      <span class="operator">=&gt;</span> <span class="number">10000</span><span class="operator">,</span>
                                 <span class="string">-end</span>        <span class="operator">=&gt;</span> <span class="number">11000</span><span class="operator">);</span>
  
  <span class="comment"># Load an entire GFF3 file, using the GFF3 loader...</span>
  <span class="keyword">my</span> <span class="variable">$loader</span> <span class="operator">=</span> <span class="variable">Bio::DB::SeqFeature::Store::GFF3Loader</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">-store</span>    <span class="operator">=&gt;</span> <span class="variable">$db</span><span class="operator">,</span>
                                                           <span class="string">-verbose</span>  <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span>
                                                           <span class="string">-fast</span>     <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">);</span>
  
  <span class="variable">$loader</span><span class="operator">-&gt;</span><span class="variable">load</span><span class="operator">(</span><span class="string">'./my_genome.gff3'</span><span class="operator">);</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Bio::DB::SeqFeature::Store implements the Bio::SeqFeature::CollectionI interface to allow you to persistently store Bio::SeqFeatureI objects in a database and to later to retrieve them by a variety of searches. This module is similar to the older Bio::DB::GFF module, with the following differences:</p>

<ol>

<li><p>No limitation on Bio::SeqFeatureI implementations</p>

<p>Unlike Bio::DB::GFF, Bio::DB::SeqFeature::Store works with any Bio::SeqFeatureI object.</p>

</li>
<li><p>No limitation on nesting of features &amp; subfeatures</p>

<p>Bio::DB::GFF is limited to features that have at most one level of subfeature. Bio::DB::SeqFeature::Store can work with features that have unlimited levels of nesting.</p>

</li>
<li><p>No aggregators</p>

<p>The aggregator architecture, which was necessary to impose order on the GFF2 files that Bio::DB::GFF works with, does not apply to Bio::DB::SeqFeature::Store. It is intended to store features that obey well-defined ontologies, such as the Sequence Ontology (http://song.sourceforge.net).</p>

</li>
<li><p>No relative locations</p>

<p>All locations defined by this module are relative to an absolute sequence ID, unlike Bio::DB::GFF which allows you to define the location of one feature relative to another.</p>

</li>
</ol>

<p>We&#39;ll discuss major concepts in Bio::DB::SeqFeature::Store and then describe how to use the module.</p>

<h2 id="Adaptors">Adaptors</h2>

<p>Bio::DB::SeqFeature::Store is designed to work with a variety of storage back ends called &quot;adaptors.&quot; Adaptors are subclasses of Bio::DB::SeqFeature::Store and provide the interface between the store() and fetch() methods and the physical database. Currently the number of adaptors is quite limited, but the number will grow soon.</p>

<dl>

<dt id="memory">memory</dt>
<dd>

<p>An implementation that stores all data in memory. This is useful for small data sets of no more than 10,000 features (more or less, depending on system memory).</p>

</dd>
<dt id="DBI::mysql">DBI::mysql</dt>
<dd>

<p>A full-featured implementation on top of the MySQL relational database system.</p>

</dd>
<dt id="berkeleydb">berkeleydb</dt>
<dd>

<p>A full-feature implementation that runs on top of the BerkeleyDB database. See <a href="../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/SeqFeature/Store/berkeleydb.html">Bio::DB::SeqFeature::Store::berkeleydb</a>.</p>

</dd>
</dl>

<p>If you do not explicitly specify the adaptor, then DBI::mysql will be used by default.</p>

<h2 id="Serializers">Serializers</h2>

<p>When Bio::DB::SeqFeature::Store stores a Bio::SeqFeatureI object into the database, it serializes it into binary or text form. When it later fetches the feature from the database, it unserializes it. Two serializers are available: Recent versions of</p>

<dl>

<dt id="Storable">Storable</dt>
<dd>

<p>This is a fast binary serializer. It is available in Perl versions 5.8.7 and higher and is used when available.</p>

</dd>
<dt id="Data::Dumper">Data::Dumper</dt>
<dd>

<p>This is a slow text serializer that is available in Perl 5.8.0 and higher. It is used when Storable is unavailable.</p>

</dd>
</dl>

<p>If you do not specify the serializer, then Storable will be used if available; otherwise Data::Dumper.</p>

<h2 id="Loaders-and-Normalized-Features">Loaders and Normalized Features</h2>

<p>The Bio::DB::SeqFeature::Store::GFF3Loader parses a GFF3-format file and loads the annotations and sequence data into the database of your choice. The script bp_seqfeature_load.pl (found in the scripts/Bio-SeqFeature-Store/ subdirectory) is a thin front end to the GFF3Loader. Other loaders may be written later.</p>

<p>Although Bio::DB::SeqFeature::Store should work with any Bio::SeqFeatureI object, there are some disadvantages to using Bio::SeqFeature::Generic and other vanilla implementations. The major issue is that if two vanilla features share the same subfeature (e.g. two transcripts sharing an exon), the shared subfeature will be cloned when stored into the database.</p>

<p>The special-purpose <a href="../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/SeqFeature.html">Bio::DB::SeqFeature</a> class is able to normalize its subfeatures in the database, so that shared subfeatures are stored only once. This minimizes wasted storage space. In addition, when in-memory caching is turned on, each shared subfeature will usually occupy only a single memory location upon restoration.</p>

<h1 id="Methods-for-Connecting-and-Initializating-a-Database">Methods for Connecting and Initializating a Database</h1>

<p>## TODO: http://iowg.brcdevel.org/gff3.html#a_fasta is a dead link</p>

<h2 id="new">new</h2>

<pre><code><code> Title   : new
 Usage   : $db = Bio::DB::SeqFeature::Store-&gt;new(@options)
 Function: connect to a database
 Returns : A descendent of Bio::DB::Seqfeature::Store
 Args    : several - see below
 Status  : public</code></code></pre>

<p>This class method creates a new database connection. The following -name=&gt;$value arguments are accepted:</p>

<pre><code><code> Name               Value
 ----               -----

 -adaptor           The name of the Adaptor class (default DBI::mysql)

 -serializer        The name of the serializer class (default Storable)

 -index_subfeatures Whether or not to make subfeatures searchable
                    (default false)

 -cache             Activate LRU caching feature -- size of cache

 -compress          Compresses features before storing them in database
                    using Compress::Zlib

 -create            (Re)initialize the database.</code></code></pre>

<p>The <b>-index_subfeatures</b> argument, if true, tells the module to create indexes for a feature and all its subfeatures (and its subfeatures&#39; subfeatures). Indexing subfeatures means that you will be able to search for the gene, its mRNA subfeatures and the exons inside each mRNA. It also means when you search the database for all features contained within a particular location, you will get the gene, the mRNAs and all the exons as individual objects as well as subfeatures of each other. NOTE: this option is only honored when working with a normalized feature class such as Bio::DB::SeqFeature.</p>

<p>The <b>-cache</b> argument, if true, tells the module to try to create a LRU (least-recently-used) object cache using the Tie::Cacher module. Caching will cause two objects that share the same primary_id to (often, but not always) share the same memory location, and may improve performance modestly. The argument is taken as the desired size for the cache. If you pass &quot;1&quot; as the cache value, a reasonable default cache size will be chosen. Caching requires the Tie::Cacher module to be installed. If the module is not installed, then caching will silently be disabled.</p>

<p>The <b>-compress</b> argument, if true, will cause the feature data to be compressed before storing it. This will make the database somewhat smaller at the cost of decreasing performance.</p>

<p>The <b>-create</b> argument, if true, will either initialize or reinitialize the database. It is needed the first time a database is used.</p>

<p>The new() method of individual adaptors recognize additional arguments. The default DBI::mysql adaptor recognizes the following ones:</p>

<pre><code><code> Name               Value
 ----               -----

 -dsn               DBI data source (default dbi:mysql:test)

 -autoindex         A flag that controls whether or not to update
                    all search indexes whenever a feature is stored
                    or updated (default true).

 -namespace         A string that will be used to qualify each table,
                    thereby allowing you to store several independent
                    sequence feature databases in a single Mysql
                    database.

 -dumpdir           The path to a temporary directory that will be
                    used during &quot;fast&quot; loading. See
                    L&lt;Bio::DB::SeqFeature::Store::GFF3Loader&gt; for a
                    description of this. Default is the current
                    directory.

 -write             Make the database writable (implied by -create)

 -fasta             Provide an alternative DNA accessor object or path.</code></code></pre>

<p>By default the database will store DNA sequences internally. However, you may override this behavior by passing either a path to a FASTA file, or any Perl object that recognizes the seq($seqid,$start,$end) method. In the former case, the FASTA path will be passed to Bio::DB::Fasta, possibly causing an index to be constructed. Suitable examples of the latter type of object include the Bio::DB::Sam and Bio::DB::Sam::Fai classes.</p>

<h2 id="init_database">init_database</h2>

<pre><code><code> Title   : init_database
 Usage   : $db-&gt;init_database([$erase_flag])
 Function: initialize a database
 Returns : true
 Args    : (optional) flag to erase current data
 Status  : public</code></code></pre>

<p>Call this after Bio::DB::SeqFeature::Store-&gt;new() to initialize a new database. In the case of a DBI database, this method installs the schema but does <b>not</b> create the database. You have to do this offline using the appropriate command-line tool. In the case of the &quot;berkeleydb&quot; adaptor, this creates an empty BTREE database.</p>

<p>If there is any data already in the database, init_database() called with no arguments will have no effect. To permanently erase the data already there and prepare to receive a fresh set of data, pass a true argument.</p>

<h2 id="post_init">post_init</h2>

<p>This method is invoked after init_database for use by certain adaptors (currently only the memory adaptor) to do automatic data loading after initialization. It is passed a copy of the init_database() args.</p>

<h2 id="add_features">add_features</h2>

<pre><code><code> Title   : add_features
 Usage   : $success = $db-&gt;add_features(\@features)
 Function: store one or more features into the database
 Returns : true if successful
 Args    : array reference of Bio::SeqFeatureI objects
 Status  : public</code></code></pre>

<h2 id="store">store</h2>

<pre><code><code> Title   : store
 Usage   : $success = $db-&gt;store(@features)
 Function: store one or more features into the database
 Returns : true if successful
 Args    : list of Bio::SeqFeatureI objects
 Status  : public</code></code></pre>

<p>This method stores a list of features into the database. Each feature is updated so that its primary_id becomes the primary ID of the serialized feature stored in the database. If all features were successfully stored, the method returns true. In the DBI implementation, the store is performed as a single transaction and the transaction is rolled back if one or more store operations failed.</p>

<p>In most cases, you should let the database assign the primary id. If the object you store already has a primary_id, then the ID must adhere to the datatype expected by the adaptor: an integer in the case of the various DB adaptors, and a string in the case of the memory and berkeley adaptors.</p>

<p>You can find out what the primary ID of the feature has become by calling the feature&#39;s primary_id() method:</p>

<pre><code><code>  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">store</span><span class="operator">(</span><span class="variable">$my_feature</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Oh darn"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$id</span> <span class="operator">=</span> <span class="variable">$my_feature</span><span class="operator">-&gt;</span><span class="variable">primary_id</span><span class="operator">;</span>
</code></code></pre>

<p>If the feature contains subfeatures, they will all be stored recursively. In the case of Bio::DB::SeqFeature and Bio::DB::SeqFeature::Store::NormalizedFeature, the subfeatures will be stored in a normalized way so that each subfeature appears just once in the database.</p>

<p>Subfeatures will be indexed for separate retrieval based on the current value of index_subfeatures().</p>

<p>If you call store() with one or more features that already have valid primary_ids, then any existing objects will be <b>replaced</b>. Note that when using normalized features such as Bio::DB::SeqFeature, the subfeatures are not recursively updated when you update the parent feature. You must manually update each subfeatures that has changed.</p>

<h2 id="store_noindex">store_noindex</h2>

<pre><code><code> Title   : store_noindex
 Usage   : $success = $db-&gt;store_noindex(@features)
 Function: store one or more features into the database without indexing
 Returns : true if successful
 Args    : list of Bio::SeqFeatureI objects
 Status  : public</code></code></pre>

<p>This method stores a list of features into the database but does not make them searchable. The only way to access the features is via their primary IDs. This method is ordinarily only used internally to store subfeatures that are not indexed.</p>

<h2 id="no_blobs">no_blobs</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">no_blobs</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">no_blobs</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">decide</span> <span class="keyword">if</span> <span class="variable">objects</span> <span class="variable">should</span> <span class="variable">be</span> <span class="variable">stored</span> <span class="variable">in</span> <span class="variable">the</span> <span class="variable">database</span> <span class="variable">as</span> <span class="variable">blobs</span><span class="operator">.</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">boolean</span> <span class="operator">(</span><span class="keyword">default</span> <span class="variable">false</span><span class="operator">)</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">boolean</span> <span class="operator">(</span><span class="variable">true</span> <span class="variable">to</span> <span class="keyword">no</span> <span class="variable">longer</span> <span class="variable">store</span> <span class="variable">objects</span><span class="operator">;</span> <span class="keyword">when</span> <span class="variable">the</span> <span class="variable">corresponding</span>
           <span class="variable">feature</span> <span class="variable">is</span> <span class="variable">retrieved</span> <span class="variable">it</span> <span class="variable">will</span> <span class="variable">instead</span> <span class="variable">be</span> <span class="variable">a</span> <span class="variable">minimal</span> <span class="variable">representation</span> <span class="variable">of</span>
           <span class="variable">the</span> <span class="variable">object</span> <span class="variable">that</span> <span class="variable">was</span> <span class="variable">stored</span><span class="operator">,</span> <span class="variable">as</span> <span class="variable">some</span> <span class="variable">simple</span> <span class="variable">Bio::SeqFeatureI</span> <span class="variable">object</span><span class="operator">)</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">dubious</span> <span class="operator">(</span><span class="variable">new</span><span class="operator">)</span>
</code></code></pre>

<p>This method saves lots of space in the database, which may in turn lead to large performance increases in extreme cases (over 7 million features in the db).</p>

<h2 id="new_feature">new_feature</h2>

<pre><code><code> Title   : new_feature
 Usage   : $feature = $db-&gt;new_feature(@args)
 Function: create a new Bio::DB::SeqFeature object in the database
 Returns : the new seqfeature
 Args    : see below
 Status  : public</code></code></pre>

<p>This method creates and stores a new Bio::SeqFeatureI object using the specialized Bio::DB::SeqFeature class. This class is able to store its subfeatures in a normalized fashion, allowing subfeatures to be shared among multiple parents (e.g. multiple exons shared among several mRNAs).</p>

<p>The arguments are the same as for Bio::DB::SeqFeature-&gt;new(), which in turn are similar to Bio::SeqFeature::Generic-&gt;new() and Bio::Graphics::Feature-&gt;new(). The most important difference is the <b>-index</b> option, which controls whether the feature will be indexed for retrieval (default is true). Ordinarily, you would only want to turn indexing off when creating subfeatures, because features stored without indexes will only be reachable via their primary IDs or their parents.</p>

<p>Arguments are as follows:</p>

<pre><code><code>  -seq_id       the reference sequence
  -start        the start position of the feature
  -end          the stop position of the feature
  -display_name the feature name (returned by seqname)
  -primary_tag  the feature type (returned by primary_tag)
  -source       the source tag
  -score        the feature score (for GFF compatibility)
  -desc         a description of the feature
  -segments     a list of subfeatures (see Bio::Graphics::Feature)
  -subtype      the type to use when creating subfeatures
  -strand       the strand of the feature (one of -1, 0 or +1)
  -phase        the phase of the feature (0..2)
  -url          a URL to link to when rendered with Bio::Graphics
  -attributes   a hashref of tag value attributes, in which the key is the tag
                  and the value is an array reference of values
  -index        index this feature if true</code></code></pre>

<p>Aliases:</p>

<pre><code><code>  -id           an alias for -display_name
  -seqname      an alias for -display_name
  -display_id   an alias for -display_name
  -name         an alias for -display_name
  -stop         an alias for end
  -type         an alias for primary_tag</code></code></pre>

<p>You can change the seqfeature implementation generated by new() by passing the name of the desired seqfeature class to $db-&gt;seqfeature_class().</p>

<h2 id="delete">delete</h2>

<pre><code><code> Title   : delete
 Usage   : $success = $db-&gt;delete(@features)
 Function: delete a list of feature from the database
 Returns : true if successful
 Args    : list of features
 Status  : public</code></code></pre>

<p>This method looks up the primary IDs from a list of features and deletes them from the database, returning true if all deletions are successful.</p>

<p>WARNING: The current DBI::mysql implementation has some issues that need to be resolved, namely (1) normalized subfeatures are NOT recursively deleted; and (2) the deletions are not performed in a transaction.</p>

<h2 id="fetch-get_feature_by_id-get_feature_by_primary_id">fetch / get_feature_by_id / get_feature_by_primary_id</h2>

<pre><code><code> Title   : fetch
           get_feature_by_id
           get_feature_by_primary_id
 Usage   : $feature = $db-&gt;fetch($primary_id)
 Function: fetch a feature from the database using its primary ID
 Returns : a feature
 Args    : primary ID of desired feature
 Status  : public</code></code></pre>

<p>This method returns a previously-stored feature from the database using its primary ID. If the primary ID is invalid, it returns undef. Use fetch_many() to rapidly retrieve multiple features.</p>

<h2 id="fetch_many">fetch_many</h2>

<pre><code><code> Title   : fetch_many
 Usage   : @features = $db-&gt;fetch_many($primary_id,$primary_id,$primary_id...)
 Function: fetch many features from the database using their primary ID
 Returns : list of features
 Args    : a list of primary IDs or an array ref of primary IDs
 Status  : public</code></code></pre>

<p>Same as fetch() except that you can pass a list of primary IDs or a ref to an array of IDs.</p>

<h2 id="get_seq_stream">get_seq_stream</h2>

<pre><code><code> Title   : get_seq_stream
 Usage   : $iterator = $db-&gt;get_seq_stream(@args)
 Function: return an iterator across all features in the database
 Returns : a Bio::DB::SeqFeature::Store::Iterator object
 Args    : feature filters (optional)
 Status  : public</code></code></pre>

<p>When called without any arguments this method will return an iterator object that will traverse all indexed features in the database. Call the iterator&#39;s next_seq() method to step through them (in no particular order):</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$iterator</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_seq_stream</span><span class="operator">;</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$feature</span> <span class="operator">=</span> <span class="variable">$iterator</span><span class="operator">-&gt;</span><span class="variable">next_seq</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="variable">$feature</span><span class="operator">-&gt;</span><span class="variable">primary_tag</span><span class="operator">,</span><span class="string">' '</span><span class="operator">,</span><span class="variable">$feature</span><span class="operator">-&gt;</span><span class="variable">display_name</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>You can select a subset of features by passing a series of filter arguments. The arguments are identical to those accepted by $db-&gt;features().</p>

<h2 id="get_features_by_name">get_features_by_name</h2>

<pre><code><code> Title   : get_features_by_name
 Usage   : @features = $db-&gt;get_features_by_name($name)
 Function: looks up features by their display_name
 Returns : a list of matching features
 Args    : the desired name
 Status  : public</code></code></pre>

<p>This method searches the display_name of all features for matches against the provided name. GLOB style wildcares (&quot;*&quot;, &quot;?&quot;) are accepted, but may be slow.</p>

<p>The method returns the list of matches, which may be zero, 1 or more than one features. Be prepared to receive more than one result, as display names are not guaranteed to be unique.</p>

<p>For backward compatibility with gbrowse, this method is also known as get_feature_by_name().</p>

<h2 id="get_feature_by_name">get_feature_by_name</h2>

<pre><code><code> Title   : get_feature_by_name
 Usage   : @features = $db-&gt;get_feature_by_name($name)
 Function: looks up features by their display_name
 Returns : a list of matching features
 Args    : the desired name
 Status  : Use get_features_by_name instead.</code></code></pre>

<p>This method is provided for backward compatibility with gbrowse.</p>

<h2 id="get_features_by_alias">get_features_by_alias</h2>

<pre><code><code> Title   : get_features_by_alias
 Usage   : @features = $db-&gt;get_features_by_alias($name)
 Function: looks up features by their display_name or alias
 Returns : a list of matching features
 Args    : the desired name
 Status  : public</code></code></pre>

<p>This method is similar to get_features_by_name() except that it will also search through the feature aliases. Aliases can be created by storing features that contain one or more Alias tags. Wildards are accepted.</p>

<h2 id="get_features_by_type">get_features_by_type</h2>

<pre><code><code> Title   : get_features_by_type
 Usage   : @features = $db-&gt;get_features_by_type(@types)
 Function: looks up features by their primary_tag
 Returns : a list of matching features
 Args    : list of primary tags
 Status  : public</code></code></pre>

<p>This method will return a list of features that have any of the primary tags given in the argument list. For compatibility with gbrowse and Bio::DB::GFF, types can be qualified using a colon:</p>

<pre><code><code>  primary_tag:source_tag</code></code></pre>

<p>in which case only features that match both the primary_tag <b>and</b> the indicated source_tag will be returned. If the database was loaded from a GFF3 file, this corresponds to the third and second columns of the row, in that order.</p>

<p>For example, given the GFF3 lines:</p>

<pre><code><code>  ctg123 geneFinder exon 1300 1500 . + . ID=exon001
  ctg123 fgenesH    exon 1300 1520 . + . ID=exon002</code></code></pre>

<p>exon001 and exon002 will be returned by searching for type &quot;exon&quot;, but only exon001 will be returned by searching for type &quot;exon:fgenesH&quot;.</p>

<h2 id="get_features_by_location">get_features_by_location</h2>

<pre><code><code> Title   : get_features_by_location
 Usage   : @features = $db-&gt;get_features_by_location(@args)
 Function: looks up features by their location
 Returns : a list of matching features
 Args    : see below
 Status  : public</code></code></pre>

<p>This method fetches features based on a location range lookup. You call it using a positional list of arguments, or a list of (-argument=&gt;$value) pairs.</p>

<p>The positional form is as follows:</p>

<pre><code><code> $db-&gt;get_features_by_location($seqid [[,$start,]$end])</code></code></pre>

<p>The $seqid is the name of the sequence on which the feature resides, and start and end are optional endpoints for the match. If the endpoints are missing then any feature on the indicated seqid is returned.</p>

<p>Examples:</p>

<pre><code><code> <span class="variable">get_features_by_location</span><span class="operator">(</span><span class="string">'chr1'</span><span class="operator">);</span>      <span class="comment"># all features on chromosome 1</span>
 <span class="variable">get_features_by_location</span><span class="operator">(</span><span class="string">'chr1'</span><span class="operator">,</span><span class="number">5000</span><span class="operator">);</span> <span class="comment"># features between 5000 and the end</span>
 <span class="variable">get_features_by_location</span><span class="operator">(</span><span class="string">'chr1'</span><span class="operator">,</span><span class="number">5000</span><span class="operator">,</span><span class="number">8000</span><span class="operator">);</span> <span class="comment"># features between 5000 and 8000</span>
</code></code></pre>

<p>Location lookups are overlapping. A feature will be returned if it partially or completely overlaps the indicated range.</p>

<p>The named argument form gives you more control:</p>

<pre><code><code>  Argument       Value
  --------       -----

  -seq_id        The name of the sequence on which the feature resides
  -start         Start of the range
  -end           End of the range
  -strand        Strand of the feature
  -range_type    Type of range to search over</code></code></pre>

<p>The <b>-strand</b> argument, if present, can be one of &quot;0&quot; to find features that are on both strands, &quot;+1&quot; to find only plus strand features, and &quot;-1&quot; to find only minus strand features. Specifying a strand of undef is the same as not specifying this argument at all, and retrieves all features regardless of their strandedness.</p>

<p>The <b>-range_type</b> argument, if present, can be one of &quot;overlaps&quot; (the default), to find features whose positions overlap the indicated range, &quot;contains,&quot; to find features whose endpoints are completely contained within the indicated range, and &quot;contained_in&quot; to find features whose endpoints are both outside the indicated range.</p>

<h2 id="get_features_by_attribute">get_features_by_attribute</h2>

<pre><code><code> Title   : get_features_by_attribute
 Usage   : @features = $db-&gt;get_features_by_attribute(@args)
 Function: looks up features by their attributes/tags
 Returns : a list of matching features
 Args    : see below
 Status  : public</code></code></pre>

<p>This implements a simple tag filter. Pass a list of tag names and their values. The module will return a list of features whose tag names and values match. Tag names are case insensitive. If multiple tag name/value pairs are present, they will be ANDed together. To match any of a list of values, use an array reference for the value.</p>

<p>Examples:</p>

<pre><code><code> <span class="comment"># return all features whose "function" tag is "GO:0000123"</span>
 <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_features_by_attribute</span><span class="operator">(</span><span class="string">function</span> <span class="operator">=&gt;</span> <span class="string">'GO:0000123'</span><span class="operator">);</span>
 
 <span class="comment"># return all features whose "function" tag is "GO:0000123" or "GO:0000555"</span>
 <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_features_by_attribute</span><span class="operator">(</span><span class="string">function</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">'GO:0000123'</span><span class="operator">,</span><span class="string">'GO:0000555'</span><span class="operator">]</span><span class="operator">);</span>
 
 <span class="comment"># return all features whose "function" tag is "GO:0000123" or "GO:0000555"</span>
 <span class="comment"># and whose "confirmed" tag is 1</span>
 <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_features_by_attribute</span><span class="operator">(</span><span class="string">function</span>  <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">'GO:0000123'</span><span class="operator">,</span><span class="string">'GO:0000555'</span><span class="operator">]</span><span class="operator">,</span>
                                            <span class="string">confirmed</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">);</span>
</code></code></pre>

<h2 id="features">features</h2>

<pre><code><code> Title   : features
 Usage   : @features = $db-&gt;features(@args)
 Function: generalized query &amp; retrieval interface
 Returns : list of features
 Args    : see below
 Status  : Public</code></code></pre>

<p>This is the workhorse for feature query and retrieval. It takes a series of -name=&gt;$value arguments filter arguments. Features that match all the filters are returned.</p>

<pre><code><code>  Argument       Value
  --------       -----

 Location filters:
  -seq_id        Chromosome, contig or other DNA segment
  -seqid         Synonym for -seq_id
  -ref           Synonym for -seqid
  -start         Start of range
  -end           End of range
  -stop          Synonym for -end
  -strand        Strand
  -range_type    Type of range match (&#39;overlaps&#39;,&#39;contains&#39;,&#39;contained_in&#39;)

 Name filters:
  -name          Name of feature (may be a glob expression)
  -aliases       If true, match aliases as well as display names
  -class         Archaic argument for backward compatibility.
                  (-class=&gt;&#39;Clone&#39;,-name=&gt;&#39;ABC123&#39;) is equivalent
                  to (-name=&gt;&#39;Clone:ABC123&#39;)

 Type filters:
  -types         List of feature types (array reference) or one type (scalar)
  -type          Synonym for the above
  -primary_tag   Synonym for the above

  -attributes    Hashref of attribute=&gt;value pairs as per
                    get_features_by_attribute(). Multiple alternative values
                    can be matched by providing an array reference.
  -attribute     synonym for -attributes</code></code></pre>

<p>You may also provide features() with a list of scalar values (the first element of which must <b>not</b> begin with a dash), in which case it will treat the list as a feature type filter.</p>

<p>Examples:</p>

<p>All features: @features = $db-&gt;features( );</p>

<p>All features on chromosome 1:</p>

<pre><code><code> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">-seqid</span><span class="operator">=&gt;</span><span class="string">'Chr1'</span><span class="operator">);</span>
</code></code></pre>

<p>All features on chromosome 1 between 5000 and 6000:</p>

<pre><code><code> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">-seqid</span><span class="operator">=&gt;</span><span class="string">'Chr1'</span><span class="operator">,</span><span class="string">-start</span><span class="operator">=&gt;</span><span class="number">5000</span><span class="operator">,</span><span class="string">-end</span><span class="operator">=&gt;</span><span class="number">6000</span><span class="operator">);</span>
</code></code></pre>

<p>All mRNAs on chromosome 1 between 5000 and 6000:</p>

<pre><code><code> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">-seqid</span><span class="operator">=&gt;</span><span class="string">'Chr1'</span><span class="operator">,</span><span class="string">-start</span><span class="operator">=&gt;</span><span class="number">5000</span><span class="operator">,</span><span class="string">-end</span><span class="operator">=&gt;</span><span class="number">6000</span><span class="operator">,</span><span class="string">-types</span><span class="operator">=&gt;</span><span class="string">'mRNA'</span><span class="operator">);</span>
</code></code></pre>

<p>All confirmed mRNAs and repeats on chromosome 1 that overlap the range 5000..6000:</p>

<pre><code><code> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">-seqid</span>     <span class="operator">=&gt;</span> <span class="string">'Chr1'</span><span class="operator">,</span><span class="string">-start</span><span class="operator">=&gt;</span><span class="number">5000</span><span class="operator">,</span><span class="string">-end</span><span class="operator">=&gt;</span><span class="number">6000</span><span class="operator">,</span>
                           <span class="string">-types</span>     <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">'mRNA'</span><span class="operator">,</span><span class="string">'repeat'</span><span class="operator">]</span><span class="operator">,</span>
                           <span class="string">-attributes</span><span class="operator">=&gt;</span> <span class="operator">{</span><span class="string">confirmed</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span>
                          <span class="operator">);</span>
</code></code></pre>

<p>All confirmed mRNAs and repeats on chromosome 1 strictly contained within the range 5000..6000:</p>

<pre><code><code> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">-seqid</span>     <span class="operator">=&gt;</span> <span class="string">'Chr1'</span><span class="operator">,</span><span class="string">-start</span><span class="operator">=&gt;</span><span class="number">5000</span><span class="operator">,</span><span class="string">-end</span><span class="operator">=&gt;</span><span class="number">6000</span><span class="operator">,</span>
                           <span class="string">-types</span>     <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">'mRNA'</span><span class="operator">,</span><span class="string">'repeat'</span><span class="operator">]</span><span class="operator">,</span>
                           <span class="string">-attributes</span><span class="operator">=&gt;</span> <span class="operator">{</span><span class="string">confirmed</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span>
                           <span class="operator">-</span><span class="string">range_type</span> <span class="operator">=&gt;</span> <span class="string">'contained_in'</span><span class="operator">,</span>
                          <span class="operator">);</span>
</code></code></pre>

<p>All genes and repeats:</p>

<pre><code><code> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">'gene'</span><span class="operator">,</span><span class="string">'repeat_region'</span><span class="operator">);</span>
</code></code></pre>

<h2 id="get_all_features">get_all_features</h2>

<pre><code><code> Title   : get_all_features
 Usage   : @features = $db-&gt;get_all_features()
 Function: get all feature in the database
 Returns : list of features
 Args    : none
 Status  : Public</code></code></pre>

<h2 id="seq_ids">seq_ids</h2>

<pre><code><code> Title   : seq_ids
 Usage   : @ids = $db-&gt;seq_ids()
 Function: Return all sequence IDs contained in database
 Returns : list of sequence Ids
 Args    : none
 Status  : public</code></code></pre>

<h2 id="search_attributes">search_attributes</h2>

<pre><code><code> Title   : search_attributes
 Usage   : @result_list = $db-&gt;search_attributes(&quot;text search string&quot;,[$tag1,$tag2...],$limit)
 Function: Search attributes for keywords occurring in a text string
 Returns : array of results
 Args    : full text search string, array ref of attribute names, and an optional feature limit
 Status  : public</code></code></pre>

<p>Given a search string, this method performs a full-text search of the specified attributes and returns an array of results. You may pass a scalar attribute name to search the values of one attribute (e.g. &quot;Note&quot;) or you may pass an array reference to search inside multiple attributes ([&#39;Note&#39;,&#39;Alias&#39;,&#39;Parent&#39;]).Each row of the returned array is a arrayref containing the following fields:</p>

<pre><code><code>  column 1     The display name of the feature
  column 2     The text of the note
  column 3     A relevance score.
  column 4     The feature type
  column 5     The unique ID of the feature</code></code></pre>

<p>NOTE: This search will fail to find features that do not have a display name!</p>

<p>You can use fetch() or fetch_many() with the returned IDs to get to the features themselves.</p>

<h2 id="search_notes">search_notes</h2>

<pre><code><code> Title   : search_notes
 Usage   : @result_list = $db-&gt;search_notes(&quot;full text search string&quot;,$limit)
 Function: Search the notes for a text string
 Returns : array of results
 Args    : full text search string, and an optional feature limit
 Status  : public</code></code></pre>

<p>Given a search string, this method performs a full-text search of the &quot;Notes&quot; attribute and returns an array of results. Each row of the returned array is a arrayref containing the following fields:</p>

<pre><code><code>  column 1     The display_name of the feature, suitable for passing to get_feature_by_name()
  column 2     The text of the note
  column 3     A relevance score.
  column 4     The type</code></code></pre>

<p>NOTE: This is equivalent to $db-&gt;search_attributes(&#39;full text search string&#39;,&#39;Note&#39;,$limit). This search will fail to find features that do not have a display name!</p>

<h2 id="types">types</h2>

<pre><code><code> Title   : types
 Usage   : @type_list = $db-&gt;types
 Function: Get all the types in the database
 Returns : array of Bio::DB::GFF::Typename objects
 Args    : none
 Status  : public</code></code></pre>

<h2 id="insert_sequence">insert_sequence</h2>

<pre><code><code> Title   : insert_sequence
 Usage   : $success = $db-&gt;insert_sequence($seqid,$sequence_string,$offset)
 Function: Inserts sequence data into the database at the indicated offset
 Returns : true if successful
 Args    : see below
 Status  : public</code></code></pre>

<p>This method inserts the DNA or protein sequence fragment $sequence_string, identified by the ID $seq_id, into the database at the indicated offset $offset. It is used internally by the GFF3Loader to load sequence data from the files.</p>

<h2 id="fetch_sequence">fetch_sequence</h2>

<pre><code><code> Title   : fetch_sequence
 Usage   : $sequence = $db-&gt;fetch_sequence(-seq_id=&gt;$seqid,-start=&gt;$start,-end=&gt;$end)
 Function: Fetch the indicated subsequene from the database
 Returns : The sequence string (not a Bio::PrimarySeq object!)
 Args    : see below
 Status  : public</code></code></pre>

<p>This method retrieves a portion of the indicated sequence. The arguments are:</p>

<pre><code><code>  <span class="variable">Argument</span>       <span class="variable">Value</span>
  <span class="operator">--------</span>       <span class="operator">-----</span>
  <span class="operator">-</span><span class="variable">seq_id</span>        <span class="variable">Chromosome</span><span class="operator">,</span> <span class="variable">contig</span> <span class="keyword">or</span> <span class="variable">other</span> <span class="variable">DNA</span> <span class="variable">segment</span>
  <span class="operator">-</span><span class="variable">seqid</span>         <span class="variable">Synonym</span> <span class="keyword">for</span> <span class="operator">-</span><span class="variable">seq_id</span>
  <span class="operator">-</span><span class="variable">name</span>          <span class="variable">Synonym</span> <span class="keyword">for</span> <span class="operator">-</span><span class="variable">seq_id</span>
  <span class="operator">-</span><span class="variable">start</span>         <span class="variable">Start</span> <span class="variable">of</span> <span class="variable">range</span>
  <span class="operator">-</span><span class="variable">end</span>           <span class="variable">End</span> <span class="variable">of</span> <span class="variable">range</span>
  <span class="operator">-</span><span class="variable">class</span>         <span class="variable">Obsolete</span> <span class="variable">argument</span> <span class="variable">used</span> <span class="keyword">for</span> <span class="variable">Bio::DB::GFF</span> <span class="variable">compatibility</span><span class="operator">.</span> <span class="variable">If</span>
                  <span class="variable">specified</span> <span class="variable">will</span> <span class="variable">qualify</span> <span class="variable">the</span> <span class="variable">seq_id</span> <span class="variable">as</span> <span class="string">"</span><span class="variable">$class</span><span class="string">:</span><span class="variable">$seq_id</span><span class="string">"</span><span class="operator">.</span>
  <span class="operator">-</span><span class="variable">bioseq</span>        <span class="variable">Boolean</span> <span class="variable">flag</span><span class="operator">;</span> <span class="keyword">if</span> <span class="variable">true</span><span class="operator">,</span> <span class="variable">returns</span> <span class="variable">a</span> <span class="variable">Bio::PrimarySeq</span> <span class="variable">object</span> <span class="variable">instead</span>
                  <span class="variable">of</span> <span class="variable">a</span> <span class="variable">sequence</span> <span class="variable">string</span><span class="operator">.</span>
</code></code></pre>

<p>You can call fetch_sequence using the following shortcuts:</p>

<pre><code><code> <span class="variable">$seq</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">fetch_sequence</span><span class="operator">(</span><span class="string">'chr3'</span><span class="operator">);</span>  <span class="comment"># entire chromosome</span>
 <span class="variable">$seq</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">fetch_sequence</span><span class="operator">(</span><span class="string">'chr3'</span><span class="operator">,</span><span class="number">1000</span><span class="operator">);</span>        <span class="comment"># position 1000 to end of chromosome</span>
 <span class="variable">$seq</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">fetch_sequence</span><span class="operator">(</span><span class="string">'chr3'</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="number">5000</span><span class="operator">);</span>  <span class="comment"># position 1 to 5000</span>
 <span class="variable">$seq</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">fetch_sequence</span><span class="operator">(</span><span class="string">'chr3'</span><span class="operator">,</span><span class="number">1000</span><span class="operator">,</span><span class="number">5000</span><span class="operator">);</span>   <span class="comment"># positions 1000 to 5000</span>
</code></code></pre>

<h2 id="segment">segment</h2>

<pre><code><code> Title   : segment
 Usage   : $segment = $db-&gt;segment($seq_id [,$start] [,$end] [,$absolute])
 Function: restrict the database to a sequence range
 Returns : a Bio::DB::SeqFeature::Segment object
 Args    : sequence id, start and end ranges (optional)
 Status  : public</code></code></pre>

<p>This is a convenience method that can be used when you are interested in the contents of a particular sequence landmark, such as a contig. Specify the ID of a sequence or other landmark in the database and optionally a start and endpoint relative to that landmark. The method will look up the region and return a Bio::DB::SeqFeature::Segment object that spans it. You can then use this segment object to make location-restricted queries on the database.</p>

<p>Example:</p>

<pre><code><code> <span class="variable">$segment</span>  <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="string">'contig23'</span><span class="operator">,</span><span class="number">1</span><span class="operator">,</span><span class="number">1000</span><span class="operator">);</span>  <span class="comment"># first 1000 bp of contig23</span>
 <span class="keyword">my</span> <span class="variable">@mRNAs</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">'mRNA'</span><span class="operator">);</span>       <span class="comment"># all mRNAs that overlap segment</span>
</code></code></pre>

<p>Although you will usually want to fetch segments that correspond to physical sequences in the database, you can actually use any feature in the database as the sequence ID. The segment() method will perform a get_features_by_name() internally and then transform the feature into the appropriate coordinates.</p>

<p>The named feature should exist once and only once in the database. If it exists multiple times in the database and you attempt to call segment() in a scalar context, you will get an exception. A workaround is to call the method in a list context, as in:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$segment</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="string">'contig23'</span><span class="operator">,</span><span class="number">1</span><span class="operator">,</span><span class="number">1000</span><span class="operator">);</span>
</code></code></pre>

<p>or</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">@segments</span>  <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="string">'contig23'</span><span class="operator">,</span><span class="number">1</span><span class="operator">,</span><span class="number">1000</span><span class="operator">);</span>
</code></code></pre>

<p>However, having multiple same-named features in the database is often an indication of underlying data problems.</p>

<p>If the optional $absolute argument is a true value, then the specified coordinates are relative to the reference (absolute) coordinates.</p>

<h2 id="seqfeature_class">seqfeature_class</h2>

<pre><code><code> Title   : seqfeature_class
 Usage   : $classname = $db-&gt;seqfeature_class([$new_classname])
 Function: get or set the name of the Bio::SeqFeatureI class generated by new_feature()
 Returns : name of class
 Args    : new classname (optional)
 Status  : public</code></code></pre>

<h2 id="reindex">reindex</h2>

<pre><code><code> Title   : reindex
 Usage   : $db-&gt;reindex
 Function: reindex the database
 Returns : nothing
 Args    : nothing
 Status  : public</code></code></pre>

<p>This method will force the secondary indexes (name, location, attributes, feature types) to be recalculated. It may be useful to rebuild a corrupted database.</p>

<h2 id="attributes">attributes</h2>

<pre><code><code> Title   : attributes
 Usage   : @a = $db-&gt;attributes
 Function: Returns list of all known attributes
 Returns : Returns list of all known attributes
 Args    : nothing
 Status  : public</code></code></pre>

<h2 id="start_bulk_update-finish_bulk_update">start_bulk_update,finish_bulk_update</h2>

<pre><code><code> Title   : start_bulk_update,finish_bulk_update
 Usage   : $db-&gt;start_bulk_update
           $db-&gt;finish_bulk_update
 Function: Activate optimizations for large number of insertions/updates
 Returns : nothing
 Args    : nothing
 Status  : public</code></code></pre>

<p>With some adaptors (currently only the DBI::mysql adaptor), these methods signal the adaptor that a large number of insertions or updates are to be performed, and activate certain optimizations. These methods are called automatically by the Bio::DB::SeqFeature::Store::GFF3Loader module.</p>

<p>Example:</p>

<pre><code><code>  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">start_bulk_update</span><span class="operator">;</span>
  <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$f</span> <span class="operator">(</span><span class="variable">@features</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">store</span><span class="operator">(</span><span class="variable">$f</span><span class="operator">);</span>
  <span class="operator">}</span>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">finish_bulk_update</span><span class="operator">;</span>
</code></code></pre>

<h2 id="add_SeqFeature">add_SeqFeature</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">add_SeqFeature</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">add_SeqFeature</span><span class="operator">(</span><span class="variable">$parent</span><span class="operator">,</span><span class="variable">@children</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">store</span> <span class="variable">a</span> <span class="variable">parent</span><span class="operator">/</span><span class="variable">child</span> <span class="variable">relationship</span> <span class="variable">between</span> <span class="variable">a</span> <span class="variable">$parent</span> <span class="keyword">and</span> <span class="variable">@children</span>
           <span class="variable">features</span> <span class="variable">that</span> <span class="variable">are</span> <span class="variable">already</span> <span class="variable">stored</span> <span class="variable">in</span> <span class="variable">the</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">number</span> <span class="variable">of</span> <span class="variable">children</span> <span class="variable">successfully</span> <span class="variable">stored</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">parent</span> <span class="variable">feature</span> <span class="keyword">or</span> <span class="variable">primary</span> <span class="variable">ID</span> <span class="keyword">and</span> <span class="variable">children</span> <span class="variable">features</span> <span class="keyword">or</span> <span class="variable">primary</span> <span class="variable">IDs</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">OPTIONAL</span><span class="operator">;</span> <span class="variable">MAY</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTORS</span>
</code></code></pre>

<p>If can_store_parentage() returns true, then some store-aware features (e.g. Bio::DB::SeqFeature) will invoke this method to store feature/subfeature relationships in a normalized table.</p>

<h2 id="fetch_SeqFeatures">fetch_SeqFeatures</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">fetch_SeqFeatures</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">@children</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">fetch_SeqFeatures</span><span class="operator">(</span><span class="variable">$parent_feature</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="keyword">return</span> <span class="variable">the</span> <span class="variable">immediate</span> <span class="variable">subfeatures</span> <span class="variable">of</span> <span class="variable">the</span> <span class="variable">indicated</span> <span class="variable">feature</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">subfeatures</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">the</span> <span class="variable">parent</span> <span class="variable">feature</span> <span class="keyword">and</span> <span class="variable">an</span> <span class="variable">optional</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">children</span> <span class="variable">types</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">OPTIONAL</span><span class="operator">;</span> <span class="variable">MAY</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTORS</span>
</code></code></pre>

<p>If can_store_parentage() returns true, then some store-aware features (e.g. Bio::DB::SeqFeature) will invoke this method to retrieve feature/subfeature relationships from the database.</p>

<h1 id="Changing-the-Behavior-of-the-Database">Changing the Behavior of the Database</h1>

<p>These methods allow you to modify the behavior of the database.</p>

<h2 id="debug">debug</h2>

<pre><code><code> Title   : debug
 Usage   : $debug_flag = $db-&gt;debug([$new_flag])
 Function: set the debug flag
 Returns : current debug flag
 Args    : new debug flag
 Status  : public</code></code></pre>

<p>This method gets/sets a flag that turns on verbose progress messages. Currently this will not do very much.</p>

<h2 id="serializer">serializer</h2>

<pre><code><code> Title   : serializer
 Usage   : $serializer = $db-&gt;serializer([$new_serializer])
 Function: get/set the name of the serializer
 Returns : the name of the current serializer class
 Args    : (optional) the name of a new serializer
 Status  : public</code></code></pre>

<p>You can use this method to set the serializer, but do not attempt to change the serializer once the database is initialized and populated.</p>

<h2 id="dna_accessor">dna_accessor</h2>

<pre><code><code> Title   : dna_accessor
 Usage   : $dna_accessor = $db-&gt;dna_accessor([$new_dna_accessor])
 Function: get/set the name of the dna_accessor
 Returns : the current dna_accessor object, if any
 Args    : (optional) the dna_accessor object
 Status  : public</code></code></pre>

<p>You can use this method to request or set the DNA accessor.</p>

<h2 id="index_subfeatures">index_subfeatures</h2>

<pre><code><code> Title   : index_subfeatures
 Usage   : $flag = $db-&gt;index_subfeatures([$new_value])
 Function: flag whether to index subfeatures
 Returns : current value of the flag
 Args    : (optional) new value of the flag
 Status  : public</code></code></pre>

<p>If true, the store() method will add a searchable index to both the top-level feature and all its subfeatures, allowing the search functions to return features at any level of the containment hierarchy. If false, only the top level feature will be indexed, meaning that you will only be able to get at subfeatures by fetching the top-level feature and then traversing downward using get_SeqFeatures().</p>

<p>You are free to change this setting at any point during the creation and population of a database. One database can contain both indexed and unindexed subfeatures.</p>

<h2 id="clone">clone</h2>

<p>The clone() method should be used when you want to pass the Bio::DB::SeqFeature::Store object to a child process across a fork(). The child must call clone() before making any queries.</p>

<p>The default behavior is to do nothing, but adaptors that use the DBI interface may need to implement this in order to avoid database handle errors. See the dbi adaptor for an example.</p>

<h1 id="TIE-Interface">TIE Interface</h1>

<p>This module implements a full TIEHASH interface. The keys are the primary IDs of the features in the database. Example:</p>

<pre><code><code> <span class="keyword">tie</span> <span class="variable">%h</span><span class="operator">,</span><span class="string">'Bio::DB::SeqFeature::Store'</span><span class="operator">,</span><span class="string">-adaptor</span><span class="operator">=&gt;</span><span class="string">'DBI::mysql'</span><span class="operator">,</span><span class="string">-dsn</span><span class="operator">=&gt;</span><span class="string">'dbi:mysql:elegans'</span><span class="operator">;</span>
 <span class="variable">$h</span><span class="operator">{</span><span class="string">123</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$feature1</span><span class="operator">;</span>
 <span class="variable">$h</span><span class="operator">{</span><span class="string">124</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$feature2</span><span class="operator">;</span>
 <span class="keyword">print</span> <span class="variable">$h</span><span class="operator">{</span><span class="string">123</span><span class="operator">}</span><span class="operator">-&gt;</span><span class="variable">display_name</span><span class="operator">;</span>
</code></code></pre>

<h2 id="init_database1">_init_database</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_init_database</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$success</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_init_database</span><span class="operator">(</span><span class="operator">[</span><span class="variable">$erase</span><span class="operator">]</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">initialize</span> <span class="variable">an</span> <span class="variable">empty</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">true</span> <span class="variable">on</span> <span class="variable">success</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">optional</span> <span class="variable">boolean</span> <span class="variable">flag</span> <span class="variable">to</span> <span class="variable">erase</span> <span class="variable">contents</span> <span class="variable">of</span> <span class="variable">an</span> <span class="variable">existing</span> <span class="variable">database</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">ABSTRACT</span> <span class="variable">METHOD</span><span class="operator">;</span> <span class="variable">MUST</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">AN</span> <span class="variable">ADAPTOR</span>
</code></code></pre>

<p>This method is the back end for init_database(). It must be implemented by an adaptor that inherits from Bio::DB::SeqFeature::Store. It returns true on success. @features = $db-&gt;features(-seqid=&gt;&#39;Chr1&#39;);</p>

<h2 id="store1">_store</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_store</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$success</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_store</span><span class="operator">(</span><span class="variable">$indexed</span><span class="operator">,</span><span class="variable">@objects</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">store</span> <span class="variable">seqfeature</span> <span class="variable">objects</span> <span class="variable">into</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">true</span> <span class="variable">on</span> <span class="variable">success</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">a</span> <span class="variable">boolean</span> <span class="variable">flag</span> <span class="variable">indicating</span> <span class="variable">whether</span> <span class="variable">objects</span> <span class="variable">are</span> <span class="variable">to</span> <span class="variable">be</span> <span class="variable">indexed</span><span class="operator">,</span>
           <span class="keyword">and</span> <span class="variable">one</span> <span class="keyword">or</span> <span class="variable">more</span> <span class="variable">objects</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">ABSTRACT</span> <span class="variable">METHOD</span><span class="operator">;</span> <span class="variable">MUST</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">AN</span> <span class="variable">ADAPTOR</span>
</code></code></pre>

<p>This method is the back end for store() and store_noindex(). It should write the seqfeature objects into the database. If indexing is requested, the features should be indexed for query and retrieval. Otherwise the features should be stored without indexing (it is not required that adaptors respect this).</p>

<p>If the object has no primary_id (undef), then the object is written into the database and assigned a new primary_id. If the object already has a primary_id, then the system will perform an update, replacing whatever was there before.</p>

<p>In practice, the implementation will serialize each object using the freeze() method and then store it in the database under the corresponding primary_id. The object is then updated with the primary_id.</p>

<h2 id="fetch">_fetch</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_fetch</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$feature</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_fetch</span><span class="operator">(</span><span class="variable">$primary_id</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">fetch</span> <span class="variable">feature</span> <span class="variable">from</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">feature</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">primary</span> <span class="variable">id</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">ABSTRACT</span> <span class="variable">METHOD</span><span class="operator">;</span> <span class="variable">MUST</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">AN</span> <span class="variable">ADAPTOR</span>
</code></code></pre>

<p>This method is the back end for fetch(). It accepts a primary_id and returns a feature object. It must be implemented by the adaptor.</p>

<p>In practice, the implementation will retrieve the serialized Bio::SeqfeatureI object from the database and pass it to the thaw() method to unserialize it and synchronize the primary_id.</p>

<h2 id="fetch_many1">_fetch_many</h2>

<pre><code><code> Title   : _fetch_many
 Usage   : $feature = $db-&gt;_fetch_many(@primary_ids)
 Function: fetch many features from database
 Returns : feature
 Args    : primary id
 Status  : private -- does not need to be implemented</code></code></pre>

<p>This method fetches many features specified by a list of IDs. The default implementation simply calls _fetch() once for each primary_id. Implementors can override it if needed for efficiency.</p>

<h2 id="update_indexes">_update_indexes</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_update_indexes</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$success</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_update_indexes</span><span class="operator">(</span><span class="variable">$feature</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">update</span> <span class="variable">the</span> <span class="variable">indexes</span> <span class="keyword">for</span> <span class="variable">a</span> <span class="variable">feature</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">true</span> <span class="variable">on</span> <span class="variable">success</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">A</span> <span class="variable">seqfeature</span> <span class="variable">object</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">ABSTRACT</span> <span class="variable">METHOD</span><span class="operator">;</span> <span class="variable">MUST</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">AN</span> <span class="variable">ADAPTOR</span>
</code></code></pre>

<p>This method is called by reindex() to update the searchable indexes for a feature object that has changed.</p>

<h2 id="start_reindexing-_end_reindexing">_start_reindexing, _end_reindexing</h2>

<pre><code><code> Title   : _start_reindexing, _end_reindexing
 Usage   : $db-&gt;_start_reindexing()
           $db-&gt;_end_reindexing
 Function: flag that a series of reindexing operations is beginning/ending
 Returns : true on success
 Args    : none
 Status  : MAY BE IMPLEMENTED BY AN ADAPTOR (optional)</code></code></pre>

<p>These methods are called by reindex() before and immediately after a series of reindexing operations. The default behavior is to do nothing, but these methods can be overridden by an adaptor in order to perform optimizations, turn off autocommits, etc.</p>

<h2 id="features1">_features</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_features</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_features</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">back</span> <span class="variable">end</span> <span class="keyword">for</span> <span class="variable">all</span> <span class="variable">get_feature_by_</span><span class="operator">*()</span> <span class="variable">queries</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">features</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">see</span> <span class="variable">below</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">ABSTRACT</span> <span class="variable">METHOD</span><span class="operator">;</span> <span class="variable">MUST</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTOR</span>
</code></code></pre>

<p>This is the backend for features(), get_features_by_name(), get_features_by_location(), etc. Arguments are as described for the features() method, except that only the named-argument form is recognized.</p>

<h2 id="search_attributes1">_search_attributes</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_search_attributes</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">@result_list</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_search_attributes</span><span class="operator">(</span><span class="string">"text search string"</span><span class="operator">,</span><span class="operator">[</span><span class="variable">$tag1</span><span class="operator">,</span><span class="variable">$tag2</span><span class="operator">...</span><span class="operator">]</span><span class="operator">,</span><span class="variable">$limit</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">back</span> <span class="variable">end</span> <span class="keyword">for</span> <span class="variable">the</span> <span class="variable">search_attributes</span><span class="operator">()</span> <span class="variable">method</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">results</span> <span class="variable">list</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">as</span> <span class="variable">per</span> <span class="variable">search_attributes</span><span class="operator">()</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">ABSTRACT</span> <span class="variable">METHOD</span><span class="operator">;</span> <span class="variable">MUST</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTOR</span>
</code></code></pre>

<p>See search_attributes() for the format of the results list. The only difference between this and the public method is that the tag list is guaranteed to be an array reference.</p>

<h2 id="can_store_parentage">can_store_parentage</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">can_store_parentage</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$flag</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">can_store_parentage</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="keyword">return</span> <span class="variable">true</span> <span class="keyword">if</span> <span class="variable">this</span> <span class="variable">adaptor</span> <span class="variable">can</span> <span class="variable">store</span> <span class="variable">parent</span><span class="operator">/</span><span class="variable">child</span> <span class="variable">relationships</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">boolean</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">none</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">OPTIONAL</span><span class="operator">;</span> <span class="variable">MAY</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTORS</span>
</code></code></pre>

<p>Override this method and return true if this adaptor supports the _add_SeqFeature() and _get_SeqFeatures() methods, which are used for storing feature parent/child relationships in a normalized fashion. Default is false (parent/child relationships are stored in denormalized form in each feature).</p>

<h2 id="add_SeqFeature1">_add_SeqFeature</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_add_SeqFeature</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_add_SeqFeature</span><span class="operator">(</span><span class="variable">$parent</span><span class="operator">,</span><span class="variable">@children</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">store</span> <span class="variable">a</span> <span class="variable">parent</span><span class="operator">/</span><span class="variable">child</span> <span class="variable">relationship</span> <span class="variable">between</span> <span class="variable">$parent</span> <span class="keyword">and</span> <span class="variable">@children</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">number</span> <span class="variable">of</span> <span class="variable">children</span> <span class="variable">successfully</span> <span class="variable">stored</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">parent</span> <span class="variable">feature</span> <span class="keyword">and</span> <span class="variable">one</span> <span class="keyword">or</span> <span class="variable">more</span> <span class="variable">children</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">OPTIONAL</span><span class="operator">;</span> <span class="variable">MAY</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTORS</span>
</code></code></pre>

<p>If can_store_parentage() returns true, then some store-aware features (e.g. Bio::DB::SeqFeature) will invoke this method to store feature/subfeature relationships in a normalized table.</p>

<h2 id="fetch_SeqFeatures1">_fetch_SeqFeatures</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_fetch_SeqFeatures</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">@children</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_fetch_SeqFeatures</span><span class="operator">(</span><span class="variable">$parent_feature</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="keyword">return</span> <span class="variable">the</span> <span class="variable">immediate</span> <span class="variable">subfeatures</span> <span class="variable">of</span> <span class="variable">the</span> <span class="variable">indicated</span> <span class="variable">feature</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">subfeatures</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">the</span> <span class="variable">parent</span> <span class="variable">feature</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">OPTIONAL</span><span class="operator">;</span> <span class="variable">MAY</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTORS</span>
</code></code></pre>

<p>If can_store_parentage() returns true, then some store-aware features (e.g. Bio::DB::SeqFeature) will invoke this method to retrieve feature/subfeature relationships from the database.</p>

<h2 id="insert_sequence1">_insert_sequence</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_insert_sequence</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$success</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_insert_sequence</span><span class="operator">(</span><span class="variable">$seqid</span><span class="operator">,</span><span class="variable">$sequence_string</span><span class="operator">,</span><span class="variable">$offset</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">Inserts</span> <span class="variable">sequence</span> <span class="variable">data</span> <span class="variable">into</span> <span class="variable">the</span> <span class="variable">database</span> <span class="variable">at</span> <span class="variable">the</span> <span class="variable">indicated</span> <span class="variable">offset</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">true</span> <span class="keyword">if</span> <span class="variable">successful</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">see</span> <span class="variable">below</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">ABSTRACT</span> <span class="variable">METHOD</span><span class="operator">;</span> <span class="variable">MUST</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTOR</span>
</code></code></pre>

<p>This is the back end for insert_sequence(). Adaptors must implement this method in order to store and retrieve nucleotide or protein sequence.</p>

<h2 id="fetch_sequence1">_fetch_sequence</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_fetch_sequence</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$sequence</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_fetch_sequence</span><span class="operator">(</span><span class="string">-seq_id</span><span class="operator">=&gt;</span><span class="variable">$seqid</span><span class="operator">,</span><span class="string">-start</span><span class="operator">=&gt;</span><span class="variable">$start</span><span class="operator">,</span><span class="string">-end</span><span class="operator">=&gt;</span><span class="variable">$end</span><span class="operator">)</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">Fetch</span> <span class="variable">the</span> <span class="variable">indicated</span> <span class="variable">subsequence</span> <span class="variable">from</span> <span class="variable">the</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">The</span> <span class="variable">sequence</span> <span class="variable">string</span> <span class="operator">(</span><span class="keyword">not</span> <span class="variable">a</span> <span class="variable">Bio::PrimarySeq</span> <span class="variable">object</span><span class="operator">!)</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">see</span> <span class="variable">below</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">ABSTRACT</span> <span class="variable">METHOD</span><span class="operator">;</span> <span class="variable">MUST</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTOR</span>
</code></code></pre>

<p>This is the back end for fetch_sequence(). Adaptors must implement this method in order to store and retrieve nucleotide or protein sequence.</p>

<h2 id="seq_ids1">_seq_ids</h2>

<pre><code><code> Title   : _seq_ids
 Usage   : @ids = $db-&gt;_seq_ids()
 Function: Return all sequence IDs contained in database
 Returns : list of sequence Ids
 Args    : none
 Status  : TO BE IMPLEMENTED BY ADAPTOR</code></code></pre>

<p>This method is invoked by seq_ids() to return all sequence IDs (coordinate systems) known to the database.</p>

<h2 id="start_bulk_update-_finish_bulk_update">_start_bulk_update,_finish_bulk_update</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">_start_bulk_update</span><span class="operator">,</span> <span class="variable">_finish_bulk_update</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_start_bulk_update</span>
           <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">_finish_bulk_update</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">Activate</span> <span class="variable">optimizations</span> <span class="keyword">for</span> <span class="variable">large</span> <span class="variable">number</span> <span class="variable">of</span> <span class="variable">insertions</span><span class="operator">/</span><span class="variable">updates</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">nothing</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">nothing</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">OPTIONAL</span><span class="operator">;</span> <span class="variable">MAY</span> <span class="variable">BE</span> <span class="variable">IMPLEMENTED</span> <span class="variable">BY</span> <span class="variable">ADAPTOR</span>
</code></code></pre>

<p>These are the backends for start_bulk_update() and finish_bulk_update(). The default behavior of both methods is to do nothing.</p>

<h2 id="Optional-methods-needed-to-implement-full-TIEHASH-interface">Optional methods needed to implement full TIEHASH interface</h2>

<p>The core TIEHASH interface will work if just the _store() and _fetch() methods are implemented. To support the full TIEHASH interface, including support for keys(), each(), and exists(), the following methods should be implemented:</p>

<dl>

<dt id="id-db-_firstid-">$id = $db-&gt;_firstid()</dt>
<dd>

<p>Return the first primary ID in the database. Needed for the each() function.</p>

</dd>
<dt id="next_id-db-_nextid-id-">$next_id = $db-&gt;_nextid($id)</dt>
<dd>

<p>Given a primary ID, return the next primary ID in the series. Needed for the each() function.</p>

</dd>
<dt id="boolean-db-_existsid-id-">$boolean = $db-&gt;_existsid($id)</dt>
<dd>

<p>Returns true if the indicated primary ID is in the database. Needed for the exists() function.</p>

</dd>
<dt id="db-_deleteid-id-">$db-&gt;_deleteid($id)</dt>
<dd>

<p>Delete the feature corresponding to the given primary ID. Needed for delete().</p>

</dd>
<dt id="db-_clearall-">$db-&gt;_clearall()</dt>
<dd>

<p>Empty the database. Needed for %tied_hash = ().</p>

</dd>
<dt id="count-db-_featurecount-">$count = $db-&gt;_featurecount()</dt>
<dd>

<p>Return the number of features in the database. Needed for scalar %tied_hash.</p>

</dd>
</dl>

<h1 id="Internal-Methods">Internal Methods</h1>

<p>These methods are internal to Bio::DB::SeqFeature::Store and adaptors.</p>

<h2 id="new_instance">new_instance</h2>

<pre><code><code> Title   : new_instance
 Usage   : $db = $db-&gt;new_instance()
 Function: class constructor
 Returns : A descendent of Bio::DB::SeqFeature::Store
 Args    : none
 Status  : internal</code></code></pre>

<p>This method is called internally by new() to create a new uninitialized instance of Bio::DB::SeqFeature::Store. It is used internally and should not be called by application software.</p>

<h2 id="init">init</h2>

<pre><code><code> Title   : init
 Usage   : $db-&gt;init(@args)
 Function: initialize object
 Returns : none
 Args    : Arguments passed to new()
 Status  : private</code></code></pre>

<p>This method is called internally by new() to initialize a newly-created object using the arguments passed to new(). It is to be overridden by Bio::DB::SeqFeature::Store adaptors.</p>

<h2 id="default_settings">default_settings</h2>

<pre><code><code> Title   : default_settings
 Usage   : $db-&gt;default_settings()
 Function: set up default settings for the adaptor
 Returns : none
 Args    : none
 Status  : private</code></code></pre>

<p>This method is may be overridden by adaptors. It is responsible for setting up object default settings.</p>

<h2 id="default_serializer">default_serializer</h2>

<pre><code><code> Title   : default_serializer
 Usage   : $serializer = $db-&gt;default_serializer
 Function: finds an available serializer
 Returns : the name of an available serializer
 Args    : none
 Status  : private</code></code></pre>

<p>This method returns the name of an available serializer module.</p>

<h2 id="setting">setting</h2>

<pre><code><code> Title   : setting
 Usage   : $value = $db-&gt;setting(&#39;setting_name&#39; [=&gt; $new_value])
 Function: get/set the value of a setting
 Returns : the value of the current setting
 Args    : the name of the setting and optionally a new value for the setting
 Status  : private</code></code></pre>

<p>This is a low-level procedure for persistently storing database settings. It can be overridden by adaptors.</p>

<h2 id="subfeatures_are_indexed">subfeatures_are_indexed</h2>

<pre><code><code> Title   : subfeatures_are_indexed
 Usage   : $flag = $db-&gt;subfeatures_are_indexed([$new_value])
 Function: flag whether subfeatures are indexed
 Returns : a flag indicating that all subfeatures are indexed
 Args    : (optional) new value of the flag
 Status  : private</code></code></pre>

<p>This method is used internally by the Bio::DB::SeqFeature class to optimize some of its operations. It returns true if all of the subfeatures in the database are indexed; it returns false if at least one of the subfeatures is not indexed. Do not attempt to change the value of this setting unless you are writing an adaptor.</p>

<h2 id="subfeature_types_are_indexed">subfeature_types_are_indexed</h2>

<pre><code><code> Title   : subfeature_types_are_indexed
 Usage   : $flag = $db-&gt;subfeature_types_are_indexed
 Function: whether subfeatures are indexed by type
 Returns : a flag indicating that all subfeatures are indexed
 Args    : none
 Status  : private</code></code></pre>

<p>This method returns true if subfeature types are indexed. Default is to return the value of subfeatures_are_indexed().</p>

<h2 id="subfeature_locations_are_indexed">subfeature_locations_are_indexed</h2>

<pre><code><code> Title   : subfeature_locations_are_indexed
 Usage   : $flag = $db-&gt;subfeature_locations_are_indexed
 Function: whether subfeatures are indexed by type
 Returns : a flag indicating that all subfeatures are indexed
 Args    : none
 Status  : private</code></code></pre>

<p>This method returns true if subfeature locations are indexed. Default is to return the value of subfeatures_are_indexed().</p>

<h2 id="setup_segment_args">setup_segment_args</h2>

<pre><code><code> Title   : setup_segment_args
 Usage   : @args = $db-&gt;setup_segment_args(@args)
 Function: munge the arguments to the segment() call
 Returns : munged arguments
 Args    : see below
 Status  : private</code></code></pre>

<p>This method is used internally by segment() to translate positional arguments into named argument=&gt;value pairs.</p>

<h2 id="store_and_cache">store_and_cache</h2>

<pre><code><code> Title   : store_and_cache
 Usage   : $success = $db-&gt;store_and_cache(@features)
 Function: store features into database and update cache
 Returns : number of features stored
 Args    : index the features? (0 or 1) and  list of features
 Status  : private</code></code></pre>

<p>This private method stores the list of Bio::SeqFeatureI objects into the database and caches them in memory for retrieval.</p>

<h2 id="init_cache">init_cache</h2>

<pre><code><code> Title   : init_cache
 Usage   : $db-&gt;init_cache($size)
 Function: initialize the in-memory feature cache
 Returns : the Tie::Cacher object
 Args    : desired size of the cache
 Status  : private</code></code></pre>

<p>This method is used internally by new() to create the Tie::Cacher instance used for the in-memory feature cache.</p>

<h2 id="cache">cache</h2>

<pre><code><code> Title   : cache
 Usage   : $cache = $db-&gt;cache
 Function: return the cache object
 Returns : the Tie::Cacher object
 Args    : none
 Status  : private</code></code></pre>

<p>This method returns the Tie::Cacher object used for the in-memory feature cache.</p>

<h2 id="load_class">load_class</h2>

<pre><code><code> Title   : load_class
 Usage   : $db-&gt;load_class($blessed_object)
 Function: loads the module corresponding to a blessed object
 Returns : empty
 Args    : a blessed object
 Status  : private</code></code></pre>

<p>This method is used by thaw() to load the code for a blessed object. This ensures that all the object&#39;s methods are available.</p>

<h2 id="freeze">freeze</h2>

<pre><code><code> Title   : freeze
 Usage   : $serialized_object = $db-&gt;freeze($feature)
 Function: serialize a feature object into a string
 Returns : serialized feature object
 Args    : a seqfeature object
 Status  : private</code></code></pre>

<p>This method converts a Bio::SeqFeatureI object into a serialized form suitable for storage into a database. The feature&#39;s primary ID is set to undef before it is serialized. This avoids any potential mismatch between the primary ID used as the database key and the primary ID stored in the serialized object.</p>

<h2 id="thaw">thaw</h2>

<pre><code><code> Title   : thaw
 Usage   : $feature = $db-&gt;thaw($serialized_object,$primary_id)
 Function: unserialize a string into a feature object
 Returns : Bio::SeqFeatureI object
 Args    : serialized form of object from freeze() and primary_id of object
 Status  : private</code></code></pre>

<p>This method is the reverse of the freeze(). The supplied primary_id becomes the primary_id() of the returned Bio::SeqFeatureI object. This implementation checks for a deserialized object in the cache before it calls thaw_object() to do the actual deserialization.</p>

<h2 id="thaw_object">thaw_object</h2>

<pre><code><code> Title   : thaw_object
 Usage   : $feature = $db-&gt;thaw_object($serialized_object,$primary_id)
 Function: unserialize a string into a feature object
 Returns : Bio::SeqFeatureI object
 Args    : serialized form of object from freeze() and primary_id of object
 Status  : private</code></code></pre>

<p>After thaw() checks the cache and comes up empty, this method is invoked to thaw the object.</p>

<h2 id="feature_names">feature_names</h2>

<pre><code><code> Title   : feature_names
 Usage   : ($names,$aliases) = $db-&gt;feature_names($feature)
 Function: get names and aliases for a feature
 Returns : an array of names and an array of aliases
 Args    : a Bio::SeqFeatureI object
 Status  : private</code></code></pre>

<p>This is an internal utility function which, given a Bio::SeqFeatureI object, returns two array refs. The first is a list of official names for the feature, and the second is a list of aliases. This is slightly skewed towards GFF3 usage, so the official names are the display_name(), plus all tag values named &#39;Name&#39;, plus all tag values named &#39;ID&#39;. The aliases are all tag values named &#39;Alias&#39;.</p>

<h2 id="feature_summary">feature_summary</h2>

<pre><code><code> Title   : feature_summary
 Usage   : $summary = $db-&gt;feature_summary(@args)
 Function: returns a coverage summary across indicated region/type
 Returns : a Bio::SeqFeatureI object containing the &quot;coverage&quot; tag
 Args    : see below
 Status  : public</code></code></pre>

<p>This method is used to get coverage density information across a region of interest. You provide it with a region of interest, optional a list of feature types, and a count of the number of bins over which you want to calculate the coverage density. An object is returned corresponding to the requested region. It contains a tag called &quot;coverage&quot; that will return an array ref of &quot;bins&quot; length. Each element of the array describes the number of features that overlap the bin at this postion.</p>

<p>Arguments:</p>

<pre><code><code>  Argument       Description
  --------       -----------

  -seq_id        Sequence ID for the region
  -start         Start of region
  -end           End of region
  -type/-types   Feature type of interest or array ref of types
  -bins          Number of bins across region. Defaults to 1000.
  -iterator      Return an iterator across the region</code></code></pre>

<p>Note that this method uses an approximate algorithm that is only accurate to 500 bp, so when dealing with bins that are smaller than 1000 bp, you may see some shifting of counts between adjacent bins.</p>

<p>Although an -iterator option is provided, the method only ever returns a single feature, so this is fairly useless.</p>

<h2 id="coverage_array">coverage_array</h2>

<pre><code><code> Title   : coverage_array
 Usage   : $arrayref = $db-&gt;coverage_array(@args)
 Function: returns a coverage summary across indicated region/type
 Returns : an array reference
 Args    : see below
 Status  : public</code></code></pre>

<p>This method is used to get coverage density information across a region of interest. The arguments are identical to feature_summary, except that instead of returning a Bio::SeqFeatureI object, it returns an array reference of the desired number of bins. The value of each element corresponds to the number of features in the bin.</p>

<p>Arguments:</p>

<pre><code><code>  Argument       Description
  --------       -----------

  -seq_id        Sequence ID for the region
  -start         Start of region
  -end           End of region
  -type/-types   Feature type of interest or array ref of types
  -bins          Number of bins across region. Defaults to 1000.</code></code></pre>

<p>Note that this method uses an approximate algorithm that is only accurate to 500 bp, so when dealing with bins that are smaller than 1000 bp, you may see some shifting of counts between adjacent bins.</p>

<h1 id="BUGS">BUGS</h1>

<p>This is an early version, so there are certainly some bugs. Please use the BioPerl bug tracking system to report bugs.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/SeqFeature.html">Bio::DB::SeqFeature</a>, <a href="../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/SeqFeature/Store/GFF3Loader.html">Bio::DB::SeqFeature::Store::GFF3Loader</a>, <a href="../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/SeqFeature/Segment.html">Bio::DB::SeqFeature::Segment</a>, <a href="../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/SeqFeature/Store/DBI/mysql.html">Bio::DB::SeqFeature::Store::DBI::mysql</a>, <a href="../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/SeqFeature/Store/berkeleydb.html">Bio::DB::SeqFeature::Store::berkeleydb</a> <a href="../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/SeqFeature/Store/memory.html">Bio::DB::SeqFeature::Store::memory</a></p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Lincoln Stein &lt;lstein@cshl.org&gt;.</p>

<p>Copyright (c) 2006 Cold Spring Harbor Laboratory.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>


</body>

</html>


