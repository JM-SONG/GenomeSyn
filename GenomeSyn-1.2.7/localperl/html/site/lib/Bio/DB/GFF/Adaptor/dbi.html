<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#new">new</a></li>
      <li><a href="#features_db">features_db</a></li>
      <li><a href="#get_dna">get_dna</a></li>
      <li><a href="#get_abscoords">get_abscoords</a></li>
      <li><a href="#get_features">get_features</a></li>
      <li><a href="#classes">classes</a></li>
      <li><a href="#make_classes_query">make_classes_query</a></li>
      <li><a href="#feature_by_name">_feature_by_name</a></li>
      <li><a href="#feature_by_id">_feature_by_id</a></li>
      <li><a href="#get_types">get_types</a></li>
      <li><a href="#range_query">range_query</a></li>
      <li><a href="#make_features_by_range_where_part">make_features_by_range_where_part</a></li>
      <li><a href="#do_straight_join">do_straight_join</a></li>
      <li><a href="#string_match">string_match</a></li>
      <li><a href="#exact_match">exact_match</a></li>
      <li><a href="#search_notes">search_notes</a></li>
      <li><a href="#meta">meta</a></li>
      <li><a href="#make_meta_get_query">make_meta_get_query</a></li>
      <li><a href="#make_meta_set_query">make_meta_set_query</a></li>
      <li><a href="#default_meta_values">default_meta_values</a></li>
      <li><a href="#get_features_iterator">get_features_iterator</a></li>
      <li><a href="#do_initialize">do_initialize</a></li>
      <li><a href="#finish_load">finish_load</a></li>
      <li><a href="#create_other_schema_objects">create_other_schema_objects</a></li>
      <li><a href="#drop_all">drop_all</a></li>
      <li><a href="#clone">clone</a></li>
    </ul>
  </li>
  <li><a href="#QUERIES-TO-IMPLEMENT">QUERIES TO IMPLEMENT</a>
    <ul>
      <li><a href="#drop_other_schema_objects">drop_other_schema_objects</a></li>
      <li><a href="#make_features_select_part">make_features_select_part</a></li>
      <li><a href="#tables">tables</a></li>
      <li><a href="#schema">schema</a></li>
      <li><a href="#DESTROY">DESTROY</a></li>
      <li><a href="#make_features_by_name_where_part">make_features_by_name_where_part</a></li>
      <li><a href="#make_features_by_id_where_part">make_features_by_id_where_part</a></li>
      <li><a href="#make_features_by_gid_where_part">make_features_by_gid_where_part</a></li>
      <li><a href="#make_features_from_part">make_features_from_part</a></li>
      <li><a href="#make_features_join_part">make_features_join_part</a></li>
      <li><a href="#make_features_order_by_part">make_features_order_by_part</a></li>
      <li><a href="#make_features_group_by_part">make_features_group_by_part</a></li>
      <li><a href="#refseq_query">refseq_query</a></li>
      <li><a href="#attributes">attributes</a></li>
      <li><a href="#overlap_query_nobin">overlap_query_nobin</a></li>
      <li><a href="#contains_query_nobin">contains_query_nobin</a></li>
      <li><a href="#contained_in_query_nobin">contained_in_query_nobin</a></li>
      <li><a href="#types_query">types_query</a></li>
      <li><a href="#make_types_select_part">make_types_select_part</a></li>
      <li><a href="#make_types_from_part">make_types_from_part</a></li>
      <li><a href="#make_types_join_part">make_types_join_part</a></li>
      <li><a href="#make_types_where_part">make_types_where_part</a></li>
      <li><a href="#make_types_group_part">make_types_group_part</a></li>
      <li><a href="#get_feature_id">get_feature_id</a></li>
      <li><a href="#make_abscoord_query">make_abscoord_query</a></li>
      <li><a href="#feature_summary">feature_summary</a></li>
      <li><a href="#coverage_array">coverage_array</a></li>
      <li><a href="#build_summary_statistics">build_summary_statistics</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Bio::DB::GFF::Adaptor::dbi -- Database adaptor for DBI (SQL) databases</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>See <a href="../../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF.html">Bio::DB::GFF</a></p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This is the base class for DBI-based adaptors. It does everything except generating the text of the queries to be used. See the section QUERIES TO IMPLEMENT for the list of methods that must be implemented.</p>

<h2 id="new">new</h2>

<pre><code><code> Title   : new
 Usage   : $db = Bio::DB::GFF-&gt;new(@args)
 Function: create a new adaptor
 Returns : a Bio::DB::GFF object
 Args    : see below
 Status  : Public</code></code></pre>

<p>This is the constructor for the adaptor. It is called automatically by Bio::DB::GFF-&gt;new. In addition to arguments that are common among all adaptors, the following class-specific arguments are recgonized:</p>

<pre><code><code>  Argument       Description
  --------       -----------

  -dsn           the DBI data source, e.g. &#39;dbi:mysql:ens0040&#39;

  -user          username for authentication

  -pass          the password for authentication</code></code></pre>

<h2 id="features_db">features_db</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">features_db</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features_db</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">get</span> <span class="variable">database</span> <span class="variable">handle</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">a</span> <span class="variable">DBI</span> <span class="variable">handle</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">none</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
 
 <span class="variable">Note</span><span class="operator">:</span> <span class="variable">what</span> <span class="variable">is</span> <span class="variable">returned</span> <span class="variable">is</span> <span class="keyword">not</span> <span class="variable">really</span> <span class="variable">a</span> <span class="variable">DBI::db</span> <span class="variable">handle</span><span class="operator">,</span> <span class="variable">but</span> <span class="variable">a</span>
 <span class="variable">subclass</span> <span class="variable">of</span> <span class="variable">one</span><span class="operator">.</span>  <span class="variable">This</span> <span class="variable">means</span> <span class="variable">that</span> <span class="variable">you</span> <span class="variable">cannot</span> <span class="variable">manipulate</span> <span class="variable">the</span>
 <span class="variable">handle's</span> <span class="variable">attributes</span> <span class="variable">directly</span><span class="operator">.</span>  <span class="variable">Instead</span> <span class="variable">call</span> <span class="variable">the</span> <span class="variable">attribute</span>
 <span class="variable">method</span><span class="operator">:</span>
 
 <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">features_db</span><span class="operator">;</span>
 <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">attribute</span><span class="operator">(</span><span class="string">AutoCommit</span><span class="operator">=&gt;</span><span class="number">0</span><span class="operator">);</span>
</code></code></pre>

<h2 id="get_dna">get_dna</h2>

<pre><code><code> Title   : get_dna
 Usage   : $string = $db-&gt;get_dna($name,$start,$stop,$class)
 Function: get DNA string
 Returns : a string
 Args    : name, class, start and stop of desired segment
 Status  : Public</code></code></pre>

<p>This method performs the low-level fetch of a DNA substring given its name, class and the desired range. It is actually a front end to the abstract method make_dna_query(), which it calls after some argument consistency checking.</p>

<h2 id="get_abscoords">get_abscoords</h2>

<pre><code><code> Title   : get_abscoords
 Usage   : ($refseq,$refclass,$start,$stop,$strand) = $db-&gt;get_abscoords($name,$class)
 Function: get absolute coordinates for landmark
 Returns : an array ref -- see below
 Args    : name and class of desired landmark
 Status  : Public</code></code></pre>

<p>This method performs the low-level resolution of a landmark into a reference sequence and position.</p>

<p>The result is an array ref, each element of which is a five-element list containing reference sequence name, class, start, stop and strand.</p>

<h2 id="get_features">get_features</h2>

<pre><code><code> Title   : get_features
 Usage   : $db-&gt;get_features($search,$options,$callback)
 Function: retrieve features from the database
 Returns : number of features retrieved
 Args    : see below
 Status  : Public</code></code></pre>

<p>This is the low-level method that is called to retrieve GFF lines from the database. It is responsible for retrieving features that satisfy range and feature type criteria, and passing the GFF fields to a callback subroutine.</p>

<p>See the manual page for Bio::DB::GFF for the interpretation of the arguments and how the information retrieved by get_features is passed to the callback for processing.</p>

<p>Internally, get_features() is a front end for range_query(). The latter method constructs the query and executes it. get_features() calls fetchrow_array() to recover the fields and passes them to the callback.</p>

<h2 id="classes">classes</h2>

<pre><code><code> Title   : classes
 Usage   : $db-&gt;classes
 Function: return list of landmark classes in database
 Returns : a list of classes
 Args    : none
 Status  : public</code></code></pre>

<p>This routine returns the list of reference classes known to the database, or empty if classes are not used by the database. Classes are distinct from types, being essentially qualifiers on the reference namespaces.</p>

<p>NOTE: In the current mysql-based schema, this query takes a while to run due to the classes not being normalized.</p>

<h2 id="make_classes_query">make_classes_query</h2>

<pre><code><code> Title   : make_classes_query
 Usage   : ($query,@args) = $db-&gt;make_classes_query
 Function: return query fragment for generating list of reference classes
 Returns : a query and args
 Args    : none
 Status  : public</code></code></pre>

<h2 id="feature_by_name">_feature_by_name</h2>

<pre><code><code> Title   : _feature_by_name
 Usage   : $db-&gt;get_features_by_name($name,$class,$callback)
 Function: get a list of features by name and class
 Returns : count of number of features retrieved
 Args    : name of feature, class of feature, and a callback
 Status  : protected</code></code></pre>

<p>This method is used internally. The callback arguments are those used by make_feature(). Internally, it invokes the following abstract procedures:</p>

<pre><code><code> make_features_select_part
 make_features_from_part
 make_features_by_name_where_part
 make_features_by_alias_where_part  (for aliases)
 make_features_join_part</code></code></pre>

<h2 id="feature_by_id">_feature_by_id</h2>

<pre><code><code> Title   : _feature_by_id
 Usage   : $db-&gt;_feature_by_id($ids,$type,$callback)
 Function: get a list of features by ID
 Returns : count of number of features retrieved
 Args    : arrayref containing list of IDs to fetch and a callback
 Status  : protected</code></code></pre>

<p>This method is used internally. The $type selector is one of &quot;feature&quot; or &quot;group&quot;. The callback arguments are those used by make_feature(). Internally, it invokes the following abstract procedures:</p>

<pre><code><code> make_features_select_part
 make_features_from_part
 make_features_by_id_where_part
 make_features_join_part</code></code></pre>

<h2 id="get_types">get_types</h2>

<pre><code><code> Title   : get_types
 Usage   : $db-&gt;get_types($refseq,$refclass,$start,$stop,$count)
 Function: get list of types
 Returns : a list of Bio::DB::GFF::Typename objects
 Args    : see below
 Status  : Public</code></code></pre>

<p>This method is responsible for fetching the list of feature type names from the database. The query may be limited to a particular range, in which case the range is indicated by a landmark sequence name and class and its subrange, if any. These arguments may be undef if it is desired to retrieve all feature types in the database (which may be a slow operation in some implementations).</p>

<p>If the $count flag is false, the method returns a simple list of vBio::DB::GFF::Typename objects. If $count is true, the method returns a list of $name=&gt;$count pairs, where $count indicates the number of times this feature occurs in the range.</p>

<p>Internally, this method calls upon the following functions to generate the SQL and its bind variables:</p>

<pre><code><code>  <span class="operator">(</span><span class="variable">$q1</span><span class="operator">,</span><span class="variable">@args</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">make_types_select_part</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
  <span class="operator">(</span><span class="variable">$q2</span><span class="operator">,</span><span class="variable">@args</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">make_types_from_part</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
  <span class="operator">(</span><span class="variable">$q3</span><span class="operator">,</span><span class="variable">@args</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">make_types_where_part</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
  <span class="operator">(</span><span class="variable">$q4</span><span class="operator">,</span><span class="variable">@args</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">make_types_join_part</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
  <span class="operator">(</span><span class="variable">$q5</span><span class="operator">,</span><span class="variable">@args</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">make_types_group_part</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
</code></code></pre>

<p>The components are then combined as follows:</p>

<pre><code><code>  <span class="variable">$query</span> <span class="operator">=</span> <span class="string">"SELECT </span><span class="variable">$q1</span><span class="string"> FROM </span><span class="variable">$q2</span><span class="string"> WHERE </span><span class="variable">$q3</span><span class="string"> AND </span><span class="variable">$q4</span><span class="string"> GROUP BY </span><span class="variable">$q5</span><span class="string">"</span><span class="operator">;</span>
</code></code></pre>

<p>If any of the query fragments contain the ? bind variable, then the same number of bind arguments must be provided in @args. The fragment-generating functions are described below.</p>

<h2 id="range_query">range_query</h2>

<pre><code><code> Title   : range_query
 Usage   : $db-&gt;range_query($range_type,$refseq,$refclass,$start,$stop,$types,$order_by_group,$attributes,$binsize)
 Function: create statement handle for range/overlap queries
 Returns : a DBI statement handle
 Args    : see below
 Status  : Protected</code></code></pre>

<p>This method constructs the statement handle for this module&#39;s central query: given a range and/or a list of feature types, fetch their GFF records.</p>

<p>The positional arguments are as follows:</p>

<pre><code><code>  Argument               Description

  $isrange               A flag indicating that this is a range.
                         query.  Otherwise an overlap query is
                         assumed.

  $refseq                The reference sequence name (undef if no range).

  $refclass              The reference sequence class (undef if no range).

  $start                 The start of the range (undef if none).

  $stop                  The stop of the range (undef if none).

  $types                 Array ref containing zero or feature types in the
                         format [method,source].

  $order_by_group        A flag indicating that statement handler should group
                         the features by group id (handy for iterative fetches)

  $attributes            A hash containing select attributes.

  $binsize               A bin size for generating tables of feature density.</code></code></pre>

<p>If successful, this method returns a statement handle. The handle is expected to return the fields described for get_features().</p>

<p>Internally, range_query() makes calls to the following methods, each of which is expected to be overridden in subclasses:</p>

<pre><code><code>  <span class="variable">$select</span>        <span class="operator">=</span> <span class="variable">$self</span><span class="operator">-&gt;</span><span class="variable">make_features_select_part</span><span class="operator">;</span>
  <span class="variable">$from</span>          <span class="operator">=</span> <span class="variable">$self</span><span class="operator">-&gt;</span><span class="variable">make_features_from_part</span><span class="operator">;</span>
  <span class="variable">$join</span>          <span class="operator">=</span> <span class="variable">$self</span><span class="operator">-&gt;</span><span class="variable">make_features_join_part</span><span class="operator">;</span>
  <span class="operator">(</span><span class="variable">$where</span><span class="operator">,</span><span class="variable">@args</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$self</span><span class="operator">-&gt;</span><span class="variable">make_features_by_range_where_part</span><span class="operator">(</span><span class="variable">$isrange</span><span class="operator">,</span><span class="variable">$srcseq</span><span class="operator">,</span><span class="variable">$class</span><span class="operator">,</span>
                                                           <span class="variable">$start</span><span class="operator">,</span><span class="variable">$stop</span><span class="operator">,</span><span class="variable">$types</span><span class="operator">,</span><span class="variable">$class</span><span class="operator">);</span>
</code></code></pre>

<p>The query that is constructed looks like this:</p>

<pre><code><code>  SELECT $select FROM $from WHERE $join AND $where</code></code></pre>

<p>The arguments that are returned from make_features_by_range_where_part() are passed to the statement handler&#39;s execute() method.</p>

<p>range_query() also calls a do_straight_join() method, described below. If this method returns true, then the keyword &quot;straight_join&quot; is inserted right after SELECT.</p>

<h2 id="make_features_by_range_where_part">make_features_by_range_where_part</h2>

<pre><code><code> Title   : make_features_by_range_where_part
 Usage   : ($string,@args) =
     $db-&gt;make_features_select_part($isrange,$refseq,$class,$start,$stop,$types)
 Function: make where part of the features query
 Returns : the list ($query,@bind_args)
 Args    : see below
 Status  : Protected</code></code></pre>

<p>This method creates the part of the features query that immediately follows the WHERE keyword and is ANDed with the string returned by make_features_join_part().</p>

<p>The six positional arguments are a flag indicating whether to perform a range search or an overlap search, the reference sequence, class, start and stop, all of which define an optional range to search in, and an array reference containing a list [$method,$souce] pairs.</p>

<p>The method result is a multi-element list containing the query string and the list of runtime arguments to bind to it with the execute() method.</p>

<p>This method&#39;s job is to clean up arguments and perform consistency checking. The real work is done by the following abstract methods:</p>

<pre><code><code>  Method             Description

  refseq_query()     Return the query string needed to match the reference
                     sequence.

  range_query()      Return the query string needed to find all features contained
                     within a range.

  overlap_query()    Return the query string needed to find all features that overlap
                     a range.</code></code></pre>

<p>See Bio::DB::Adaptor::dbi::mysql for an example of how this works.</p>

<h2 id="do_straight_join">do_straight_join</h2>

<pre><code><code> Title   : do_straight_join
 Usage   : $boolean = $db-&gt;do_straight_join($refseq,$class,$start,$stop,$types)
 Function: optimization flag
 Returns : a flag
 Args    : see range_query()
 Status  : Protected</code></code></pre>

<p>This subroutine, called by range_query() returns a boolean flag. If true, range_query() will perform a straight join, which can be used to optimize certain SQL queries. The four arguments correspond to similarly-named arguments passed to range_query().</p>

<h2 id="string_match">string_match</h2>

<pre><code><code> Title   : string_match
 Usage   : $string = $db-&gt;string_match($field,$value)
 Function: create a SQL fragment for performing exact or regexp string matching
 Returns : query string
 Args    : the table field and match value
 Status  : public</code></code></pre>

<p>This method examines the passed value for meta characters. If so it produces a SQL fragment that performs a regular expression match. Otherwise, it produces a fragment that performs an exact string match.</p>

<p>This method is not used in the module, but is available for use by subclasses.</p>

<h2 id="exact_match">exact_match</h2>

<pre><code><code> Title   : exact_match
 Usage   : $string = $db-&gt;exact_match($field,$value)
 Function: create a SQL fragment for performing exact string matching
 Returns : query string
 Args    : the table field and match value
 Status  : public</code></code></pre>

<p>This method produces the SQL fragment for matching a field name to a constant string value.</p>

<h2 id="search_notes">search_notes</h2>

<pre><code><code> Title   : search_notes
 Usage   : @search_results = $db-&gt;search_notes(&quot;full text search string&quot;,$limit)
 Function: Search the notes for a text string, using mysql full-text search
 Returns : array of results
 Args    : full text search string, and an optional row limit
 Status  : public</code></code></pre>

<p>This is a mysql-specific method. Given a search string, it performs a full-text search of the notes table and returns an array of results. Each row of the returned array is a arrayref containing the following fields:</p>

<pre><code><code>  column 1     A Bio::DB::GFF::Featname object, suitable for passing to segment()
  column 2     The text of the note
  column 3     A relevance score.
  column 4     A Bio::DB::GFF::Typename object</code></code></pre>

<h2 id="meta">meta</h2>

<pre><code><code> Title   : meta
 Usage   : $value = $db-&gt;meta($name [,$newval])
 Function: get or set a meta variable
 Returns : a string
 Args    : meta variable name and optionally value
 Status  : public</code></code></pre>

<p>Get or set a named metavariable for the database. Metavariables can be used for database-specific settings. This method calls two class-specific methods which must be implemented:</p>

<pre><code><code>  make_meta_get_query()   Returns a sql fragment which given a meta
                          parameter name, returns its value.  One bind
                          variable.
  make_meta_set_query()   Returns a sql fragment which takes two bind
                          arguments, the parameter name and its value</code></code></pre>

<p>Don&#39;t make changes unless you know what you&#39;re doing! It will affect the persistent database.</p>

<h2 id="make_meta_get_query">make_meta_get_query</h2>

<pre><code><code> Title   : make_meta_get_query
 Usage   : $sql = $db-&gt;make_meta_get_query
 Function: return SQL fragment for getting a meta parameter
 Returns : SQL fragment
 Args    : none
 Status  : public</code></code></pre>

<p>By default this does nothing; meta parameters are not stored or retrieved.</p>

<h2 id="make_meta_set_query">make_meta_set_query</h2>

<pre><code><code> Title   : make_meta_set_query
 Usage   : $sql = $db-&gt;make_meta_set_query
 Function: return SQL fragment for setting a meta parameter
 Returns : SQL fragment
 Args    : none
 Status  : public</code></code></pre>

<p>By default this does nothing; meta parameters are not stored or retrieved.</p>

<h2 id="default_meta_values">default_meta_values</h2>

<pre><code><code> Title   : default_meta_values
 Usage   : %values = $db-&gt;default_meta_values
 Function: empty the database
 Returns : a list of tag=&gt;value pairs
 Args    : none
 Status  : protected</code></code></pre>

<p>This method returns a list of tag=&gt;value pairs that contain default meta information about the database. It is invoked by initialize() to write out the default meta values. The base class version returns an empty list.</p>

<p>For things to work properly, meta value names must be UPPERCASE.</p>

<h2 id="get_features_iterator">get_features_iterator</h2>

<pre><code><code> Title   : get_features_iterator
 Usage   : $iterator = $db-&gt;get_features_iterator($search,$options,$callback)
 Function: create an iterator on a features() query
 Returns : A Bio::DB::GFF::Adaptor::dbi::iterator object
 Args    : see get_features()
 Status  : public</code></code></pre>

<p>This method is similar to get_features(), except that it returns an iterator across the query. See <a href="../../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/Adaptor/dbi/iterator.html">Bio::DB::GFF::Adaptor::dbi::iterator</a>.</p>

<h2 id="do_initialize">do_initialize</h2>

<pre><code><code> Title   : do_initialize
 Usage   : $success = $db-&gt;do_initialize($drop_all)
 Function: initialize the database
 Returns : a boolean indicating the success of the operation
 Args    : a boolean indicating whether to delete existing data
 Status  : protected</code></code></pre>

<p>This method will load the schema into the database. If $drop_all is true, then any existing data in the tables known to the schema will be deleted.</p>

<p>Internally, this method calls schema() to get the schema data.</p>

<h2 id="finish_load">finish_load</h2>

<pre><code><code> Title   : finish_load
 Usage   : $db-&gt;finish_load
 Function: called after load_gff_line()
 Returns : number of records loaded
 Args    : none
 Status  : protected</code></code></pre>

<p>This method performs schema-specific cleanup after loading a set of GFF records. It finishes each of the statement handlers prepared by setup_load().</p>

<h2 id="create_other_schema_objects">create_other_schema_objects</h2>

<pre><code><code> Title   : create_other_schema_objects
 Usage   : $self-&gt;create_other_schema_objects($table_name)
 Function: create other schema objects like : indexes, sequences, triggers
 Returns : 
 Args    : 
 Status  : Abstract</code></code></pre>

<h2 id="drop_all">drop_all</h2>

<pre><code><code> Title   : drop_all
 Usage   : $db-&gt;drop_all
 Function: empty the database
 Returns : void
 Args    : none
 Status  : protected</code></code></pre>

<p>This method drops the tables known to this module. Internally it calls the abstract tables() method.</p>

<h2 id="clone">clone</h2>

<p>The clone() method should be used when you want to pass the Bio::DB::GFF object to a child process across a fork(). The child must call clone() before making any queries.</p>

<p>This method does two things: (1) it sets the underlying database handle&#39;s InactiveDestroy parameter to 1, thereby preventing the database connection from being destroyed in the parent when the dbh&#39;s destructor is called; (2) it replaces the dbh with the result of dbh-&gt;clone(), so that we now have an independent handle.</p>

<h1 id="QUERIES-TO-IMPLEMENT">QUERIES TO IMPLEMENT</h1>

<p>The following astract methods either return DBI statement handles or fragments of SQL. They must be implemented by subclasses of this module. See Bio::DB::GFF::Adaptor::dbi::mysql for examples.</p>

<h2 id="drop_other_schema_objects">drop_other_schema_objects</h2>

<pre><code><code> Title   : drop_other_schema_objects
 Usage   : $self-&gt;create_other_schema_objects($table_name)
 Function: create other schema objects like : indexes, sequences, triggers
 Returns : 
 Args    : 
 Status  : Abstract</code></code></pre>

<h2 id="make_features_select_part">make_features_select_part</h2>

<pre><code><code> Title   : make_features_select_part
 Usage   : $string = $db-&gt;make_features_select_part()
 Function: make select part of the features query
 Returns : a string
 Args    : none
 Status  : Abstract</code></code></pre>

<p>This abstract method creates the part of the features query that immediately follows the SELECT keyword.</p>

<h2 id="tables">tables</h2>

<pre><code><code> Title   : tables
 Usage   : @tables = $db-&gt;tables
 Function: return list of tables that belong to this module
 Returns : list of tables
 Args    : none
 Status  : protected</code></code></pre>

<p>This method lists the tables known to the module.</p>

<h2 id="schema">schema</h2>

<pre><code><code> Title   : schema
 Usage   : $schema = $db-&gt;schema
 Function: return the CREATE script for the schema
 Returns : a hashref
 Args    : none
 Status  : abstract</code></code></pre>

<p>This method returns an array ref containing the various CREATE statements needed to initialize the database tables. The keys are the table names, and the values are strings containing the appropriate CREATE statement.</p>

<h2 id="DESTROY">DESTROY</h2>

<pre><code><code> Title   : DESTROY
 Usage   : $db-&gt;DESTROY
 Function: disconnect database at destruct time
 Returns : void
 Args    : none
 Status  : protected</code></code></pre>

<p>This is the destructor for the class.</p>

<h2 id="make_features_by_name_where_part">make_features_by_name_where_part</h2>

<pre><code><code> Title   : make_features_by_name_where_part
 Usage   : $db-&gt;make_features_by_name_where_part
 Function: create the SQL fragment needed to select a feature by its group name &amp; class
 Returns : a SQL fragment and bind arguments
 Args    : see below
 Status  : Protected</code></code></pre>

<h2 id="make_features_by_id_where_part">make_features_by_id_where_part</h2>

<pre><code><code> Title   : make_features_by_id_where_part
 Usage   : $db-&gt;make_features_by_id_where_part($ids)
 Function: create the SQL fragment needed to select a set of features by their ids
 Returns : a SQL fragment and bind arguments
 Args    : arrayref of IDs
 Status  : Protected</code></code></pre>

<h2 id="make_features_by_gid_where_part">make_features_by_gid_where_part</h2>

<pre><code><code> Title   : make_features_by_id_where_part
 Usage   : $db-&gt;make_features_by_gid_where_part($ids)
 Function: create the SQL fragment needed to select a set of features by their ids
 Returns : a SQL fragment and bind arguments
 Args    : arrayref of IDs
 Status  : Protected</code></code></pre>

<h2 id="make_features_from_part">make_features_from_part</h2>

<pre><code><code> Title   : make_features_from_part
 Usage   : $string = $db-&gt;make_features_from_part()
 Function: make from part of the features query
 Returns : a string
 Args    : none
 Status  : protected</code></code></pre>

<p>This method creates the part of the features query that immediately follows the FROM keyword.</p>

<h2 id="make_features_join_part">make_features_join_part</h2>

<pre><code><code> Title   : make_features_join_part
 Usage   : $string = $db-&gt;make_features_join_part()
 Function: make join part of the features query
 Returns : a string
 Args    : none
 Status  : protected</code></code></pre>

<p>This method creates the part of the features query that immediately follows the WHERE keyword.</p>

<h2 id="make_features_order_by_part">make_features_order_by_part</h2>

<pre><code><code> Title   : make_features_order_by_part
 Usage   : ($query,@args) = $db-&gt;make_features_order_by_part()
 Function: make the ORDER BY part of the features() query
 Returns : a SQL fragment and bind arguments, if any
 Args    : none
 Status  : protected</code></code></pre>

<p>This method creates the part of the features query that immediately follows the ORDER BY part of the query issued by features() and related methods.</p>

<h2 id="make_features_group_by_part">make_features_group_by_part</h2>

<pre><code><code> Title   : make_features_group_by_part
 Usage   : ($query,@args) = $db-&gt;make_features_group_by_part()
 Function: make the GROUP BY part of the features() query
 Returns : a SQL fragment and bind arguments, if any
 Args    : none
 Status  : protected</code></code></pre>

<p>This method creates the part of the features query that immediately follows the GROUP BY part of the query issued by features() and related methods.</p>

<h2 id="refseq_query">refseq_query</h2>

<pre><code><code> Title   : refseq_query
 Usage   : ($query,@args) = $db-&gt;refseq_query($name,$class)
 Function: create SQL fragment that selects the desired reference sequence
 Returns : a list containing the query and bind arguments
 Args    : reference sequence name and class
 Status  : protected</code></code></pre>

<p>This method is called by make_features_by_range_where_part() to construct the part of the select WHERE section that selects a particular reference sequence. It returns a mult-element list in which the first element is the SQL fragment and subsequent elements are bind values.</p>

<p>For example:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> refseq_query </span><span class="operator">{</span>
     <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$name</span><span class="operator">,</span><span class="variable">$class</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
     <span class="keyword">return</span> <span class="operator">(</span><span class="string">'gff.refseq=? AND gff.refclass=?'</span><span class="operator">,</span>
             <span class="variable">$name</span><span class="operator">,</span><span class="variable">$class</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The current schema does not distinguish among different classes of reference sequence.</p>

<h2 id="attributes">attributes</h2>

<pre><code><code> Title   : attributes
 Usage   : @attributes = $db-&gt;attributes($id,$name)
 Function: get the attributes on a particular feature
 Returns : an array of string
 Args    : feature ID
 Status  : public</code></code></pre>

<p>Some GFF version 2 files use the groups column to store a series of attribute/value pairs. In this interpretation of GFF, the first such pair is treated as the primary group for the feature; subsequent pairs are treated as attributes. Two attributes have special meaning: &quot;Note&quot; is for backward compatibility and is used for unstructured text remarks. &quot;Alias&quot; is considered as a synonym for the feature name.</p>

<p>If no name is provided, then attributes() returns a flattened hash, of attribute=&gt;value pairs. This lets you do:</p>

<pre><code><code>  <span class="variable">%attributes</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">attributes</span><span class="operator">(</span><span class="variable">$id</span><span class="operator">);</span>
</code></code></pre>

<p>Normally, attributes() will be called by the feature:</p>

<pre><code><code>  <span class="variable">@notes</span> <span class="operator">=</span> <span class="variable">$feature</span><span class="operator">-&gt;</span><span class="variable">attributes</span><span class="operator">(</span><span class="string">'Note'</span><span class="operator">);</span>
</code></code></pre>

<h2 id="overlap_query_nobin">overlap_query_nobin</h2>

<pre><code><code> Title   : overlap_query
 Usage   : ($query,@args) = $db-&gt;overlap_query($start,$stop)
 Function: create SQL fragment that selects the desired features by range
 Returns : a list containing the query and bind arguments
 Args    : the start and stop of a range, inclusive
 Status  : protected</code></code></pre>

<p>This method is called by make_features_byrange_where_part() to construct the part of the select WHERE section that selects a set of features that overlap a range. It returns a multi-element list in which the first element is the SQL fragment and subsequent elements are bind values.</p>

<p>sub overlap_query_nobin { my ($start,$stop) = @_; return (&#39;gff.stop&gt;=? AND gff.start&lt;=?&#39;, $start,$stop);</p>

<h2 id="contains_query_nobin">contains_query_nobin</h2>

<pre><code><code> Title   : contains_query
 Usage   : ($query,@args) = $db-&gt;contains_query_nobin($start,$stop)
 Function: create SQL fragment that selects the desired features by range
 Returns : a list containing the query and bind arguments
 Args    : the start and stop of a range, inclusive
 Status  : protected</code></code></pre>

<p>This method is called by make_features_byrange_where_part() to construct the part of the select WHERE section that selects a set of features entirely enclosed by a range. It returns a multi-element list in which the first element is the SQL fragment and subsequent elements are bind values. For example:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> contains_query_nobin </span><span class="operator">{</span>
     <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$start</span><span class="operator">,</span><span class="variable">$stop</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
     <span class="keyword">return</span> <span class="operator">(</span><span class="string">'gff.start&gt;=? AND gff.stop&lt;=?'</span><span class="operator">,</span>
             <span class="variable">$start</span><span class="operator">,</span><span class="variable">$stop</span><span class="operator">);</span>
</code></code></pre>

<h2 id="contained_in_query_nobin">contained_in_query_nobin</h2>

<pre><code><code> Title   : contained_in_query_nobin
 Usage   : ($query,@args) = $db-&gt;contained_in_query($start,$stop)
 Function: create SQL fragment that selects the desired features by range
 Returns : a list containing the query and bind arguments
 Args    : the start and stop of a range, inclusive
 Status  : protected</code></code></pre>

<p>This method is called by make_features_byrange_where_part() to construct the part of the select WHERE section that selects a set of features entirely enclosed by a range. It returns a multi-element list in which the first element is the SQL fragment and subsequent elements are bind values.For example:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> contained_in_query_nobin </span><span class="operator">{</span>
     <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$start</span><span class="operator">,</span><span class="variable">$stop</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
     <span class="keyword">return</span> <span class="operator">(</span><span class="string">'gff.start&lt;=? AND gff.stop&gt;=?'</span><span class="operator">,</span>
             <span class="variable">$start</span><span class="operator">,</span><span class="variable">$stop</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<h2 id="types_query">types_query</h2>

<pre><code><code> Title   : types_query
 Usage   : ($query,@args) = $db-&gt;types_query($types)
 Function: create SQL fragment that selects the desired features by type
 Returns : a list containing the query and bind arguments
 Args    : an array reference containing the types
 Status  : protected</code></code></pre>

<p>This method is called by make_features_byrange_where_part() to construct the part of the select WHERE section that selects a set of features based on their type. It returns a multi-element list in which the first element is the SQL fragment and subsequent elements are bind values. The argument is an array reference containing zero or more [$method,$source] pairs.</p>

<h2 id="make_types_select_part">make_types_select_part</h2>

<pre><code><code> Title   : make_types_select_part
 Usage   : ($string,@args) = $db-&gt;make_types_select_part(@args)
 Function: create the select portion of the SQL for fetching features type list
 Returns : query string and bind arguments
 Args    : see below
 Status  : protected</code></code></pre>

<p>This method is called by get_types() to generate the query fragment and bind arguments for the SELECT part of the query that retrieves lists of feature types. The four positional arguments are as follows:</p>

<pre><code><code> $refseq      reference sequence name
 $start       start of region
 $stop        end of region
 $want_count  true to return the count of this feature type</code></code></pre>

<p>If $want_count is false, the SQL fragment returned must produce a list of feature types in the format (method, source).</p>

<p>If $want_count is true, the returned fragment must produce a list of feature types in the format (method, source, count).</p>

<h2 id="make_types_from_part">make_types_from_part</h2>

<pre><code><code> Title   : make_types_from_part
 Usage   : ($string,@args) = $db-&gt;make_types_from_part(@args)
 Function: create the FROM portion of the SQL for fetching features type lists
 Returns : query string and bind arguments
 Args    : see below
 Status  : protected</code></code></pre>

<p>This method is called by get_types() to generate the query fragment and bind arguments for the FROM part of the query that retrieves lists of feature types. The four positional arguments are as follows:</p>

<pre><code><code> $refseq      reference sequence name
 $start       start of region
 $stop        end of region
 $want_count  true to return the count of this feature type</code></code></pre>

<p>If $want_count is false, the SQL fragment returned must produce a list of feature types in the format (method, source).</p>

<p>If $want_count is true, the returned fragment must produce a list of feature types in the format (method, source, count).</p>

<h2 id="make_types_join_part">make_types_join_part</h2>

<pre><code><code> Title   : make_types_join_part
 Usage   : ($string,@args) = $db-&gt;make_types_join_part(@args)
 Function: create the JOIN portion of the SQL for fetching features type lists
 Returns : query string and bind arguments
 Args    : see below
 Status  : protected</code></code></pre>

<p>This method is called by get_types() to generate the query fragment and bind arguments for the JOIN part of the query that retrieves lists of feature types. The four positional arguments are as follows:</p>

<pre><code><code> $refseq      reference sequence name
 $start       start of region
 $stop        end of region
 $want_count  true to return the count of this feature type</code></code></pre>

<h2 id="make_types_where_part">make_types_where_part</h2>

<pre><code><code> Title   : make_types_where_part
 Usage   : ($string,@args) = $db-&gt;make_types_where_part(@args)
 Function: create the WHERE portion of the SQL for fetching features type lists
 Returns : query string and bind arguments
 Args    : see below
 Status  : protected</code></code></pre>

<p>This method is called by get_types() to generate the query fragment and bind arguments for the WHERE part of the query that retrieves lists of feature types. The four positional arguments are as follows:</p>

<pre><code><code> $refseq      reference sequence name
 $start       start of region
 $stop        end of region
 $want_count  true to return the count of this feature type</code></code></pre>

<h2 id="make_types_group_part">make_types_group_part</h2>

<pre><code><code> Title   : make_types_group_part
 Usage   : ($string,@args) = $db-&gt;make_types_group_part(@args)
 Function: create the GROUP BY portion of the SQL for fetching features type lists
 Returns : query string and bind arguments
 Args    : see below
 Status  : protected</code></code></pre>

<p>This method is called by get_types() to generate the query fragment and bind arguments for the GROUP BY part of the query that retrieves lists of feature types. The four positional arguments are as follows:</p>

<pre><code><code> $refseq      reference sequence name
 $start       start of region
 $stop        end of region
 $want_count  true to return the count of this feature type</code></code></pre>

<h2 id="get_feature_id">get_feature_id</h2>

<pre><code><code> Title   : get_feature_id
 Usage   : $integer = $db-&gt;get_feature_id($ref,$start,$stop,$typeid,$groupid)
 Function: get the ID of a feature
 Returns : an integer ID or undef
 Args    : none
 Status  : private</code></code></pre>

<p>This internal method is called by load_gff_line to look up the integer ID of an existing feature. It is ony needed when replacing a feature with new information.</p>

<h2 id="make_abscoord_query">make_abscoord_query</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">make_abscoord_query</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">make_abscoord_query</span><span class="operator">(</span><span class="variable">$name</span><span class="operator">,</span><span class="variable">$class</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">create</span> <span class="variable">query</span> <span class="variable">that</span> <span class="variable">finds</span> <span class="variable">the</span> <span class="variable">reference</span> <span class="variable">sequence</span> <span class="variable">coordinates</span> <span class="keyword">given</span> <span class="variable">a</span> <span class="variable">landmark</span> <span class="operator">&amp;</span> <span class="variable">classa</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">a</span> <span class="variable">DBI</span> <span class="variable">statement</span> <span class="variable">handle</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">name</span> <span class="keyword">and</span> <span class="variable">class</span> <span class="variable">of</span> <span class="variable">landmark</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">protected</span>
</code></code></pre>

<p>The statement handler should return rows containing five fields:</p>

<pre><code><code>  1. reference sequence name
  2. reference sequence class
  3. start position
  4. stop position
  5. strand (&quot;+&quot; or &quot;-&quot;)</code></code></pre>

<p>This query always returns &quot;Sequence&quot; as the class of the reference sequence.</p>

<h2 id="feature_summary">feature_summary</h2>

<pre><code><code> Title   : feature_summary
 Usage   : $summary = $db-&gt;feature_summary(@args)
 Function: returns a coverage summary across indicated region/type
 Returns : a Bio::SeqFeatureI object containing the &quot;coverage&quot; tag
 Args    : see below
 Status  : public</code></code></pre>

<p>This method is used to get coverage density information across a region of interest. You provide it with a region of interest, optional a list of feature types, and a count of the number of bins over which you want to calculate the coverage density. An object is returned corresponding to the requested region. It contains a tag called &quot;coverage&quot; that will return an array ref of &quot;bins&quot; length. Each element of the array describes the number of features that overlap the bin at this postion.</p>

<p>Arguments:</p>

<pre><code><code>  Argument       Description
  --------       -----------

  -seq_id        Sequence ID for the region
  -start         Start of region
  -end           End of region
  -type/-types   Feature type of interest or array ref of types
  -bins          Number of bins across region. Defaults to 1000.
  -iterator      Return an iterator across the region</code></code></pre>

<p>Note that this method uses an approximate algorithm that is only accurate to 500 bp, so when dealing with bins that are smaller than 1000 bp, you may see some shifting of counts between adjacent bins.</p>

<p>Although an -iterator option is provided, the method only ever returns a single feature, so this is fairly useless.</p>

<h2 id="coverage_array">coverage_array</h2>

<pre><code><code> Title   : coverage_array
 Usage   : $arrayref = $db-&gt;coverage_array(@args)
 Function: returns a coverage summary across indicated region/type
 Returns : an array reference
 Args    : see below
 Status  : public</code></code></pre>

<p>This method is used to get coverage density information across a region of interest. The arguments are identical to feature_summary, except that instead of returning a Bio::SeqFeatureI object, it returns an array reference of the desired number of bins. The value of each element corresponds to the number of features in the bin.</p>

<p>Arguments:</p>

<pre><code><code>  Argument       Description
  --------       -----------

  -seq_id        Sequence ID for the region
  -start         Start of region
  -end           End of region
  -type/-types   Feature type of interest or array ref of types
  -bins          Number of bins across region. Defaults to 1000.</code></code></pre>

<p>Note that this method uses an approximate algorithm that is only accurate to 500 bp, so when dealing with bins that are smaller than 1000 bp, you may see some shifting of counts between adjacent bins.</p>

<h2 id="build_summary_statistics">build_summary_statistics</h2>

<pre><code><code> Title   : build_summary_statistics
 Usage   : $db-&gt;build_summary_statistics
 Function: prepares the table needed to call feature_summary()
 Returns : nothing
 Args    : none
 Status  : public</code></code></pre>

<p>This method is used to build the summary statistics table that is used by the feature_summary() and coverage_array() methods. It needs to be called whenever the database is updated.</p>

<h1 id="BUGS">BUGS</h1>

<p>Schemas need work to support multiple hierarchical groups.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../../../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF.html">Bio::DB::GFF</a>, <a>bioperl</a></p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Lincoln Stein &lt;lstein@cshl.org&gt;.</p>

<p>Copyright (c) 2001 Cold Spring Harbor Laboratory.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>


</body>

</html>


