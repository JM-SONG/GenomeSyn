<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Auxiliary-Scripts">Auxiliary Scripts</a></li>
      <li><a href="#GFF-Fundamentals">GFF Fundamentals</a></li>
      <li><a href="#Making-GFF-files-work-with-this-module">Making GFF files work with this module</a></li>
      <li><a href="#Specifying-the-group-tag">Specifying the group tag</a></li>
      <li><a href="#Sequence-alignments">Sequence alignments</a></li>
      <li><a href="#Attributes">Attributes</a></li>
      <li><a href="#Adaptors-and-Aggregators">Adaptors and Aggregators</a></li>
      <li><a href="#Loading-GFF3-Files">Loading GFF3 Files</a></li>
    </ul>
  </li>
  <li><a href="#API">API</a></li>
  <li><a href="#Querying-GFF-Databases">Querying GFF Databases</a>
    <ul>
      <li><a href="#new">new</a></li>
      <li><a href="#types">types</a></li>
      <li><a href="#classes">classes</a></li>
      <li><a href="#segment">segment</a></li>
      <li><a href="#features">features</a></li>
      <li><a href="#get_seq_stream">get_seq_stream</a></li>
      <li><a href="#get_feature_by_name">get_feature_by_name</a></li>
      <li><a href="#get_feature_by_target">get_feature_by_target</a></li>
      <li><a href="#get_feature_by_attribute">get_feature_by_attribute</a></li>
      <li><a href="#get_feature_by_id">get_feature_by_id</a></li>
      <li><a href="#get_feature_by_gid">get_feature_by_gid</a></li>
      <li><a href="#delete_fattribute_to_features">delete_fattribute_to_features</a></li>
      <li><a href="#delete_features">delete_features</a></li>
      <li><a href="#delete_groups">delete_groups</a></li>
      <li><a href="#delete">delete</a></li>
      <li><a href="#absolute">absolute</a></li>
      <li><a href="#strict_bounds_checking">strict_bounds_checking</a></li>
      <li><a href="#get_Seq_by_id">get_Seq_by_id</a></li>
      <li><a href="#get_Seq_by_accession">get_Seq_by_accession</a></li>
      <li><a href="#get_Seq_by_acc">get_Seq_by_acc</a></li>
      <li><a href="#get_Stream_by_name">get_Stream_by_name</a></li>
      <li><a href="#get_Stream_by_id">get_Stream_by_id</a></li>
      <li><a href="#get_Stream_by_batch-">get_Stream_by_batch ()</a></li>
      <li><a href="#get_Stream_by_group-">get_Stream_by_group ()</a></li>
      <li><a href="#all_seqfeatures">all_seqfeatures</a></li>
    </ul>
  </li>
  <li><a href="#Creating-and-Loading-GFF-Databases">Creating and Loading GFF Databases</a>
    <ul>
      <li><a href="#initialize">initialize</a></li>
      <li><a href="#load_gff">load_gff</a></li>
      <li><a href="#load_gff_file">load_gff_file</a></li>
      <li><a href="#load_fasta">load_fasta</a></li>
      <li><a href="#load_fasta_file">load_fasta_file</a></li>
      <li><a href="#load_sequence_string">load_sequence_string</a></li>
      <li><a href="#lock_on_load">lock_on_load</a></li>
      <li><a href="#meta">meta</a></li>
      <li><a href="#default_meta_values">default_meta_values</a></li>
      <li><a href="#error">error</a></li>
      <li><a href="#debug">debug</a></li>
      <li><a href="#automerge">automerge</a></li>
      <li><a href="#attributes">attributes</a></li>
      <li><a href="#fast_queries">fast_queries</a></li>
      <li><a href="#add_aggregator">add_aggregator</a></li>
      <li><a href="#aggregators">aggregators</a></li>
      <li><a href="#clear_aggregators">clear_aggregators</a></li>
      <li><a href="#preferred_groups">preferred_groups</a></li>
    </ul>
  </li>
  <li><a href="#Methods-for-use-by-Subclasses">Methods for use by Subclasses</a>
    <ul>
      <li><a href="#abscoords">abscoords</a></li>
    </ul>
  </li>
  <li><a href="#Protected-API">Protected API</a>
    <ul>
      <li><a href="#default_aggregators">default_aggregators</a></li>
      <li><a href="#do_load_gff">do_load_gff</a></li>
      <li><a href="#load_sequence">load_sequence</a></li>
      <li><a href="#setup_load">setup_load</a></li>
      <li><a href="#finish_load">finish_load</a></li>
      <li><a href="#load_gff_line">load_gff_line</a></li>
      <li><a href="#do_initialize">do_initialize</a></li>
      <li><a href="#dna">dna</a></li>
      <li><a href="#get_dna">get_dna</a></li>
      <li><a href="#get_features">get_features</a></li>
      <li><a href="#feature_summary-coverage_array-">feature_summary(), coverage_array()</a></li>
      <li><a href="#feature_by_name">_feature_by_name</a></li>
      <li><a href="#feature_by_id">_feature_by_id</a></li>
      <li><a href="#overlapping_features">overlapping_features</a></li>
      <li><a href="#contained_features">contained_features</a></li>
      <li><a href="#contained_in">contained_in</a></li>
      <li><a href="#get_abscoords">get_abscoords</a></li>
      <li><a href="#get_types">get_types</a></li>
      <li><a href="#make_feature">make_feature</a></li>
      <li><a href="#make_match_sub">make_match_sub</a></li>
      <li><a href="#make_object">make_object</a></li>
      <li><a href="#do_attributes">do_attributes</a></li>
      <li><a href="#clone">clone</a></li>
    </ul>
  </li>
  <li><a href="#Internal-Methods">Internal Methods</a>
    <ul>
      <li><a href="#features1">_features</a></li>
      <li><a href="#get_features_iterator">get_features_iterator</a></li>
      <li><a href="#split_group">split_group</a></li>
      <li><a href="#split_gff2_group">_split_gff2_group</a></li>
      <li><a href="#gff3_name_munging">gff3_name_munging</a></li>
      <li><a href="#split_gff3_group">_split_gff3_group</a></li>
      <li><a href="#delete_features-_delete_groups-_delete-_delete_fattribute_to_features-">_delete_features(), _delete_groups(),_delete(),_delete_fattribute_to_features()</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Bio::DB::GFF -- Storage and retrieval of sequence annotation data</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Bio::DB::GFF</span><span class="operator">;</span>
  
  <span class="comment"># Open the sequence database</span>
  <span class="keyword">my</span> <span class="variable">$db</span>      <span class="operator">=</span> <span class="variable">Bio::DB::GFF</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">-adaptor</span> <span class="operator">=&gt;</span> <span class="string">'dbi::mysqlopt'</span><span class="operator">,</span>
                                   <span class="string">-dsn</span>     <span class="operator">=&gt;</span> <span class="string">'dbi:mysql:elegans'</span><span class="operator">);</span>
  
  <span class="comment"># fetch a 1 megabase segment of sequence starting at landmark "ZK909"</span>
  <span class="keyword">my</span> <span class="variable">$segment</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="string">'ZK909'</span><span class="operator">,</span> <span class="number">1</span> <span class="operator">=&gt;</span> <span class="number">1000000</span><span class="operator">);</span>
  
  <span class="comment"># pull out all transcript features</span>
  <span class="keyword">my</span> <span class="variable">@transcripts</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">'transcript'</span><span class="operator">);</span>
  
  <span class="comment"># for each transcript, total the length of the introns</span>
  <span class="keyword">my</span> <span class="variable">%totals</span><span class="operator">;</span>
  <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$t</span> <span class="operator">(</span><span class="variable">@transcripts</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">@introns</span> <span class="operator">=</span> <span class="variable">$t</span><span class="operator">-&gt;</span><span class="variable">Intron</span><span class="operator">;</span>
    <span class="variable">$totals</span><span class="operator">{</span><span class="variable">$t</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">}</span> <span class="operator">+=</span> <span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">length</span> <span class="keyword">foreach</span> <span class="variable">@introns</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="comment"># Sort the exons of the first transcript by position</span>
  <span class="keyword">my</span> <span class="variable">@exons</span> <span class="operator">=</span> <span class="keyword">sort</span> <span class="operator">{</span><span class="variable">$a</span><span class="operator">-&gt;</span><span class="variable">start</span> <span class="operator">&lt;=&gt;</span> <span class="variable">$b</span><span class="operator">-&gt;</span><span class="variable">start</span><span class="operator">}</span> <span class="variable">$transcripts</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">-&gt;</span><span class="variable">Exon</span><span class="operator">;</span>
  
  <span class="comment"># Get a region 1000 bp upstream of first exon</span>
  <span class="keyword">my</span> <span class="variable">$upstream</span> <span class="operator">=</span> <span class="variable">$exons</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">-&gt;</span><span class="variable">subseq</span><span class="operator">(-</span><span class="number">1000</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
  
  <span class="comment"># get its DNA</span>
  <span class="keyword">my</span> <span class="variable">$dna</span> <span class="operator">=</span> <span class="variable">$upstream</span><span class="operator">-&gt;</span><span class="variable">seq</span><span class="operator">;</span>
  
  <span class="comment"># and get all curated polymorphisms inside it</span>
  <span class="variable">@polymorphisms</span> <span class="operator">=</span> <span class="variable">$upstream</span><span class="operator">-&gt;</span><span class="variable">contained_features</span><span class="operator">(</span><span class="string">'polymorphism:curated'</span><span class="operator">);</span>
  
  <span class="comment"># get all feature types in the database</span>
  <span class="keyword">my</span> <span class="variable">@types</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">types</span><span class="operator">;</span>
  
  <span class="comment"># count all feature types in the segment</span>
  <span class="keyword">my</span> <span class="variable">%type_counts</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">types</span><span class="operator">(</span><span class="string">-enumerate</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">);</span>
  
  <span class="comment"># get an iterator on all curated features of type 'exon' or 'intron'</span>
  <span class="keyword">my</span> <span class="variable">$iterator</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_seq_stream</span><span class="operator">(</span><span class="string">-type</span>     <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">'exon:curated'</span><span class="operator">,</span><span class="string">'intron:curated'</span><span class="operator">]</span><span class="operator">);</span>
  
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$s</span> <span class="operator">=</span> <span class="variable">$iterator</span><span class="operator">-&gt;</span><span class="variable">next_seq</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="variable">$s</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="comment"># find all transcripts annotated as having function 'kinase'</span>
  <span class="keyword">my</span> <span class="variable">$iterator</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_seq_stream</span><span class="operator">(</span><span class="string">-type</span><span class="operator">=&gt;</span><span class="string">'transcript'</span><span class="operator">,</span>
                                     <span class="string">-attributes</span><span class="operator">=&gt;</span><span class="operator">{</span><span class="string">Function</span><span class="operator">=&gt;</span><span class="string">'kinase'</span><span class="operator">}</span><span class="operator">);</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$s</span> <span class="operator">=</span> <span class="variable">$iterator</span><span class="operator">-&gt;</span><span class="variable">next_seq</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="variable">$s</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Bio::DB::GFF provides fast indexed access to a sequence annotation database. It supports multiple database types (ACeDB, relational), and multiple schemas through a system of adaptors and aggregators.</p>

<p>The following operations are supported by this module:</p>

<pre><code><code>  - retrieving a segment of sequence based on the ID of a landmark
  - retrieving the DNA from that segment
  - finding all annotations that overlap with the segment
  - finding all annotations that are completely contained within the
    segment
  - retrieving all annotations of a particular type, either within a
    segment, or globally
  - conversion from absolute to relative coordinates and back again,
    using any arbitrary landmark for the relative coordinates
  - using a sequence segment to create new segments based on relative 
    offsets</code></code></pre>

<p>The data model used by Bio::DB::GFF is compatible with the GFF flat file format (<a href="http://www.sequenceontology.org/gff3.shtml">http://www.sequenceontology.org/gff3.shtml</a>). The module can load a set of GFF files into the database, and serves objects that have methods corresponding to GFF fields.</p>

<p>The objects returned by Bio::DB::GFF are compatible with the SeqFeatureI interface, allowing their use by the Bio::Graphics and Bio::DAS modules.</p>

<h2 id="Auxiliary-Scripts">Auxiliary Scripts</h2>

<p>The bioperl distribution includes several scripts that make it easier to work with Bio::DB::GFF databases. They are located in the scripts directory under a subdirectory named Bio::DB::GFF:</p>

<ul>

<li><p>bp_load_gff.pl</p>

<p>This script will load a Bio::DB::GFF database from a flat GFF file of sequence annotations. Only the relational database version of Bio::DB::GFF is supported. It can be used to create the database from scratch, as well as to incrementally load new data.</p>

<p>This script takes a --fasta argument to load raw DNA into the database as well. However, GFF databases do not require access to the raw DNA for most of their functionality.</p>

<p>load_gff.pl also has a --upgrade option, which will perform a non-destructive upgrade of older schemas to newer ones.</p>

</li>
<li><p>bp_bulk_load_gff.pl</p>

<p>This script will populate a Bio::DB::GFF database from a flat GFF file of sequence annotations. Only the MySQL database version of Bio::DB::GFF is supported. It uses the &quot;LOAD DATA INFILE&quot; query in order to accelerate loading considerably; however, it can only be used for the initial load, and not for updates.</p>

<p>This script takes a --fasta argument to load raw DNA into the database as well. However, GFF databases do not require access to the raw DNA for most of their functionality.</p>

</li>
<li><p>bp_fast_load_gff.pl</p>

<p>This script is as fast as bp_bulk_load_gff.pl but uses Unix pipe tricks to allow for incremental updates. It only supports the MySQL database version of Bio::DB::GFF and is guaranteed not to work on non-Unix platforms.</p>

<p>Arguments are the same as bp_load_gff.pl</p>

</li>
<li><p>gadfly_to_gff.pl</p>

<p>This script will convert the GFF-like format used by the Berkeley Drosophila Sequencing project into a format suitable for use with this module.</p>

</li>
<li><p>sgd_to_gff.pl</p>

<p>This script will convert the tab-delimited feature files used by the Saccharomyces Genome Database into a format suitable for use with this module.</p>

</li>
</ul>

<h2 id="GFF-Fundamentals">GFF Fundamentals</h2>

<p>The GFF format is a flat tab-delimited file, each line of which corresponds to an annotation, or feature. Each line has nine columns and looks like this:</p>

<pre><code><code> Chr1  curated  CDS 365647  365963  .  +  1  Transcript &quot;R119.7&quot;</code></code></pre>

<p>The 9 columns are as follows:</p>

<ol>

<li><p>reference sequence</p>

<p>This is the ID of the sequence that is used to establish the coordinate system of the annotation. In the example above, the reference sequence is &quot;Chr1&quot;.</p>

</li>
<li><p>source</p>

<p>The source of the annotation. This field describes how the annotation was derived. In the example above, the source is &quot;curated&quot; to indicate that the feature is the result of human curation. The names and versions of software programs are often used for the source field, as in &quot;tRNAScan-SE/1.2&quot;.</p>

</li>
<li><p>method</p>

<p>The annotation method. This field describes the type of the annotation, such as &quot;CDS&quot;. Together the method and source describe the annotation type.</p>

</li>
<li><p>start position</p>

<p>The start of the annotation relative to the reference sequence.</p>

</li>
<li><p>stop position</p>

<p>The stop of the annotation relative to the reference sequence. Start is always less than or equal to stop.</p>

</li>
<li><p>score</p>

<p>For annotations that are associated with a numeric score (for example, a sequence similarity), this field describes the score. The score units are completely unspecified, but for sequence similarities, it is typically percent identity. Annotations that don&#39;t have a score can use &quot;.&quot;</p>

</li>
<li><p>strand</p>

<p>For those annotations which are strand-specific, this field is the strand on which the annotation resides. It is &quot;+&quot; for the forward strand, &quot;-&quot; for the reverse strand, or &quot;.&quot; for annotations that are not stranded.</p>

</li>
<li><p>phase</p>

<p>For annotations that are linked to proteins, this field describes the phase of the annotation on the codons. It is a number from 0 to 2, or &quot;.&quot; for features that have no phase.</p>

</li>
<li><p>group</p>

<p>GFF provides a simple way of generating annotation hierarchies (&quot;is composed of&quot; relationships) by providing a group field. The group field contains the class and ID of an annotation which is the logical parent of the current one. In the example given above, the group is the Transcript named &quot;R119.7&quot;.</p>

<p>The group field is also used to store information about the target of sequence similarity hits, and miscellaneous notes. See the next section for a description of how to describe similarity targets.</p>

<p>The format of the group fields is &quot;Class ID&quot; with a single space (not a tab) separating the class from the ID. It is VERY IMPORTANT to follow this format, or grouping will not work properly.</p>

</li>
</ol>

<p>The sequences used to establish the coordinate system for annotations can correspond to sequenced clones, clone fragments, contigs or super-contigs. Thus, this module can be used throughout the lifecycle of a sequencing project.</p>

<p>In addition to a group ID, the GFF format allows annotations to have a group class. For example, in the ACeDB representation, RNA interference experiments have a class of &quot;RNAi&quot; and an ID that is unique among the RNAi experiments. Since not all databases support this notion, the class is optional in all calls to this module, and defaults to &quot;Sequence&quot; when not provided.</p>

<p>Double-quotes are sometimes used in GFF files around components of the group field. Strictly, this is only necessary if the group name or class contains whitespace.</p>

<h2 id="Making-GFF-files-work-with-this-module">Making GFF files work with this module</h2>

<p>Some annotations do not need to be individually named. For example, it is probably not useful to assign a unique name to each ALU repeat in a vertebrate genome. Others, such as predicted genes, correspond to named biological objects; you probably want to be able to fetch the positions of these objects by referring to them by name.</p>

<p>To accommodate named annotations, the GFF format places the object class and name in the group field. The name identifies the object, and the class prevents similarly-named objects, for example clones and sequences, from collding.</p>

<p>A named object is shown in the following excerpt from a GFF file:</p>

<pre><code><code> Chr1  curated transcript  939627 942410 . +  . Transcript Y95B8A.2</code></code></pre>

<p>This object is a predicted transcript named Y95BA.2. In this case, the group field is used to identify the class and name of the object, even though no other annotation belongs to that group.</p>

<p>It now becomes possible to retrieve the region of the genome covered by transcript Y95B8A.2 using the segment() method:</p>

<pre><code><code>  <span class="variable">$segment</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="string">-class</span><span class="operator">=&gt;</span><span class="string">'Transcript'</span><span class="operator">,</span><span class="string">-name</span><span class="operator">=&gt;</span><span class="string">'Y95B8A.2'</span><span class="operator">);</span>
</code></code></pre>

<p>It is not necessary for the annotation&#39;s method to correspond to the object class, although this is commonly the case.</p>

<p>As explained above, each annotation in a GFF file refers to a reference sequence. It is important that each reference sequence also be identified by a line in the GFF file. This allows the Bio::DB::GFF module to determine the length and class of the reference sequence, and makes it possible to do relative arithmetic.</p>

<p>For example, if &quot;Chr1&quot; is used as a reference sequence, then it should have an entry in the GFF file similar to this one:</p>

<pre><code><code> Chr1 assembly chromosome 1 14972282 . + . Sequence Chr1</code></code></pre>

<p>This indicates that the reference sequence named &quot;Chr1&quot; has length 14972282 bp, method &quot;chromosome&quot; and source &quot;assembly&quot;. In addition, as indicated by the group field, Chr1 has class &quot;Sequence&quot; and name &quot;Chr1&quot;.</p>

<p>The object class &quot;Sequence&quot; is used by default when the class is not specified in the segment() call. This allows you to use a shortcut form of the segment() method:</p>

<pre><code><code> <span class="variable">$segment</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="string">'Chr1'</span><span class="operator">);</span>          <span class="comment"># whole chromosome</span>
 <span class="variable">$segment</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="string">'Chr1'</span><span class="operator">,</span><span class="number">1</span><span class="operator">=&gt;</span><span class="number">1000</span><span class="operator">);</span>  <span class="comment"># first 1000 bp</span>
</code></code></pre>

<p>For your convenience, if, during loading a GFF file, Bio::DB::GFF encounters a line like the following:</p>

<pre><code><code>  <span class="comment">##sequence-region Chr1 1 14972282</span>
</code></code></pre>

<p>It will automatically generate the following entry:</p>

<pre><code><code> Chr1 reference Component 1 14972282 . + . Sequence Chr1</code></code></pre>

<p>This is sufficient to use Chr1 as a reference point. The ##sequence-region line is frequently found in the GFF files distributed by annotation groups.</p>

<h2 id="Specifying-the-group-tag">Specifying the group tag</h2>

<p>A frequent problem with GFF files is the problem distinguishing which of the several tag/value pairs in the 9th column is the grouping pair. Ordinarily the first tag will be used for grouping, but some GFF manipulating tools do not preserve the order of attributes. To eliminate this ambiguity, this module provides two ways of explicitly specifying which tag to group on:</p>

<ul>

<li><p>Using -preferred_groups</p>

<p>When you create a Bio::DB::GFF object, pass it a -preferred_groups=&gt; argument. This specifies a tag that will be used for grouping. You can pass an array reference to specify a list of such tags.</p>

</li>
<li><p>In the GFF header</p>

<p>The GFF file itself can specify which tags are to be used for grouping. Insert a comment like the following:</p>

<pre><code><code> <span class="comment">##group-tags Accession Locus</span>
</code></code></pre>

<p>This says to use the Accession tag for grouping. If it is not available, use the Locus tag. If neither tag is available, use the first pair to appear.</p>

</li>
</ul>

<p>These options only apply when <b>loading</b> a GFF file into the database, and have no effect on existing databases.</p>

<p>The group-tags comment in the GFF file will *override* the preferred groups set when you create the Bio::DB::GFF object.</p>

<p>For backward compatibility, the tags Sequence and Transcript are always treated as grouping tags unless preferred_tags are specified. The &quot;Target&quot; tag is always used for grouping regardless of the preferred_groups() setting, and the tags &quot;tstart&quot;, &quot;tend&quot; and &quot;Note&quot; cannot be used for grouping. These are historical artefacts coming from various interpretations of GFF2, and cannot be changed.</p>

<h2 id="Sequence-alignments">Sequence alignments</h2>

<p>There are two cases in which an annotation indicates the relationship between two sequences. The first case is a similarity hit, where the annotation indicates an alignment. The second case is a map assembly, in which the annotation indicates that a portion of a larger sequence is built up from one or more smaller ones.</p>

<p>Both cases are indicated by using the <b>Target</b> tag in the group field. For example, a typical similarity hit will look like this:</p>

<pre><code><code> Chr1 BLASTX similarity 76953 77108 132 + 0 Target Protein:SW:ABL_DROME 493 544</code></code></pre>

<p>The group field contains the Target tag, followed by an identifier for the biological object referred to. The GFF format uses the notation <i>Class</i>:<i>Name</i> for the biological object, and even though this is stylistically inconsistent, that&#39;s the way it&#39;s done. The object identifier is followed by two integers indicating the start and stop of the alignment on the target sequence.</p>

<p>Unlike the main start and stop columns, it is possible for the target start to be greater than the target end. The previous example indicates that the the section of Chr1 from 76,953 to 77,108 aligns to the protein SW:ABL_DROME starting at position 493 and extending to position 544.</p>

<p>A similar notation is used for sequence assembly information as shown in this example:</p>

<pre><code><code> Chr1        assembly Link   10922906 11177731 . . . Target Sequence:LINK_H06O01 1 254826
 LINK_H06O01 assembly Cosmid 32386    64122    . . . Target Sequence:F49B2       6 31742</code></code></pre>

<p>This indicates that the region between bases 10922906 and 11177731 of Chr1 are composed of LINK_H06O01 from bp 1 to bp 254826. The region of LINK_H0601 between 32386 and 64122 is, in turn, composed of the bases 5 to 31742 of cosmid F49B2.</p>

<h2 id="Attributes">Attributes</h2>

<p>While not intended to serve as a general-purpose sequence database (see bioperl-db for that), GFF allows you to tag features with arbitrary attributes. Attributes appear in the Group field following the initial class/name pair. For example:</p>

<pre><code><code> <span class="variable">Chr1</span>  <span class="variable">cur</span> <span class="variable">trans</span>  <span class="number">939</span> <span class="number">942</span> <span class="operator">.</span> <span class="operator">+</span>  <span class="operator">.</span> <span class="variable">Transcript</span> <span class="variable">Y95B8A</span><span class="number">.2</span> <span class="operator">;</span> <span class="variable">Gene</span> <span class="variable">sma</span><span class="operator">-</span><span class="number">3</span> <span class="operator">;</span> <span class="variable">Alias</span> <span class="variable">sma3</span>
</code></code></pre>

<p>This line tags the feature named Transcript Y95B8A.2 as being &quot;Gene&quot; named sma-3 and having the Alias &quot;sma3&quot;. Features having these attributes can be looked up using the fetch_feature_by_attribute() method.</p>

<p>Two attributes have special meaning: &quot;Note&quot; is for backward compatibility and is used for unstructured text remarks. &quot;Alias&quot; is considered as a synonym for the feature name and will be consulted when looking up a feature by its name.</p>

<h2 id="Adaptors-and-Aggregators">Adaptors and Aggregators</h2>

<p>This module uses a system of adaptors and aggregators in order to make it adaptable to use with a variety of databases.</p>

<ul>

<li><p>Adaptors</p>

<p>The core of the module handles the user API, annotation coordinate arithmetic, and other common issues. The details of fetching information from databases is handled by an adaptor, which is specified during Bio::DB::GFF construction. The adaptor encapsulates database-specific information such as the schema, user authentication and access methods.</p>

<p>There are currently five adaptors recommended for general use:</p>

<pre><code><code>  Adaptor Name             Description
  ------------             -----------

  memory                   A simple in-memory database suitable for testing
                            and small data sets.

  berkeleydb               An indexed file database based on the DB_File module,
                            suitable for medium-sized read-only data sets.

  dbi::mysql               An interface to a schema implemented in the Mysql
                            relational database management system.

  dbi::oracle              An interface to a schema implemented in the Oracle
                            relational database management system.

  dbi::pg                  An interface to a schema implemented in the PostgreSQL
                            relational database management system.</code></code></pre>

<p>Check the Bio/DB/GFF/Adaptor directory and subdirectories for other, more specialized adaptors, as well as experimental ones.</p>

</li>
<li><p>Aggregators</p>

<p>The GFF format uses a &quot;group&quot; field to indicate aggregation properties of individual features. For example, a set of exons and introns may share a common transcript group, and multiple transcripts may share the same gene group.</p>

<p>Aggregators are small modules that use the group information to rebuild the hierarchy. When a Bio::DB::GFF object is created, you indicate that it use a set of one or more aggregators. Each aggregator provides a new composite annotation type. Before the database query is generated each aggregator is called to &quot;disaggregate&quot; its annotation type into list of component types contained in the database. After the query is generated, each aggregator is called again in order to build composite annotations from the returned components.</p>

<p>For example, during disaggregation, the standard &quot;processed_transcript&quot; aggregator generates a list of component feature types including &quot;UTR&quot;, &quot;CDS&quot;, and &quot;polyA_site&quot;. Later, it aggregates these features into a set of annotations of type &quot;processed_transcript&quot;.</p>

<p>During aggregation, the list of aggregators is called in reverse order. This allows aggregators to collaborate to create multi-level structures: the transcript aggregator assembles transcripts from introns and exons; the gene aggregator then assembles genes from sets of transcripts.</p>

<p>Three default aggregators are provided:</p>

<pre><code><code>      transcript   assembles transcripts from features of type
                   exon, CDS, 5&#39;UTR, 3&#39;UTR, TSS, and PolyA
      clone        assembles clones from Clone_left_end, Clone_right_end
                   and Sequence features.
      alignment    assembles gapped alignments from features of type
                   &quot;similarity&quot;.</code></code></pre>

<p>In addition, this module provides the optional &quot;wormbase_gene&quot; aggregator, which accommodates the WormBase representation of genes. This aggregator aggregates features of method &quot;exon&quot;, &quot;CDS&quot;, &quot;5&#39;UTR&quot;, &quot;3&#39;UTR&quot;, &quot;polyA&quot; and &quot;TSS&quot; into a single object. It also expects to find a single feature of type &quot;Sequence&quot; that spans the entire gene.</p>

<p>The existing aggregators are easily customized.</p>

<p>Note that aggregation will not occur unless you specifically request the aggregation type. For example, this call:</p>

<pre><code><code>  <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">(</span><span class="string">'alignment'</span><span class="operator">);</span>
</code></code></pre>

<p>will generate an array of aggregated alignment features. However, this call:</p>

<pre><code><code>  <span class="variable">@features</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">features</span><span class="operator">();</span>
</code></code></pre>

<p>will return a list of unaggregated similarity segments.</p>

<p>For more informnation, see the manual pages for Bio::DB::GFF::Aggregator::processed_transcript, Bio::DB::GFF::Aggregator::clone, etc.</p>

</li>
</ul>

<h2 id="Loading-GFF3-Files">Loading GFF3 Files</h2>

<p>This module will accept GFF3 files, as described at http://song.sourceforge.net/gff3.shtml. However, the implementation has some limitations.</p>

<dl>

<dt id="GFF-version-string-is-required">GFF version string is required</dt>
<dd>

<p>The GFF file <b>must</b> contain the version comment:</p>

<pre><code><code> <span class="comment">##gff-version 3</span>
</code></code></pre>

<p>Unless this version string is present at the top of the GFF file, the loader will attempt to parse the file in GFF2 format, with less-than-desirable results.</p>

</dd>
<dt id="Only-one-level-of-nesting-allowed">Only one level of nesting allowed</dt>
<dd>

<p>A major restriction is that Bio::DB::GFF only allows one level of nesting of features. For nesting, the Target tag will be used preferentially followed by the ID tag, followed by the Parent tag. This means that if genes are represented like this:</p>

<pre><code><code>  <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">gene</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">ID</span><span class="operator">=</span><span class="variable">myGene</span>
  <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">mRNA</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">ID</span><span class="operator">=</span><span class="variable">myTranscript</span><span class="operator">;</span><span class="variable">Parent</span><span class="operator">=</span><span class="variable">myGene</span>
  <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">exon</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">Parent</span><span class="operator">=</span><span class="variable">myTranscript</span>
  <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">exon</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">Parent</span><span class="operator">=</span><span class="variable">myTranscript</span>
</code></code></pre>

<p>Then there will be one group called myGene containing the &quot;gene&quot; feature and one group called myTranscript containing the mRNA, and two exons.</p>

<p>You can work around this restriction to some extent by using the Alias attribute literally:</p>

<pre><code><code>  <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">gene</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">ID</span><span class="operator">=</span><span class="variable">myGene</span>
  <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">mRNA</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">ID</span><span class="operator">=</span><span class="variable">myTranscript</span><span class="operator">;</span><span class="variable">Parent</span><span class="operator">=</span><span class="variable">myGene</span><span class="operator">;</span><span class="variable">Alias</span><span class="operator">=</span><span class="variable">myGene</span>
  <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">exon</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">Parent</span><span class="operator">=</span><span class="variable">myTranscript</span><span class="operator">;</span><span class="variable">Alias</span><span class="operator">=</span><span class="variable">myGene</span>
  <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">exon</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">XXXX</span> <span class="variable">Parent</span><span class="operator">=</span><span class="variable">myTranscript</span><span class="operator">;</span><span class="variable">Alias</span><span class="operator">=</span><span class="variable">myGene</span>
</code></code></pre>

<p>This limitation will be corrected in the next version of Bio::DB::GFF.</p>

</dd>
</dl>

<h1 id="API">API</h1>

<p>The following is the API for Bio::DB::GFF.</p>

<h1 id="Querying-GFF-Databases">Querying GFF Databases</h1>

<h2 id="new">new</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">new</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="keyword">my</span> <span class="variable">$db</span> <span class="operator">=</span> <span class="variable">Bio::DB::GFF</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">create</span> <span class="variable">a</span> <span class="variable">new</span> <span class="variable">Bio::DB::GFF</span> <span class="variable">object</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">new</span> <span class="variable">Bio::DB::GFF</span> <span class="variable">object</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">lists</span> <span class="variable">of</span> <span class="variable">adaptors</span> <span class="keyword">and</span> <span class="variable">aggregators</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
</code></code></pre>

<p>These are the arguments:</p>

<pre><code><code> -adaptor      Name of the adaptor module to use.  If none
               provided, defaults to &quot;dbi::mysqlopt&quot;.

 -aggregator   Array reference to a list of aggregators
               to apply to the database.  If none provided,
               defaults to [&#39;processed_transcript&#39;,&#39;alignment&#39;].

  -preferred_groups  When interpreteting the 9th column of a GFF2 file,
                 the indicated group names will have preference over
                 other attributes, even if they do not come first in
                 the list of attributes.  This can be a scalar value
                 or an array reference.

  &lt;other&gt;      Any other named argument pairs are passed to
               the adaptor for processing.</code></code></pre>

<p>The adaptor argument must correspond to a module contained within the Bio::DB::GFF::Adaptor namespace. For example, the Bio::DB::GFF::Adaptor::dbi::mysql adaptor is loaded by specifying &#39;dbi::mysql&#39;. By Perl convention, the adaptors names are lower case because they are loaded at run time.</p>

<p>The aggregator array may contain a list of aggregator names, a list of initialized aggregator objects, or a string in the form &quot;aggregator_name{subpart1,subpart2,subpart3/main_method}&quot; (the &quot;/main_method&quot; part is optional, but if present a feature with the main_method must be present in order for aggregation to occur). For example, if you wish to change the components aggregated by the transcript aggregator, you could pass it to the GFF constructor this way:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$transcript</span> <span class="operator">=</span> 
     <span class="variable">Bio::DB::Aggregator::transcript</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">-sub_parts</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="string">qw(exon intron utr
                                                          polyA spliced_leader)</span><span class="operator">]</span><span class="operator">);</span>
  
  <span class="keyword">my</span> <span class="variable">$db</span> <span class="operator">=</span> <span class="variable">Bio::DB::GFF</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">-aggregator</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="variable">$transcript</span><span class="operator">,</span><span class="string">'clone'</span><span class="operator">,</span><span class="string">'alignment],
                             -adaptor   =&gt; '</span><span class="variable">dbi::mysql</span><span class="string">',
                             -dsn      =&gt; '</span><span class="variable">dbi</span><span class="operator">:</span><span class="variable">mysql</span><span class="operator">:</span><span class="variable">elegans42</span><span class="string">');
  </span>
</code></code></pre>

<p>Alternatively, you could create an entirely new transcript aggregator this way:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$new_agg</span> <span class="operator">=</span> <span class="string">'transcript{exon,intron,utr,polyA,spliced_leader}'</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$db</span>      <span class="operator">=</span> <span class="variable">Bio::DB::GFF</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">-aggregator</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="variable">$new_agg</span><span class="operator">,</span><span class="string">'clone'</span><span class="operator">,</span><span class="string">'alignment],
                                  -adaptor   =&gt; '</span><span class="variable">dbi::mysql</span><span class="string">',
                                  -dsn       =&gt; '</span><span class="variable">dbi</span><span class="operator">:</span><span class="variable">mysql</span><span class="operator">:</span><span class="variable">elegans42</span><span class="string">');
  </span>
</code></code></pre>

<p>See <a href="../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/Aggregator.html">Bio::DB::GFF::Aggregator</a> for more details.</p>

<p>The <b>-preferred_groups</b> argument is used to change the default processing of the 9th column of GFF version 2 files. By default, the first tag/value pair is used to establish the group class and name. If you pass -preferred_groups a scalar, the parser will look for a tag of the indicated type and use it as the group even if it is not first in the file. If you pass this argument a list of group classes as an array ref, then the list will establish the precedence for searching.</p>

<p>The commonly used &#39;dbi::mysql&#39; adaptor recognizes the following adaptor-specific arguments:</p>

<pre><code><code>  <span class="variable">Argument</span>       <span class="variable">Description</span>
  <span class="operator">--------</span>       <span class="operator">-----------</span>
  
  <span class="operator">-</span><span class="variable">dsn</span>           <span class="variable">the</span> <span class="variable">DBI</span> <span class="variable">data</span> <span class="variable">source</span><span class="operator">,</span> <span class="variable">e</span><span class="operator">.</span><span class="variable">g</span><span class="operator">.</span> <span class="string">'dbi:mysql:ens0040'</span>
                 <span class="variable">If</span> <span class="variable">a</span> <span class="variable">partial</span> <span class="variable">name</span> <span class="variable">is</span> <span class="keyword">given</span><span class="operator">,</span> <span class="variable">such</span> <span class="variable">as</span> <span class="string">"ens0040"</span><span class="operator">,</span> <span class="variable">the</span>
                 <span class="string">"dbi:mysql:"</span> <span class="variable">prefix</span> <span class="variable">will</span> <span class="variable">be</span> <span class="variable">added</span> <span class="variable">automatically</span><span class="operator">.</span>
  
  <span class="operator">-</span><span class="variable">user</span>          <span class="variable">username</span> <span class="keyword">for</span> <span class="variable">authentication</span>
  
  <span class="operator">-</span><span class="variable">pass</span>          <span class="variable">the</span> <span class="variable">password</span> <span class="keyword">for</span> <span class="variable">authentication</span>
  
  <span class="operator">-</span><span class="variable">refclass</span>      <span class="variable">landmark</span> <span class="variable">Class</span><span class="operator">;</span> <span class="variable">defaults</span> <span class="variable">to</span> <span class="string">"Sequence"</span>
</code></code></pre>

<p>The commonly used &#39;dbi::mysqlopt&#39; adaptor also recogizes the following arguments.</p>

<pre><code><code>  Argument       Description
  --------       -----------

  -fasta         path to a directory containing FASTA files for the DNA
                 contained in this database (e.g. &quot;/usr/local/share/fasta&quot;)

  -acedb         an acedb URL to use when converting features into ACEDB
                    objects (e.g. sace://localhost:2005)</code></code></pre>

<h2 id="types">types</h2>

<pre><code><code> Title   : types
 Usage   : $db-&gt;types(@args)
 Function: return list of feature types in range or database
 Returns : a list of Bio::DB::GFF::Typename objects
 Args    : see below
 Status  : public</code></code></pre>

<p>This routine returns a list of feature types known to the database. The list can be database-wide or restricted to a region. It is also possible to find out how many times each feature occurs.</p>

<p>For range queries, it is usually more convenient to create a Bio::DB::GFF::Segment object, and then invoke it&#39;s types() method.</p>

<p>Arguments are as follows:</p>

<pre><code><code>  -ref        ID of reference sequence
  -class      class of reference sequence
  -start      start of segment
  -stop       stop of segment
  -enumerate  if true, count the features</code></code></pre>

<p>The returned value will be a list of Bio::DB::GFF::Typename objects, which if evaluated in a string context will return the feature type in &quot;method:source&quot; format. This object class also has method() and source() methods for retrieving the like-named fields.</p>

<p>If -enumerate is true, then the function returns a hash (not a hash reference) in which the keys are type names in &quot;method:source&quot; format and the values are the number of times each feature appears in the database or segment.</p>

<p>The argument -end is a synonum for -stop, and -count is a synonym for -enumerate.</p>

<h2 id="classes">classes</h2>

<pre><code><code> Title   : classes
 Usage   : $db-&gt;classes
 Function: return list of landmark classes in database
 Returns : a list of classes
 Args    : none
 Status  : public</code></code></pre>

<p>This routine returns the list of reference classes known to the database, or empty if classes are not used by the database. Classes are distinct from types, being essentially qualifiers on the reference namespaces.</p>

<h2 id="segment">segment</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">segment</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">create</span> <span class="variable">a</span> <span class="variable">segment</span> <span class="variable">object</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">segment</span> <span class="variable">object</span><span class="operator">(</span><span class="regex">s)
 Args    : numerous, see below
 Status  : public
 </span>
</code></code></pre>

<p>This method generates a segment object, which is a Perl object subclassed from Bio::DB::GFF::Segment. The segment can be used to find overlapping features and the raw DNA.</p>

<p>When making the segment() call, you specify the ID of a sequence landmark (e.g. an accession number, a clone or contig), and a positional range relative to the landmark. If no range is specified, then the entire extent of the landmark is used to generate the segment.</p>

<p>You may also provide the ID of a &quot;reference&quot; sequence, which will set the coordinate system and orientation used for all features contained within the segment. The reference sequence can be changed later. If no reference sequence is provided, then the coordinate system is based on the landmark.</p>

<p>Arguments:</p>

<pre><code><code> -name         ID of the landmark sequence.

 -class        Database object class for the landmark sequence.
               &quot;Sequence&quot; assumed if not specified.  This is
               irrelevant for databases which do not recognize
               object classes.

 -start        Start of the segment relative to landmark.  Positions
               follow standard 1-based sequence rules.  If not specified,
               defaults to the beginning of the landmark.

 -end          Stop of the segment relative to the landmark.  If not specified,
               defaults to the end of the landmark.

 -stop         Same as -end.

 -offset       For those who prefer 0-based indexing, the offset specifies the
               position of the new segment relative to the start of the landmark.

 -length       For those who prefer 0-based indexing, the length specifies the
               length of the new segment.

 -refseq       Specifies the ID of the reference landmark used to establish the
               coordinate system for the newly-created segment.

 -refclass     Specifies the class of the reference landmark, for those databases
               that distinguish different object classes.  Defaults to &quot;Sequence&quot;.

 -absolute
               Return features in absolute coordinates rather than relative to the
               parent segment.

 -nocheck      Don&#39;t check the database for the coordinates and length of this
               feature.  Construct a segment using the indicated name as the
               reference, a start coordinate of 1, an undefined end coordinate,
               and a strand of +1.

 -force        Same as -nocheck.

 -seq,-sequence,-sourceseq   Aliases for -name.

 -begin,-end   Aliases for -start and -stop

 -off,-len     Aliases for -offset and -length

 -seqclass     Alias for -class</code></code></pre>

<p>Here&#39;s an example to explain how this works:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$db</span> <span class="operator">=</span> <span class="variable">Bio::DB::GFF</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">-dsn</span> <span class="operator">=&gt;</span> <span class="string">'dbi:mysql:human'</span><span class="operator">,</span><span class="string">-adaptor</span><span class="operator">=&gt;</span><span class="string">'dbi::mysql'</span><span class="operator">);</span>
</code></code></pre>

<p>If successful, $db will now hold the database accessor object. We now try to fetch the fragment of sequence whose ID is A0000182 and class is &quot;Accession.&quot;</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$segment</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">segment</span><span class="operator">(</span><span class="string">-name</span><span class="operator">=&gt;</span><span class="string">'A0000182'</span><span class="operator">,</span><span class="string">-class</span><span class="operator">=&gt;</span><span class="string">'Accession'</span><span class="operator">);</span>
</code></code></pre>

<p>If successful, $segment now holds the entire segment corresponding to this accession number. By default, the sequence is used as its own reference sequence, so its first base will be 1 and its last base will be the length of the accession.</p>

<p>Assuming that this sequence belongs to a longer stretch of DNA, say a contig, we can fetch this information like so:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$sourceseq</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">sourceseq</span><span class="operator">;</span>
</code></code></pre>

<p>and find the start and stop on the source like this:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$start</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">abs_start</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$stop</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">abs_stop</span><span class="operator">;</span>
</code></code></pre>

<p>If we had another segment, say $s2, which is on the same contiguous piece of DNA, we can pass that to the refseq() method in order to establish it as the coordinate reference point:</p>

<pre><code><code>  <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">refseq</span><span class="operator">(</span><span class="variable">$s2</span><span class="operator">);</span>
</code></code></pre>

<p>Now calling start() will return the start of the segment relative to the beginning of $s2, accounting for differences in strandedness:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$rel_start</span> <span class="operator">=</span> <span class="variable">$segment</span><span class="operator">-&gt;</span><span class="variable">start</span><span class="operator">;</span>
</code></code></pre>

<p>IMPORTANT NOTE: This method can be used to return the segment spanned by an arbitrary named annotation. However, if the annotation appears at multiple locations on the genome, for example an EST that maps to multiple locations, then, provided that all locations reside on the same physical segment, the method will return a segment that spans the minimum and maximum positions. If the reference sequence occupies ranges on different physical segments, then it returns them all in an array context, and raises a &quot;multiple segment exception&quot; exception in a scalar context.</p>

<h2 id="features">features</h2>

<pre><code><code> Title   : features
 Usage   : $db-&gt;features(@args)
 Function: get all features, possibly filtered by type
 Returns : a list of Bio::DB::GFF::Feature objects
 Args    : see below
 Status  : public</code></code></pre>

<p>This routine will retrieve features in the database regardless of position. It can be used to return all features, or a subset based on their method and source.</p>

<p>Arguments are as follows:</p>

<pre><code><code>  -types     List of feature types to return.  Argument is an array
             reference containing strings of the format &quot;method:source&quot;

  -merge     Whether to apply aggregators to the generated features.

  -rare      Turn on optimizations suitable for a relatively rare feature type,
             where it makes more sense to filter by feature type first,
             and then by position.

  -attributes A hash reference containing attributes to match.

  -iterator  Whether to return an iterator across the features.

  -binsize   A true value will create a set of artificial features whose
             start and stop positions indicate bins of the given size, and
             whose scores are the number of features in the bin.  The
             class and method of the feature will be set to &quot;bin&quot;,
             its source to &quot;method:source&quot;, and its group to &quot;bin:method:source&quot;.
             This is a handy way of generating histograms of feature density.</code></code></pre>

<p>If -iterator is true, then the method returns a single scalar value consisting of a Bio::SeqIO object. You can call next_seq() repeatedly on this object to fetch each of the features in turn. If iterator is false or absent, then all the features are returned as a list.</p>

<p>Currently aggregation is disabled when iterating over a series of features.</p>

<p>Types are indicated using the nomenclature &quot;method:source&quot;. Either of these fields can be omitted, in which case a wildcard is used for the missing field. Type names without the colon (e.g. &quot;exon&quot;) are interpreted as the method name and a source wild card. Regular expressions are allowed in either field, as in: &quot;similarity:BLAST.*&quot;.</p>

<p>The -attributes argument is a hashref containing one or more attributes to match against:</p>

<pre><code><code>  <span class="string">-attributes</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">Gene</span> <span class="operator">=&gt;</span> <span class="string">'abc-1'</span><span class="operator">,</span>
                   <span class="string">Note</span> <span class="operator">=&gt;</span> <span class="string">'confirmed'</span> <span class="operator">}</span>
</code></code></pre>

<p>Attribute matching is simple string matching, and multiple attributes are ANDed together.</p>

<h2 id="get_seq_stream">get_seq_stream</h2>

<pre><code><code> Title   : get_seq_stream
 Usage   : my $seqio = $self-&gt;get_seq_sream(@args)
 Function: Performs a query and returns an iterator over it
 Returns : a Bio::SeqIO stream capable of producing sequence
 Args    : As in features()
 Status  : public</code></code></pre>

<p>This routine takes the same arguments as features(), but returns a Bio::SeqIO::Stream-compliant object. Use it like this:</p>

<pre><code><code>  <span class="variable">$stream</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_seq_stream</span><span class="operator">(</span><span class="string">'exon'</span><span class="operator">);</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$exon</span> <span class="operator">=</span> <span class="variable">$stream</span><span class="operator">-&gt;</span><span class="variable">next_seq</span><span class="operator">)</span> <span class="operator">{</span>
     <span class="keyword">print</span> <span class="variable">$exon</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>NOTE: This is also called get_feature_stream(), since that&#39;s what it really does.</p>

<h2 id="get_feature_by_name">get_feature_by_name</h2>

<pre><code><code> Title   : get_feature_by_name
 Usage   : $db-&gt;get_feature_by_name($class =&gt; $name)
 Function: fetch features by their name
 Returns : a list of Bio::DB::GFF::Feature objects
 Args    : the class and name of the desired feature
 Status  : public</code></code></pre>

<p>This method can be used to fetch a named feature from the database. GFF annotations are named using the group class and name fields, so for features that belong to a group of size one, this method can be used to retrieve that group (and is equivalent to the segment() method). Any Alias attributes are also searched for matching names.</p>

<p>An alternative syntax allows you to search for features by name within a circumscribed region:</p>

<pre><code><code>  <span class="variable">@f</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_feature_by_name</span><span class="operator">(</span><span class="string">-class</span> <span class="operator">=&gt;</span> <span class="variable">$class</span><span class="operator">,</span><span class="string">-name</span><span class="operator">=&gt;</span><span class="variable">$name</span><span class="operator">,</span>
                                <span class="string">-ref</span>   <span class="operator">=&gt;</span> <span class="variable">$sequence_name</span><span class="operator">,</span>
                                <span class="string">-start</span> <span class="operator">=&gt;</span> <span class="variable">$start</span><span class="operator">,</span>
                                <span class="string">-end</span>   <span class="operator">=&gt;</span> <span class="variable">$end</span><span class="operator">);</span>
</code></code></pre>

<p>This method may return zero, one, or several Bio::DB::GFF::Feature objects.</p>

<p>Aggregation is performed on features as usual.</p>

<p>NOTE: At various times, this function was called fetch_group(), fetch_feature(), fetch_feature_by_name() and segments(). These names are preserved for backward compatibility.</p>

<h2 id="get_feature_by_target">get_feature_by_target</h2>

<pre><code><code> Title   : get_feature_by_target
 Usage   : $db-&gt;get_feature_by_target($class =&gt; $name)
 Function: fetch features by their similarity target
 Returns : a list of Bio::DB::GFF::Feature objects
 Args    : the class and name of the desired feature
 Status  : public</code></code></pre>

<p>This method can be used to fetch a named feature from the database based on its similarity hit.</p>

<h2 id="get_feature_by_attribute">get_feature_by_attribute</h2>

<pre><code><code> Title   : get_feature_by_attribute
 Usage   : $db-&gt;get_feature_by_attribute(attribute1=&gt;value1,attribute2=&gt;value2)
 Function: fetch segments by combinations of attribute values
 Returns : a list of Bio::DB::GFF::Feature objects
 Args    : the class and name of the desired feature
 Status  : public</code></code></pre>

<p>This method can be used to fetch a set of features from the database. Attributes are a list of name=&gt;value pairs. They will be logically ANDED together.</p>

<h2 id="get_feature_by_id">get_feature_by_id</h2>

<pre><code><code> Title   : get_feature_by_id
 Usage   : $db-&gt;get_feature_by_id($id)
 Function: fetch segments by feature ID
 Returns : a Bio::DB::GFF::Feature object
 Args    : the feature ID
 Status  : public</code></code></pre>

<p>This method can be used to fetch a feature from the database using its ID. Not all GFF databases support IDs, so be careful with this.</p>

<h2 id="get_feature_by_gid">get_feature_by_gid</h2>

<pre><code><code> Title   : get_feature_by_gid
 Usage   : $db-&gt;get_feature_by_gid($id)
 Function: fetch segments by feature ID
 Returns : a Bio::DB::GFF::Feature object
 Args    : the feature ID
 Status  : public</code></code></pre>

<p>This method can be used to fetch a feature from the database using its group ID. Not all GFF databases support IDs, so be careful with this.</p>

<p>The group ID is often more interesting than the feature ID, since groups can be complex objects containing subobjects.</p>

<h2 id="delete_fattribute_to_features">delete_fattribute_to_features</h2>

<pre><code><code> Title   : delete_fattribute_to_features
 Usage   : $db-&gt;delete_fattribute_to_features(@ids_or_features)
 Function: delete one or more fattribute_to_features
 Returns : count of fattribute_to_features deleted
 Args    : list of features or feature ids
 Status  : public</code></code></pre>

<p>Pass this method a list of numeric feature ids or a set of features. It will attempt to remove the fattribute_to_features rows of those features from the database and return a count of the rows removed.</p>

<p>NOTE: This method is also called delete_fattribute_to_feature(). Also see delete_groups() and delete_features().</p>

<h2 id="delete_features">delete_features</h2>

<pre><code><code> Title   : delete_features
 Usage   : $db-&gt;delete_features(@ids_or_features)
 Function: delete one or more features
 Returns : count of features deleted
 Args    : list of features or feature ids
 Status  : public</code></code></pre>

<p>Pass this method a list of numeric feature ids or a set of features. It will attempt to remove the features from the database and return a count of the features removed.</p>

<p>NOTE: This method is also called delete_feature(). Also see delete_groups().</p>

<h2 id="delete_groups">delete_groups</h2>

<pre><code><code> Title   : delete_groups
 Usage   : $db-&gt;delete_groups(@ids_or_features)
 Function: delete one or more feature groups
 Returns : count of features deleted
 Args    : list of features or feature group ids
 Status  : public</code></code></pre>

<p>Pass this method a list of numeric group ids or a set of features. It will attempt to recursively remove the features and ALL members of their group from the database. It returns a count of the number of features (not groups) returned.</p>

<p>NOTE: This method is also called delete_group(). Also see delete_features().</p>

<h2 id="delete">delete</h2>

<pre><code><code> Title   : delete
 Usage   : $db-&gt;delete(@args)
 Function: delete features
 Returns : count of features deleted -- if available
 Args    : numerous, see below
 Status  : public</code></code></pre>

<p>This method deletes all features that overlap the specified region or are of a particular type. If no arguments are provided and the -force argument is true, then deletes ALL features.</p>

<p>Arguments:</p>

<pre><code><code> -name         ID of the landmark sequence.

 -ref          ID of the landmark sequence (synonym for -name).

 -class        Database object class for the landmark sequence.
               &quot;Sequence&quot; assumed if not specified.  This is
               irrelevant for databases which do not recognize
               object classes.

 -start        Start of the segment relative to landmark.  Positions
               follow standard 1-based sequence rules.  If not specified,
               defaults to the beginning of the landmark.

 -end          Stop of the segment relative to the landmark.  If not specified,
               defaults to the end of the landmark.

 -offset       Zero-based addressing

 -length       Length of region

 -type,-types  Either a single scalar type to be deleted, or an
               reference to an array of types.

 -force        Force operation to be performed even if it would delete
               entire feature table.

 -range_type   Control the range type of the deletion.  One of &quot;overlaps&quot; (default)
               &quot;contains&quot; or &quot;contained_in&quot;</code></code></pre>

<p>Examples:</p>

<pre><code><code>  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">delete</span><span class="operator">(</span><span class="string">-type</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="string">'intron'</span><span class="operator">,</span><span class="string">'repeat:repeatMasker'</span><span class="operator">]</span><span class="operator">);</span>  <span class="comment"># remove all introns &amp; repeats</span>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">delete</span><span class="operator">(</span><span class="string">-name</span><span class="operator">=&gt;</span><span class="string">'chr3'</span><span class="operator">,</span><span class="string">-start</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">,</span><span class="string">-end</span><span class="operator">=&gt;</span><span class="number">1000</span><span class="operator">);</span>       <span class="comment"># remove annotations on chr3 from 1 to 1000</span>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">delete</span><span class="operator">(</span><span class="string">-name</span><span class="operator">=&gt;</span><span class="string">'chr3'</span><span class="operator">,</span><span class="string">-type</span><span class="operator">=&gt;</span><span class="string">'exon'</span><span class="operator">);</span>              <span class="comment"># remove all exons on chr3</span>
</code></code></pre>

<p>The short form of this call, as described in segment() is also allowed:</p>

<pre><code><code>  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">delete</span><span class="operator">(</span><span class="string">"chr3"</span><span class="operator">,</span><span class="number">1</span><span class="operator">=&gt;</span><span class="number">1000</span><span class="operator">);</span>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">delete</span><span class="operator">(</span><span class="string">"chr3"</span><span class="operator">);</span>
</code></code></pre>

<p>IMPORTANT NOTE: This method only deletes features. It does *NOT* delete the names of groups that contain the deleted features. Group IDs will be reused if you later load a feature with the same group name as one that was previously deleted.</p>

<p>NOTE ON FEATURE COUNTS: The DBI-based versions of this call return the result code from the SQL DELETE operation. Some dbd drivers return the count of rows deleted, while others return 0E0. Caveat emptor.</p>

<h2 id="absolute">absolute</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">absolute</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$abs</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">absolute</span><span class="operator">(</span><span class="operator">[</span><span class="variable">$abs</span><span class="operator">]</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">gets</span><span class="operator">/</span><span class="variable">sets</span> <span class="variable">absolute</span> <span class="variable">mode</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">current</span> <span class="variable">setting</span> <span class="variable">of</span> <span class="variable">absolute</span> <span class="variable">mode</span> <span class="variable">boolean</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">new</span> <span class="variable">setting</span> <span class="keyword">for</span> <span class="variable">absolute</span> <span class="variable">mode</span> <span class="variable">boolean</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">public</span>
</code></code></pre>

<p>$db-&gt;absolute(1) will turn on absolute mode for the entire database. All segments retrieved will use absolute coordinates by default, rather than relative coordinates. You can still set them to use relative coordinates by calling $segment-&gt;absolute(0).</p>

<p>Note that this is not the same as calling abs_segment(); it continues to allow you to look up groups that are not used directly as reference sequences.</p>

<h2 id="strict_bounds_checking">strict_bounds_checking</h2>

<pre><code><code> Title   : strict_bounds_checking
 Usage   : $flag = $db-&gt;strict_bounds_checking([$flag])
 Function: gets/sets strict bounds checking
 Returns : current setting of bounds checking flag
 Args    : new setting for bounds checking flag
 Status  : public</code></code></pre>

<p>This flag enables extra checks for segment requests that go beyond the ends of their reference sequences. If bounds checking is enabled, then retrieved segments will be truncated to their physical length, and their truncated() methods will return true.</p>

<p>If the flag is off (the default), then the module will return segments that appear to extend beyond their physical boundaries. Requests for features beyond the end of the segment will, however, return empty.</p>

<h2 id="get_Seq_by_id">get_Seq_by_id</h2>

<pre><code><code> Title   : get_Seq_by_id
 Usage   : $seq = $db-&gt;get_Seq_by_id(&#39;ROA1_HUMAN&#39;)
 Function: Gets a Bio::Seq object by its name
 Returns : a Bio::Seq object
 Args    : the id (as a string) of a sequence
 Throws  : &quot;id does not exist&quot; exception</code></code></pre>

<p>NOTE: Bio::DB::RandomAccessI compliant method</p>

<h2 id="get_Seq_by_accession">get_Seq_by_accession</h2>

<pre><code><code> Title   : get_Seq_by_accession
 Usage   : $seq = $db-&gt;get_Seq_by_accession(&#39;AL12234&#39;)
 Function: Gets a Bio::Seq object by its accession
 Returns : a Bio::Seq object
 Args    : the id (as a string) of a sequence
 Throws  : &quot;id does not exist&quot; exception</code></code></pre>

<p>NOTE: Bio::DB::RandomAccessI compliant method</p>

<h2 id="get_Seq_by_acc">get_Seq_by_acc</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">get_Seq_by_acc</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$seq</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_Seq_by_acc</span><span class="operator">(</span><span class="string">'X77802'</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">Gets</span> <span class="variable">a</span> <span class="variable">Bio::Seq</span> <span class="variable">object</span> <span class="variable">by</span> <span class="variable">accession</span> <span class="variable">number</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">A</span> <span class="variable">Bio::Seq</span> <span class="variable">object</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">accession</span> <span class="variable">number</span> <span class="operator">(</span><span class="variable">as</span> <span class="variable">a</span> <span class="variable">string</span><span class="operator">)</span>
 <span class="variable">Throws</span>  <span class="operator">:</span> <span class="string">"acc does not exist"</span> <span class="variable">exception</span>
</code></code></pre>

<p>NOTE: Bio::DB::RandomAccessI compliant method</p>

<h2 id="get_Stream_by_name">get_Stream_by_name</h2>

<pre><code><code>  <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">get_Stream_by_name</span>
  <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$seq</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_Stream_by_name</span><span class="operator">(</span><span class="variable">@ids</span><span class="operator">);</span>
  <span class="variable">Function</span><span class="operator">:</span> <span class="variable">Retrieves</span> <span class="variable">a</span> <span class="variable">stream</span> <span class="variable">of</span> <span class="variable">Seq</span> <span class="variable">objects</span> <span class="keyword">given</span> <span class="variable">their</span> <span class="variable">names</span>
  <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">a</span> <span class="variable">Bio::SeqIO</span> <span class="variable">stream</span> <span class="variable">object</span>
  <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">an</span> <span class="variable">array</span> <span class="variable">of</span> <span class="variable">unique</span> <span class="variable">ids</span><span class="operator">/</span><span class="variable">accession</span> <span class="variable">numbers</span><span class="operator">,</span> <span class="keyword">or</span> 
            <span class="variable">an</span> <span class="variable">array</span> <span class="variable">reference</span>
</code></code></pre>

<p>NOTE: This is also called get_Stream_by_batch()</p>

<h2 id="get_Stream_by_id">get_Stream_by_id</h2>

<pre><code><code>  <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">get_Stream_by_id</span>
  <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$seq</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_Stream_by_id</span><span class="operator">(</span><span class="variable">@ids</span><span class="operator">);</span>
  <span class="variable">Function</span><span class="operator">:</span> <span class="variable">Retrieves</span> <span class="variable">a</span> <span class="variable">stream</span> <span class="variable">of</span> <span class="variable">Seq</span> <span class="variable">objects</span> <span class="keyword">given</span> <span class="variable">their</span> <span class="variable">ids</span>
  <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">a</span> <span class="variable">Bio::SeqIO</span> <span class="variable">stream</span> <span class="variable">object</span>
  <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">an</span> <span class="variable">array</span> <span class="variable">of</span> <span class="variable">unique</span> <span class="variable">ids</span><span class="operator">/</span><span class="variable">accession</span> <span class="variable">numbers</span><span class="operator">,</span> <span class="keyword">or</span> 
            <span class="variable">an</span> <span class="variable">array</span> <span class="variable">reference</span>
</code></code></pre>

<p>NOTE: This is also called get_Stream_by_batch()</p>

<h2 id="get_Stream_by_batch-">get_Stream_by_batch ()</h2>

<pre><code><code>  <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">get_Stream_by_batch</span>
  <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$seq</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">get_Stream_by_batch</span><span class="operator">(</span><span class="variable">@ids</span><span class="operator">);</span>
  <span class="variable">Function</span><span class="operator">:</span> <span class="variable">Retrieves</span> <span class="variable">a</span> <span class="variable">stream</span> <span class="variable">of</span> <span class="variable">Seq</span> <span class="variable">objects</span> <span class="keyword">given</span> <span class="variable">their</span> <span class="variable">ids</span>
  <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">a</span> <span class="variable">Bio::SeqIO</span> <span class="variable">stream</span> <span class="variable">object</span>
  <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">an</span> <span class="variable">array</span> <span class="variable">of</span> <span class="variable">unique</span> <span class="variable">ids</span><span class="operator">/</span><span class="variable">accession</span> <span class="variable">numbers</span><span class="operator">,</span> <span class="keyword">or</span> 
            <span class="variable">an</span> <span class="variable">array</span> <span class="variable">reference</span>
</code></code></pre>

<p>NOTE: This is the same as get_Stream_by_id().</p>

<h2 id="get_Stream_by_group-">get_Stream_by_group ()</h2>

<p>Bioperl compatibility.</p>

<h2 id="all_seqfeatures">all_seqfeatures</h2>

<pre><code><code> Title   : all_seqfeatures
 Usage   : @features = $db-&gt;all_seqfeatures(@args)
 Function: fetch all the features in the database
 Returns : an array of features, or an iterator
 Args    : See below
 Status  : public</code></code></pre>

<p>This is equivalent to calling $db-&gt;features() without any types, and will return all the features in the database. The -merge and -iterator arguments are recognized, and behave the same as described for features().</p>

<h1 id="Creating-and-Loading-GFF-Databases">Creating and Loading GFF Databases</h1>

<h2 id="initialize">initialize</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">initialize</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">initialize</span><span class="operator">(</span><span class="string">-erase</span><span class="operator">=&gt;</span><span class="variable">$erase</span><span class="operator">,</span><span class="string">-option1</span><span class="operator">=&gt;</span><span class="variable">value1</span><span class="operator">,</span><span class="string">-option2</span><span class="operator">=&gt;</span><span class="variable">value2</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">initialize</span> <span class="variable">a</span> <span class="variable">GFF</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">true</span> <span class="keyword">if</span> <span class="variable">initialization</span> <span class="variable">successful</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">a</span> <span class="variable">set</span> <span class="variable">of</span> <span class="variable">named</span> <span class="variable">parameters</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
</code></code></pre>

<p>This method can be used to initialize an empty database. It takes the following named arguments:</p>

<pre><code><code>  -erase     A boolean value.  If true the database will be wiped clean if it
             already contains data.</code></code></pre>

<p>Other named arguments may be recognized by subclasses. They become database meta values that control various settable options.</p>

<p>As a shortcut (and for backward compatibility) a single true argument is the same as initialize(-erase=&gt;1).</p>

<h2 id="load_gff">load_gff</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">load_gff</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">load_gff</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">|</span><span class="variable">$directory</span><span class="operator">|</span><span class="variable">$filehandle</span> <span class="operator">[</span><span class="operator">,</span><span class="variable">$verbose</span><span class="operator">]</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">load</span> <span class="variable">GFF</span> <span class="variable">data</span> <span class="variable">into</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">count</span> <span class="variable">of</span> <span class="variable">records</span> <span class="variable">loaded</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">a</span> <span class="variable">directory</span><span class="operator">,</span> <span class="variable">a</span> <span class="variable">file</span><span class="operator">,</span> <span class="variable">a</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">files</span><span class="operator">,</span> 
           <span class="keyword">or</span> <span class="variable">a</span> <span class="variable">filehandle</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
</code></code></pre>

<p>This method takes a single overloaded argument, which can be any of:</p>

<ul>

<li><p>a scalar corresponding to a GFF file on the system</p>

<p>A pathname to a local GFF file. Any files ending with the .gz, .Z, or .bz2 suffixes will be transparently decompressed with the appropriate command-line utility.</p>

</li>
<li><p>an array reference containing a list of GFF files on the system</p>

<p>For example [&#39;/home/gff/gff1.gz&#39;,&#39;/home/gff/gff2.gz&#39;]</p>

</li>
<li><p>directory path</p>

<p>The indicated directory will be searched for all files ending in the suffixes .gff, .gff.gz, .gff.Z or .gff.bz2.</p>

</li>
<li><p>filehandle</p>

<p>An open filehandle from which to read the GFF data. Tied filehandles now work as well.</p>

</li>
<li><p>a pipe expression</p>

<p>A pipe expression will also work. For example, a GFF file on a remote web server can be loaded with an expression like this:</p>

<pre><code><code>  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">load_gff</span><span class="operator">(</span><span class="string">"lynx -dump -source http://stein.cshl.org/gff_test |"</span><span class="operator">);</span>
</code></code></pre>

</li>
</ul>

<p>The optional second argument, if true, will turn on verbose status reports that indicate the progress.</p>

<p>If successful, the method will return the number of GFF lines successfully loaded.</p>

<p>NOTE:this method used to be called load(), but has been changed. The old method name is also recognized.</p>

<h2 id="load_gff_file">load_gff_file</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">load_gff_file</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">load_gff_file</span><span class="operator">(</span><span class="variable">$file</span> <span class="operator">[</span><span class="operator">,</span><span class="variable">$verbose</span><span class="operator">]</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">load</span> <span class="variable">GFF</span> <span class="variable">data</span> <span class="variable">into</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">count</span> <span class="variable">of</span> <span class="variable">records</span> <span class="variable">loaded</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">a</span> <span class="variable">path</span> <span class="variable">to</span> <span class="variable">a</span> <span class="variable">file</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
</code></code></pre>

<p>This is provided as an alternative to load_gff_file. It doesn&#39;t munge STDIN or play tricks with ARGV.</p>

<h2 id="load_fasta">load_fasta</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">load_fasta</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">load_fasta</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">|</span><span class="variable">$directory</span><span class="operator">|</span><span class="variable">$filehandle</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">load</span> <span class="variable">FASTA</span> <span class="variable">data</span> <span class="variable">into</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">count</span> <span class="variable">of</span> <span class="variable">records</span> <span class="variable">loaded</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">a</span> <span class="variable">directory</span><span class="operator">,</span> <span class="variable">a</span> <span class="variable">file</span><span class="operator">,</span> <span class="variable">a</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">files</span><span class="operator">,</span> 
           <span class="keyword">or</span> <span class="variable">a</span> <span class="variable">filehandle</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
</code></code></pre>

<p>This method takes a single overloaded argument, which can be any of:</p>

<ul>

<li><p>scalar corresponding to a FASTA file on the system</p>

<p>A pathname to a local FASTA file. Any files ending with the .gz, .Z, or .bz2 suffixes will be transparently decompressed with the appropriate command-line utility.</p>

</li>
<li><p>array reference containing a list of FASTA files on the system</p>

<p>For example [&#39;/home/fasta/genomic.fa.gz&#39;,&#39;/home/fasta/genomic.fa.gz&#39;]</p>

</li>
<li><p>path to a directory</p>

<p>The indicated directory will be searched for all files ending in the suffixes .fa, .fa.gz, .fa.Z or .fa.bz2.</p>

</li>
<li><p>filehandle</p>

<p>An open filehandle from which to read the FASTA data.</p>

</li>
<li><p>pipe expression</p>

<p>A pipe expression will also work. For example, a FASTA file on a remote web server can be loaded with an expression like this:</p>

<pre><code><code>  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">load_gff</span><span class="operator">(</span><span class="string">"lynx -dump -source http://stein.cshl.org/fasta_test.fa |"</span><span class="operator">);</span>
</code></code></pre>

</li>
</ul>

<h2 id="load_fasta_file">load_fasta_file</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">load_fasta_file</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">load_fasta_file</span><span class="operator">(</span><span class="variable">$file</span> <span class="operator">[</span><span class="operator">,</span><span class="variable">$verbose</span><span class="operator">]</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">load</span> <span class="variable">FASTA</span> <span class="variable">data</span> <span class="variable">into</span> <span class="variable">database</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">count</span> <span class="variable">of</span> <span class="variable">records</span> <span class="variable">loaded</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">a</span> <span class="variable">path</span> <span class="variable">to</span> <span class="variable">a</span> <span class="variable">file</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
</code></code></pre>

<p>This is provided as an alternative to load_fasta. It doesn&#39;t munge STDIN or play tricks with ARGV.</p>

<h2 id="load_sequence_string">load_sequence_string</h2>

<pre><code><code> Title   : load_sequence_string
 Usage   : $db-&gt;load_sequence_string($id,$dna)
 Function: load a single DNA entry
 Returns : true if successfully loaded
 Args    : a raw sequence string (DNA, RNA, protein)
 Status  : Public</code></code></pre>

<h2 id="lock_on_load">lock_on_load</h2>

<pre><code><code> Title   : lock_on_load
 Usage   : $lock = $db-&gt;lock_on_load([$lock])
 Function: set write locking during load
 Returns : current value of lock-on-load flag
 Args    : new value of lock-on-load-flag
 Status  : Public</code></code></pre>

<p>This method is honored by some of the adaptors. If the value is true, the tables used by the GFF modules will be locked for writing during loads and inaccessible to other processes.</p>

<h2 id="meta">meta</h2>

<pre><code><code> Title   : meta
 Usage   : $value = $db-&gt;meta($name [,$newval])
 Function: get or set a meta variable
 Returns : a string
 Args    : meta variable name and optionally value
 Status  : abstract</code></code></pre>

<p>Get or set a named metavalues for the database. Metavalues can be used for database-specific settings.</p>

<p>By default, this method does nothing!</p>

<h2 id="default_meta_values">default_meta_values</h2>

<pre><code><code> Title   : default_meta_values
 Usage   : %values = $db-&gt;default_meta_values
 Function: empty the database
 Returns : a list of tag=&gt;value pairs
 Args    : none
 Status  : protected</code></code></pre>

<p>This method returns a list of tag=&gt;value pairs that contain default meta information about the database. It is invoked by initialize() to write out the default meta values. The base class version returns an empty list.</p>

<p>For things to work properly, meta value names must be UPPERCASE.</p>

<h2 id="error">error</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">error</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">error</span><span class="operator">(</span> <span class="operator">[</span><span class="variable">$new</span> <span class="variable">error</span><span class="operator">]</span> <span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="keyword">read</span> <span class="keyword">or</span> <span class="variable">set</span> <span class="variable">error</span> <span class="variable">message</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">error</span> <span class="variable">message</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">an</span> <span class="variable">optional</span> <span class="variable">argument</span> <span class="variable">to</span> <span class="variable">set</span> <span class="variable">the</span> <span class="variable">error</span> <span class="variable">message</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
</code></code></pre>

<p>This method can be used to retrieve the last error message. Errors are not reset to empty by successful calls, so contents are only valid immediately after an error condition has been detected.</p>

<h2 id="debug">debug</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">debug</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">debug</span><span class="operator">(</span> <span class="operator">[</span><span class="variable">$flag</span><span class="operator">]</span> <span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="keyword">read</span> <span class="keyword">or</span> <span class="variable">set</span> <span class="variable">debug</span> <span class="variable">flag</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">current</span> <span class="variable">value</span> <span class="variable">of</span> <span class="variable">debug</span> <span class="variable">flag</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">new</span> <span class="variable">debug</span> <span class="variable">flag</span> <span class="operator">(</span><span class="variable">optional</span><span class="operator">)</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
</code></code></pre>

<p>This method can be used to turn on debug messages. The exact nature of those messages depends on the adaptor in use.</p>

<h2 id="automerge">automerge</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">automerge</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">automerge</span><span class="operator">(</span> <span class="operator">[</span><span class="variable">$new</span> <span class="variable">automerge</span><span class="operator">]</span> <span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">get</span> <span class="keyword">or</span> <span class="variable">set</span> <span class="variable">automerge</span> <span class="variable">value</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">current</span> <span class="variable">value</span> <span class="operator">(</span><span class="variable">boolean</span><span class="operator">)</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">an</span> <span class="variable">optional</span> <span class="variable">argument</span> <span class="variable">to</span> <span class="variable">set</span> <span class="variable">the</span> <span class="variable">automerge</span> <span class="variable">value</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">Public</span>
</code></code></pre>

<p>By default, this module will use the aggregators to merge groups into single composite objects. This default can be changed to false by calling automerge(0).</p>

<h2 id="attributes">attributes</h2>

<pre><code><code> Title   : attributes
 Usage   : @attributes = $db-&gt;attributes($id,$name)
 Function: get the &quot;attributes&quot; on a particular feature
 Returns : an array of string
 Args    : feature ID
 Status  : public</code></code></pre>

<p>Some GFF version 2 files use the groups column to store a series of attribute/value pairs. In this interpretation of GFF, the first such pair is treated as the primary group for the feature; subsequent pairs are treated as attributes. Two attributes have special meaning: &quot;Note&quot; is for backward compatibility and is used for unstructured text remarks. &quot;Alias&quot; is considered as a synonym for the feature name.</p>

<p>If no name is provided, then attributes() returns a flattened hash, of attribute=&gt;value pairs. This lets you do:</p>

<pre><code><code>  <span class="variable">%attributes</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">attributes</span><span class="operator">(</span><span class="variable">$id</span><span class="operator">);</span>
</code></code></pre>

<p>If no arguments are provided, attributes() will return the list of all attribute names:</p>

<pre><code><code>  <span class="variable">@attribute_names</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">attributes</span><span class="operator">();</span>
</code></code></pre>

<p>Normally, however, attributes() will be called by the feature:</p>

<pre><code><code>  <span class="variable">@notes</span> <span class="operator">=</span> <span class="variable">$feature</span><span class="operator">-&gt;</span><span class="variable">attributes</span><span class="operator">(</span><span class="string">'Note'</span><span class="operator">);</span>
</code></code></pre>

<p>In a scalar context, attributes() returns the first value of the attribute if a tag is present, otherwise a hash reference in which the keys are attribute names and the values are anonymous arrays containing the values.</p>

<h2 id="fast_queries">fast_queries</h2>

<pre><code><code> Title   : fast_queries
 Usage   : $flag = $db-&gt;fast_queries([$flag])
 Function: turn on and off the &quot;fast queries&quot; option
 Returns : a boolean
 Args    : a boolean flag (optional)
 Status  : public</code></code></pre>

<p>The mysql database driver (and possibly others) support a &quot;fast&quot; query mode that caches results on the server side. This makes queries come back faster, particularly when creating iterators. The downside is that while iterating, new queries will die with a &quot;command synch&quot; error. This method turns the feature on and off.</p>

<p>For databases that do not support a fast query, this method has no effect.</p>

<h2 id="add_aggregator">add_aggregator</h2>

<pre><code><code> Title   : add_aggregator
 Usage   : $db-&gt;add_aggregator($aggregator)
 Function: add an aggregator to the list
 Returns : nothing
 Args    : an aggregator
 Status  : public</code></code></pre>

<p>This method will append an aggregator to the end of the list of registered aggregators. Three different argument types are accepted:</p>

<pre><code><code>  <span class="number">1</span><span class="operator">)</span> <span class="variable">a</span> <span class="variable">Bio::DB::GFF::Aggregator</span> <span class="variable">object</span> <span class="operator">--</span> <span class="variable">will</span> <span class="variable">be</span> <span class="variable">added</span>
  <span class="number">2</span><span class="operator">)</span> <span class="variable">a</span> <span class="variable">string</span> <span class="variable">in</span> <span class="variable">the</span> <span class="variable">form</span> <span class="string">"aggregator_name{subpart1,subpart2,subpart3/main_method}"</span>
         <span class="operator">--</span> <span class="variable">will</span> <span class="variable">be</span> <span class="variable">turned</span> <span class="variable">into</span> <span class="variable">a</span> <span class="variable">Bio::DB::GFF::Aggregator</span> <span class="variable">object</span> <span class="operator">(</span><span class="variable">the</span> <span class="operator">/</span><span class="variable">main_method</span>
        <span class="variable">part</span> <span class="variable">is</span> <span class="variable">optional</span><span class="operator">).</span>
  <span class="number">3</span><span class="operator">)</span> <span class="variable">a</span> <span class="variable">valid</span> <span class="variable">Perl</span> <span class="variable">token</span> <span class="operator">--</span> <span class="variable">will</span> <span class="variable">be</span> <span class="variable">turned</span> <span class="variable">into</span> <span class="variable">a</span> <span class="variable">Bio::DB::GFF::Aggregator</span>
        <span class="variable">subclass</span><span class="operator">,</span> <span class="variable">where</span> <span class="variable">the</span> <span class="variable">token</span> <span class="variable">corresponds</span> <span class="variable">to</span> <span class="variable">the</span> <span class="variable">subclass</span> <span class="variable">name</span><span class="operator">.</span>
</code></code></pre>

<h2 id="aggregators">aggregators</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">aggregators</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">aggregators</span><span class="operator">(</span><span class="operator">[</span><span class="variable">@new_aggregators</span><span class="operator">]</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">retrieve</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">aggregators</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">aggregators</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">a</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">aggregators</span> <span class="variable">to</span> <span class="variable">set</span> <span class="operator">(</span><span class="variable">optional</span><span class="operator">)</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">public</span>
</code></code></pre>

<p>This method will get or set the list of aggregators assigned to the database. If 1 or more arguments are passed, the existing set will be cleared.</p>

<h2 id="clear_aggregators">clear_aggregators</h2>

<pre><code><code> Title   : clear_aggregators
 Usage   : $db-&gt;clear_aggregators
 Function: clears list of aggregators
 Returns : nothing
 Args    : none
 Status  : public</code></code></pre>

<p>This method will clear the aggregators stored in the database object. Use aggregators() or add_aggregator() to add some back.</p>

<h2 id="preferred_groups">preferred_groups</h2>

<pre><code><code> Title   : preferred_groups
 Usage   : $db-&gt;preferred_groups([$group_name_or_arrayref])
 Function: get/set list of groups for altering GFF2 parsing
 Returns : a list of classes
 Args    : new list (scalar or array ref)
 Status  : public</code></code></pre>

<h1 id="Methods-for-use-by-Subclasses">Methods for use by Subclasses</h1>

<p>The following methods are chiefly of interest to subclasses and are not intended for use by end programmers.</p>

<h2 id="abscoords">abscoords</h2>

<pre><code><code> Title   : abscoords
 Usage   : $db-&gt;abscoords($name,$class,$refseq)
 Function: finds position of a landmark in reference coordinates
 Returns : ($ref,$class,$start,$stop,$strand)
 Args    : name and class of landmark
 Status  : public</code></code></pre>

<p>This method is called by Bio::DB::GFF::RelSegment to obtain the absolute coordinates of a sequence landmark. The arguments are the name and class of the landmark. If successful, abscoords() returns the ID of the reference sequence, its class, its start and stop positions, and the orientation of the reference sequence&#39;s coordinate system (&quot;+&quot; for forward strand, &quot;-&quot; for reverse strand).</p>

<p>If $refseq is present in the argument list, it forces the query to search for the landmark in a particular reference sequence.</p>

<h1 id="Protected-API">Protected API</h1>

<p>The following methods are not intended for public consumption, but are intended to be overridden/implemented by adaptors.</p>

<h2 id="default_aggregators">default_aggregators</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">default_aggregators</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">default_aggregators</span><span class="operator">;</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">retrieve</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">aggregators</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">array</span> <span class="variable">reference</span> <span class="variable">containing</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">aggregator</span> <span class="variable">names</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">none</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">protected</span>
</code></code></pre>

<p>This method (which is intended to be overridden by adaptors) returns a list of standard aggregators to be applied when no aggregators are specified in the constructor.</p>

<h2 id="do_load_gff">do_load_gff</h2>

<pre><code><code> Title   : do_load_gff
 Usage   : $db-&gt;do_load_gff($handle)
 Function: load a GFF input stream
 Returns : number of features loaded
 Args    : A filehandle.
 Status  : protected</code></code></pre>

<p>This method is called to load a GFF data stream. The method will read GFF features from &lt;&gt; and load them into the database. On exit the method must return the number of features loaded.</p>

<p>Note that the method is responsible for parsing the GFF lines. This is to allow for differences in the interpretation of the &quot;group&quot; field, which are legion.</p>

<p>You probably want to use load_gff() instead. It is more flexible about the arguments it accepts.</p>

<h2 id="load_sequence">load_sequence</h2>

<pre><code><code> Title   : load_sequence
 Usage   : $db-&gt;load_sequence($handle)
 Function: load a FASTA data stream
 Returns : number of sequences
 Args    : a filehandle to the FASTA file
 Status  : protected</code></code></pre>

<p>You probably want to use load_fasta() instead.</p>

<h2 id="setup_load">setup_load</h2>

<pre><code><code> Title   : setup_load
 Usage   : $db-&gt;setup_load
 Function: called before load_gff_line()
 Returns : void
 Args    : none
 Status  : abstract</code></code></pre>

<p>This abstract method gives subclasses a chance to do any schema-specific initialization prior to loading a set of GFF records. It must be implemented by a subclass.</p>

<h2 id="finish_load">finish_load</h2>

<pre><code><code> Title   : finish_load
 Usage   : $db-&gt;finish_load
 Function: called after load_gff_line()
 Returns : number of records loaded
 Args    : none
 Status  :abstract</code></code></pre>

<p>This method gives subclasses a chance to do any schema-specific cleanup after loading a set of GFF records.</p>

<h2 id="load_gff_line">load_gff_line</h2>

<pre><code><code> Title   : load_gff_line
 Usage   : $db-&gt;load_gff_line(@args)
 Function: called to load one parsed line of GFF
 Returns : true if successfully inserted
 Args    : see below
 Status  : abstract</code></code></pre>

<p>This abstract method is called once per line of the GFF and passed a hashref containing parsed GFF fields. The fields are:</p>

<pre><code><code> <span class="operator">{</span><span class="string">ref</span>    <span class="operator">=&gt;</span> <span class="variable">$ref</span><span class="operator">,</span>
  <span class="string">class</span>  <span class="operator">=&gt;</span> <span class="variable">$class</span><span class="operator">,</span>
  <span class="string">source</span> <span class="operator">=&gt;</span> <span class="variable">$source</span><span class="operator">,</span>
  <span class="string">method</span> <span class="operator">=&gt;</span> <span class="variable">$method</span><span class="operator">,</span>
  <span class="string">start</span>  <span class="operator">=&gt;</span> <span class="variable">$start</span><span class="operator">,</span>
  <span class="string">stop</span>   <span class="operator">=&gt;</span> <span class="variable">$stop</span><span class="operator">,</span>
  <span class="string">score</span>  <span class="operator">=&gt;</span> <span class="variable">$score</span><span class="operator">,</span>
  <span class="string">strand</span> <span class="operator">=&gt;</span> <span class="variable">$strand</span><span class="operator">,</span>
  <span class="string">phase</span>  <span class="operator">=&gt;</span> <span class="variable">$phase</span><span class="operator">,</span>
  <span class="string">gclass</span> <span class="operator">=&gt;</span> <span class="variable">$gclass</span><span class="operator">,</span>
  <span class="string">gname</span>  <span class="operator">=&gt;</span> <span class="variable">$gname</span><span class="operator">,</span>
  <span class="string">tstart</span> <span class="operator">=&gt;</span> <span class="variable">$tstart</span><span class="operator">,</span>
  <span class="string">tstop</span>  <span class="operator">=&gt;</span> <span class="variable">$tstop</span><span class="operator">,</span>
  <span class="string">attributes</span>  <span class="operator">=&gt;</span> <span class="variable">$attributes</span><span class="operator">}</span>
</code></code></pre>

<h2 id="do_initialize">do_initialize</h2>

<pre><code><code> Title   : do_initialize
 Usage   : $db-&gt;do_initialize([$erase])
 Function: initialize and possibly erase database
 Returns : true if successful
 Args    : optional erase flag
 Status  : protected</code></code></pre>

<p>This method implements the initialize() method described above, and takes the same arguments.</p>

<h2 id="dna">dna</h2>

<pre><code><code> Title   : dna
 Usage   : $db-&gt;dna($id,$start,$stop,$class)
 Function: return the raw DNA string for a segment
 Returns : a raw DNA string
 Args    : id of the sequence, its class, start and stop positions
 Status  : public</code></code></pre>

<p>This method is invoked by Bio::DB::GFF::Segment to fetch the raw DNA sequence.</p>

<p>Arguments: -name sequence name -start start position -stop stop position -class sequence class</p>

<p>If start and stop are both undef, then the entire DNA is retrieved. So to fetch the whole dna, call like this:</p>

<pre><code><code>  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">dna</span><span class="operator">(</span><span class="variable">$name_of_sequence</span><span class="operator">);</span>
</code></code></pre>

<p>or like this:</p>

<pre><code><code>   <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">dna</span><span class="operator">(</span><span class="string">-name</span><span class="operator">=&gt;</span><span class="variable">$name_of_sequence</span><span class="operator">,</span><span class="string">-class</span><span class="operator">=&gt;</span><span class="variable">$class_of_sequence</span><span class="operator">);</span>
</code></code></pre>

<p>NOTE: you will probably prefer to create a Segment and then invoke its dna() method.</p>

<h2 id="get_dna">get_dna</h2>

<pre><code><code> Title   : get_dna
 Usage   : $db-&gt;get_dna($id,$start,$stop,$class)
 Function: get DNA for indicated segment
 Returns : the dna string
 Args    : sequence ID, start, stop and class
 Status  : protected</code></code></pre>

<p>If start &gt; stop and the sequence is nucleotide, then this method should return the reverse complement. The sequence class may be ignored by those databases that do not recognize different object types.</p>

<h2 id="get_features">get_features</h2>

<pre><code><code> Title   : get_features
 Usage   : $db-&gt;get_features($search,$options,$callback)
 Function: get list of features for a region
 Returns : count of number of features retrieved
 Args    : see below
 Status  : protected</code></code></pre>

<p>The first argument is a hash reference containing search criteria for retrieving features. It contains the following keys:</p>

<pre><code><code>   rangetype One of &quot;overlaps&quot;, &quot;contains&quot; or &quot;contained_in&quot;.  Indicates
              the type of range query requested.

   refseq    ID of the landmark that establishes the absolute 
              coordinate system.

   refclass  Class of this landmark.  Can be ignored by implementations
              that don&#39;t recognize such distinctions.

   start     Start of the range, inclusive.

   stop      Stop of the range, inclusive.

   types     Array reference containing the list of annotation types
              to fetch from the database.  Each annotation type is an
              array reference consisting of [source,method].</code></code></pre>

<p>The second argument is a hash reference containing certain options that affect the way information is retrieved:</p>

<pre><code><code>   sort_by_group
             A flag.  If true, means that the returned features should be
             sorted by the group that they&#39;re in.

   sparse    A flag.  If true, means that the expected density of the 
             features is such that it will be more efficient to search
             by type rather than by range.  If it is taking a long
             time to fetch features, give this a try.

   binsize   A true value will create a set of artificial features whose
             start and stop positions indicate bins of the given size, and
             whose scores are the number of features in the bin.  The
             class of the feature will be set to &quot;bin&quot;, and its name to
             &quot;method:source&quot;.  This is a handy way of generating histograms
             of feature density.</code></code></pre>

<p>The third argument, the $callback, is a code reference to which retrieved features are passed. It is described in more detail below.</p>

<p>This routine is responsible for getting arrays of GFF data out of the database and passing them to the callback subroutine. The callback does the work of constructing a Bio::DB::GFF::Feature object out of that data. The callback expects a list of 13 fields:</p>

<pre><code><code>  $refseq      The reference sequence
  $start       feature start
  $stop        feature stop
  $source      feature source
  $method      feature method
  $score       feature score
  $strand      feature strand
  $phase       feature phase
  $groupclass  group class (may be undef)
  $groupname   group ID (may be undef)
  $tstart      target start for similarity hits (may be undef)
  $tstop       target stop for similarity hits (may be undef)
  $feature_id  A unique feature ID (may be undef)</code></code></pre>

<p>These fields are in the same order as the raw GFF file, with the exception that the group column has been parsed into group class and group name fields.</p>

<p>The feature ID, if provided, is a unique identifier of the feature line. The module does not depend on this ID in any way, but it is available via Bio::DB::GFF-&gt;id() if wanted. In the dbi::mysql and dbi::mysqlopt adaptor, the ID is a unique row ID. In the acedb adaptor it is not used.</p>

<h2 id="feature_summary-coverage_array-">feature_summary(), coverage_array()</h2>

<p>The DBI adaptors provide methods for rapidly fetching coverage statistics across a region of interest. Please see <a href="../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/Adaptor/dbi.html">Bio::DB::GFF::Adaptor::dbi</a> for more information about these methods.</p>

<h2 id="feature_by_name">_feature_by_name</h2>

<pre><code><code> Title   : _feature_by_name
 Usage   : $db-&gt;_feature_by_name($class,$name,$location,$callback)
 Function: get a list of features by name and class
 Returns : count of number of features retrieved
 Args    : name of feature, class of feature, and a callback
 Status  : abstract</code></code></pre>

<p>This method is used internally. The callback arguments are the same as those used by make_feature(). This method must be overidden by subclasses.</p>

<h2 id="feature_by_id">_feature_by_id</h2>

<pre><code><code> Title   : _feature_by_id
 Usage   : $db-&gt;_feature_by_id($ids,$type,$callback)
 Function: get a feature based
 Returns : count of number of features retrieved
 Args    : arrayref to feature IDs to fetch
 Status  : abstract</code></code></pre>

<p>This method is used internally to fetch features either by their ID or their group ID. $ids is a arrayref containing a list of IDs, $type is one of &quot;feature&quot; or &quot;group&quot;, and $callback is a callback. The callback arguments are the same as those used by make_feature(). This method must be overidden by subclasses.</p>

<h2 id="overlapping_features">overlapping_features</h2>

<pre><code><code> Title   : overlapping_features
 Usage   : $db-&gt;overlapping_features(@args)
 Function: get features that overlap the indicated range
 Returns : a list of Bio::DB::GFF::Feature objects
 Args    : see below
 Status  : public</code></code></pre>

<p>This method is invoked by Bio::DB::GFF::Segment-&gt;features() to find the list of features that overlap a given range. It is generally preferable to create the Segment first, and then fetch the features.</p>

<p>This method takes set of named arguments:</p>

<pre><code><code>  -refseq    ID of the reference sequence
  -class     Class of the reference sequence
  -start     Start of the desired range in refseq coordinates
  -stop      Stop of the desired range in refseq coordinates
  -types     List of feature types to return.  Argument is an array
             reference containing strings of the format &quot;method:source&quot;
  -parent    A parent Bio::DB::GFF::Segment object, used to create
             relative coordinates in the generated features.
  -rare      Turn on an optimization suitable for a relatively rare feature type,
             where it will be faster to filter by feature type first
             and then by position, rather than vice versa.
  -merge     Whether to apply aggregators to the generated features.
  -iterator  Whether to return an iterator across the features.</code></code></pre>

<p>If -iterator is true, then the method returns a single scalar value consisting of a Bio::SeqIO object. You can call next_seq() repeatedly on this object to fetch each of the features in turn. If iterator is false or absent, then all the features are returned as a list.</p>

<p>Currently aggregation is disabled when iterating over a series of features.</p>

<p>Types are indicated using the nomenclature &quot;method:source&quot;. Either of these fields can be omitted, in which case a wildcard is used for the missing field. Type names without the colon (e.g. &quot;exon&quot;) are interpreted as the method name and a source wild card. Regular expressions are allowed in either field, as in: &quot;similarity:BLAST.*&quot;.</p>

<h2 id="contained_features">contained_features</h2>

<pre><code><code> Title   : contained_features
 Usage   : $db-&gt;contained_features(@args)
 Function: get features that are contained within the indicated range
 Returns : a list of Bio::DB::GFF::Feature objects
 Args    : see overlapping_features()
 Status  : public</code></code></pre>

<p>This call is similar to overlapping_features(), except that it only retrieves features whose end points are completely contained within the specified range.</p>

<p>Generally you will want to fetch a Bio::DB::GFF::Segment object and call its contained_features() method rather than call this directly.</p>

<h2 id="contained_in">contained_in</h2>

<pre><code><code> Title   : contained_in
 Usage   : @features = $s-&gt;contained_in(@args)
 Function: get features that contain this segment
 Returns : a list of Bio::DB::GFF::Feature objects
 Args    : see features()
 Status  : Public</code></code></pre>

<p>This is identical in behavior to features() except that it returns only those features that completely contain the segment.</p>

<h2 id="get_abscoords">get_abscoords</h2>

<pre><code><code> Title   : get_abscoords
 Usage   : $db-&gt;get_abscoords($name,$class,$refseq)
 Function: get the absolute coordinates of sequence with name &amp; class
 Returns : ($absref,$absstart,$absstop,$absstrand)
 Args    : name and class of the landmark
 Status  : protected</code></code></pre>

<p>Given the name and class of a genomic landmark, this function returns a four-element array consisting of:</p>

<pre><code><code>  $absref      the ID of the reference sequence that contains this landmark
  $absstart    the position at which the landmark starts
  $absstop     the position at which the landmark stops
  $absstrand   the strand of the landmark, relative to the reference sequence</code></code></pre>

<p>If $refseq is provided, the function searches only within the specified reference sequence.</p>

<h2 id="get_types">get_types</h2>

<pre><code><code> Title   : get_types
 Usage   : $db-&gt;get_types($absref,$class,$start,$stop,$count)
 Function: get list of all feature types on the indicated segment
 Returns : list or hash of Bio::DB::GFF::Typename objects
 Args    : see below
 Status  : protected</code></code></pre>

<p>Arguments are:</p>

<pre><code><code>  $absref      the ID of the reference sequence
  $class       the class of the reference sequence
  $start       the position to start counting
  $stop        the position to end counting
  $count       a boolean indicating whether to count the number
               of occurrences of each feature type</code></code></pre>

<p>If $count is true, then a hash is returned. The keys of the hash are feature type names in the format &quot;method:source&quot; and the values are the number of times a feature of this type overlaps the indicated segment. Otherwise, the call returns a set of Bio::DB::GFF::Typename objects. If $start or $stop are undef, then all features on the indicated segment are enumerated. If $absref is undef, then the call returns all feature types in the database.</p>

<h2 id="make_feature">make_feature</h2>

<pre><code><code> Title   : make_feature
 Usage   : $db-&gt;make_feature(@args)
 Function: Create a Bio::DB::GFF::Feature object from string data
 Returns : a Bio::DB::GFF::Feature object
 Args    : see below
 Status  : internal

 This takes 14 arguments (really!):

  $parent                A Bio::DB::GFF::RelSegment object
  $group_hash            A hashref containing unique list of GFF groups
  $refname               The name of the reference sequence for this feature
  $refclass              The class of the reference sequence for this feature
  $start                 Start of feature
  $stop                  Stop of feature
  $source                Feature source field
  $method                Feature method field
  $score                 Feature score field
  $strand                Feature strand
  $phase                 Feature phase
  $group_class           Class of feature group
  $group_name            Name of feature group
  $tstart                For homologies, start of hit on target
  $tstop                 Stop of hit on target</code></code></pre>

<p>The $parent argument, if present, is used to establish relative coordinates in the resulting Bio::DB::Feature object. This allows one feature to generate a list of other features that are relative to its coordinate system (for example, finding the coordinates of the second exon relative to the coordinates of the first).</p>

<p>The $group_hash allows the group_class/group_name strings to be turned into rich database objects via the make_obect() method (see above). Because these objects may be expensive to create, $group_hash is used to uniquefy them. The index of this hash is the composite key {$group_class,$group_name,$tstart,$tstop}. Values are whatever object is returned by the make_object() method.</p>

<p>The remainder of the fields are taken from the GFF line, with the exception that &quot;Target&quot; features, which contain information about the target of a homology search, are parsed into their components.</p>

<h2 id="make_match_sub">make_match_sub</h2>

<pre><code><code> Title   : make_match_sub
 Usage   : $db-&gt;make_match_sub($types)
 Function: creates a subroutine used for filtering features
 Returns : a code reference
 Args    : a list of parsed type names
 Status  : protected</code></code></pre>

<p>This method is used internally to generate a code subroutine that will accept or reject a feature based on its method and source. It takes an array of parsed type names in the format returned by parse_types(), and generates an anonymous subroutine. The subroutine takes a single Bio::DB::GFF::Feature object and returns true if the feature matches one of the desired feature types, and false otherwise.</p>

<h2 id="make_object">make_object</h2>

<pre><code><code> Title   : make_object
 Usage   : $db-&gt;make_object($class,$name,$start,$stop)
 Function: creates a feature object
 Returns : a feature object
 Args    : see below
 Status  : protected</code></code></pre>

<p>This method is called to make an object from the GFF &quot;group&quot; field. By default, all Target groups are turned into Bio::DB::GFF::Homol objects, and everything else becomes a Bio::DB::GFF::Featname. However, adaptors are free to override this method to generate more interesting objects, such as true BioPerl objects, or Acedb objects.</p>

<p>Arguments are:</p>

<pre><code><code>  $name      database ID for object
  $class     class of object
  $start     for similarities, start of match inside object
  $stop      for similarities, stop of match inside object</code></code></pre>

<h2 id="do_attributes">do_attributes</h2>

<pre><code><code> <span class="variable">Title</span>   <span class="operator">:</span> <span class="variable">do_attributes</span>
 <span class="variable">Usage</span>   <span class="operator">:</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">do_attributes</span><span class="operator">(</span><span class="variable">$id</span> <span class="operator">[</span><span class="operator">,</span><span class="variable">$tag</span><span class="operator">]</span><span class="operator">);</span>
 <span class="variable">Function</span><span class="operator">:</span> <span class="variable">internal</span> <span class="variable">method</span> <span class="variable">to</span> <span class="variable">retrieve</span> <span class="variable">attributes</span> <span class="keyword">given</span> <span class="variable">an</span> <span class="variable">id</span> <span class="keyword">and</span> <span class="variable">tag</span>
 <span class="variable">Returns</span> <span class="operator">:</span> <span class="variable">a</span> <span class="variable">list</span> <span class="variable">of</span> <span class="variable">Bio::DB::GFF::Feature</span> <span class="variable">objects</span>
 <span class="variable">Args</span>    <span class="operator">:</span> <span class="variable">a</span> <span class="variable">feature</span> <span class="variable">id</span> <span class="keyword">and</span> <span class="variable">a</span> <span class="variable">attribute</span> <span class="variable">tag</span> <span class="operator">(</span><span class="variable">optional</span><span class="operator">)</span>
 <span class="variable">Status</span>  <span class="operator">:</span> <span class="variable">protected</span>
</code></code></pre>

<p>This method is overridden by subclasses in order to return a list of attributes. If called with a tag, returns the value of attributes of that tag type. If called without a tag, returns a flattened array of (tag=&gt;value) pairs. A particular tag can be present multiple times.</p>

<h2 id="clone">clone</h2>

<p>The clone() method should be used when you want to pass the Bio::DB::GFF object to a child process across a fork(). The child must call clone() before making any queries.</p>

<p>The default behavior is to do nothing, but adaptors that use the DBI interface may need to implement this in order to avoid database handle errors. See the dbi adaptor for an example.</p>

<h1 id="Internal-Methods">Internal Methods</h1>

<p>The following methods are internal to Bio::DB::GFF and are not guaranteed to remain the same.</p>

<h2 id="features1">_features</h2>

<pre><code><code> Title   : _features
 Usage   : $db-&gt;_features($search,$options,$parent)
 Function: internal method
 Returns : a list of Bio::DB::GFF::Feature objects
 Args    : see below
 Status  : internal</code></code></pre>

<p>This is an internal method that is called by overlapping_features(), contained_features() and features() to create features based on a parent segment&#39;s coordinate system. It takes three arguments, a search options hashref, an options hashref, and a parent segment.</p>

<p>The search hashref contains the following keys:</p>

<pre><code><code>  rangetype     One of &quot;overlaps&quot;, &quot;contains&quot; or &quot;contained_in&quot;.  Indicates
                the type of range query requested.
  refseq        reference sequence ID
  refclass      reference sequence class
  start         start of range
  stop          stop of range
  types         arrayref containing list of types in &quot;method:source&quot; form</code></code></pre>

<p>The options hashref contains zero or more of the following keys:</p>

<pre><code><code>  sparse        turn on optimizations for a rare feature
  automerge     if true, invoke aggregators to merge features
  iterator      if true, return an iterator</code></code></pre>

<p>The $parent argument is a scalar object containing a Bio::DB::GFF::RelSegment object or descendent.</p>

<h2 id="get_features_iterator">get_features_iterator</h2>

<pre><code><code> Title   : get_features_iterator
 Usage   : $db-&gt;get_features_iterator($search,$options,$callback)
 Function: get an iterator on a features query
 Returns : a Bio::SeqIO object
 Args    : as per get_features()
 Status  : Public</code></code></pre>

<p>This method takes the same arguments as get_features(), but returns an iterator that can be used to fetch features sequentially, as per Bio::SeqIO.</p>

<p>Internally, this method is simply a front end to range_query(). The latter method constructs and executes the query, returning a statement handle. This routine passes the statement handle to the constructor for the iterator, along with the callback.</p>

<h2 id="split_group">split_group</h2>

<pre><code><code> Title   : split_group
 Usage   : $db-&gt;split_group($group_field,$gff3_flag)
 Function: parse GFF group field
 Returns : ($gclass,$gname,$tstart,$tstop,$attributes)
 Args    : the gff group column and a flag indicating gff3 compatibility
 Status  : internal</code></code></pre>

<p>This is a method that is called by load_gff_line to parse out the contents of one or more group fields. It returns the class of the group, its name, the start and stop of the target, if any, and an array reference containing any attributes that were stuck into the group field, in [attribute_name,attribute_value] format.</p>

<h2 id="split_gff2_group">_split_gff2_group</h2>

<p>This is an internal method called by split_group().</p>

<h2 id="gff3_name_munging">gff3_name_munging</h2>

<pre><code><code> Title   : gff3_name_munging
 Usage   : $db-&gt;gff3_name_munging($boolean)
 Function: get/set gff3_name_munging flag
 Returns : $current value of flag
 Args    : new value of flag (optional)
 Status  : utility</code></code></pre>

<p>If this is set to true (default false), then features identified in gff3 files with an ID in the format foo:bar will be parsed so that &quot;foo&quot; is the class and &quot;bar&quot; is the name. This is mostly for backward compatibility with GFF2.</p>

<h2 id="split_gff3_group">_split_gff3_group</h2>

<p>This is called internally from split_group().</p>

<h2 id="delete_features-_delete_groups-_delete-_delete_fattribute_to_features-">_delete_features(), _delete_groups(),_delete(),_delete_fattribute_to_features()</h2>

<pre><code><code> Title   : _delete_features(), _delete_groups(),_delete(),_delete_fattribute_to_features()
 Usage   : $count = $db-&gt;_delete_features(@feature_ids)
           $count = $db-&gt;_delete_groups(@group_ids)
           $count = $db-&gt;_delete(\%delete_spec)
           $count = $db-&gt;_delete_fattribute_to_features(@feature_ids)
 Function: low-level feature/group deleter
 Returns : count of groups removed
 Args    : list of feature or group ids removed
 Status  : for implementation by subclasses</code></code></pre>

<p>These methods need to be implemented in adaptors. For _delete_features, _delete_groups and _delete_fattribute_to_features, the arguments are a list of feature or group IDs to remove. For _delete(), the argument is a hashref with the three keys &#39;segments&#39;, &#39;types&#39; and &#39;force&#39;. The first contains an arrayref of Bio::DB::GFF::RelSegment objects to delete (all FEATURES within the segment are deleted). The second contains an arrayref of [method,source] feature types to delete. The two are ANDed together. If &#39;force&#39; has a true value, this forces the operation to continue even if it would delete all features.</p>

<h1 id="BUGS">BUGS</h1>

<p>Features can only belong to a single group at a time. This must be addressed soon.</p>

<p>Start coordinate can be greater than stop coordinate for relative addressing. This breaks strict BioPerl compatibility and must be fixed.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/RelSegment.html">Bio::DB::GFF::RelSegment</a>, <a href="../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/Aggregator.html">Bio::DB::GFF::Aggregator</a>, <a href="../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/Feature.html">Bio::DB::GFF::Feature</a>, <a href="../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/Adaptor/dbi/mysqlopt.html">Bio::DB::GFF::Adaptor::dbi::mysqlopt</a>, <a href="../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/Adaptor/dbi/oracle.html">Bio::DB::GFF::Adaptor::dbi::oracle</a>, <a href="../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/Adaptor/memory.html">Bio::DB::GFF::Adaptor::memory</a> <a href="../../../../../.cpan/build/BioPerl-1.6.901-ghKY8U/blib/lib/Bio/DB/GFF/Adaptor/berkeleydb.html">Bio::DB::GFF::Adaptor::berkeleydb</a></p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Lincoln Stein &lt;lstein@cshl.org&gt;.</p>

<p>Copyright (c) 2001 Cold Spring Harbor Laboratory.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>


</body>

</html>


