<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#A-NOTE-TO-THE-READER">A NOTE TO THE READER</a></li>
  <li><a href="#OBJECT-CONTENTS">OBJECT CONTENTS</a>
    <ul>
      <li><a href="#About-The-Documented-Interface">About The Documented Interface</a></li>
    </ul>
  </li>
  <li><a href="#MAIN-CONSTRUCTOR-AND-INITIALIZER">MAIN CONSTRUCTOR, AND INITIALIZER</a></li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#add_daughter-LIST-">add_daughter(LIST)</a></li>
      <li><a href="#add_daughters-LIST-">add_daughters(LIST)</a></li>
      <li><a href="#add_daughter_left-LIST-">add_daughter_left(LIST)</a></li>
      <li><a href="#add_daughters_left-LIST-">add_daughters_left(LIST)</a></li>
      <li><a href="#add_left_sister-LIST-">add_left_sister(LIST)</a></li>
      <li><a href="#add_left_sisters-LIST-">add_left_sisters(LIST)</a></li>
      <li><a href="#add_right_sister-LIST-">add_right_sister(LIST)</a></li>
      <li><a href="#add_right_sisters-LIST-">add_right_sisters(LIST)</a></li>
      <li><a href="#address-">address()</a></li>
      <li><a href="#address-ADDRESS-">address(ADDRESS)</a></li>
      <li><a href="#ancestors-">ancestors()</a></li>
      <li><a href="#attribute-">attribute()</a></li>
      <li><a href="#attribute-SCALAR-">attribute(SCALAR)</a></li>
      <li><a href="#attributes-">attributes()</a></li>
      <li><a href="#attributes-SCALAR-">attributes(SCALAR)</a></li>
      <li><a href="#clear_daughters-">clear_daughters()</a></li>
      <li><a href="#common-LIST-">common(LIST)</a></li>
      <li><a href="#common_ancestor-LIST-">common_ancestor(LIST)</a></li>
      <li><a href="#copy_at_and_under-">copy_at_and_under()</a></li>
      <li><a href="#copy_at_and_under-options-">copy_at_and_under($options)</a></li>
      <li><a href="#copy_tree-">copy_tree()</a></li>
      <li><a href="#copy_tree-options-">copy_tree($options)</a></li>
      <li><a href="#daughters-">daughters()</a></li>
      <li><a href="#delete_tree-">delete_tree()</a></li>
      <li><a href="#depth_under-">depth_under()</a></li>
      <li><a href="#descendants-">descendants()</a></li>
      <li><a href="#draw_ascii_tree-options-">draw_ascii_tree([$options])</a></li>
      <li><a href="#dump_names-options-">dump_names($options)</a></li>
      <li><a href="#format_node-options-node-">format_node([$options], [$node])</a></li>
      <li><a href="#generation-">generation()</a></li>
      <li><a href="#generation_under-node-">generation_under($node)</a></li>
      <li><a href="#is_daughter_of-node2-">is_daughter_of($node2)</a></li>
      <li><a href="#is_node-">is_node()</a></li>
      <li><a href="#is_root-">is_root()</a></li>
      <li><a href="#leaves_under-">leaves_under()</a></li>
      <li><a href="#left_sister-">left_sister()</a></li>
      <li><a href="#left_sisters-">left_sisters()</a></li>
      <li><a href="#lol_to_tree-lol-">lol_to_tree($lol)</a></li>
      <li><a href="#mother-">mother()</a></li>
      <li><a href="#my_daughter_index-">my_daughter_index()</a></li>
      <li><a href="#name-">name()</a></li>
      <li><a href="#name-SCALAR-">name(SCALAR)</a></li>
      <li><a href="#new-hashref-">new($hashref)</a></li>
      <li><a href="#new_daughter-">new_daughter()</a></li>
      <li><a href="#new_daughter-options-">new_daughter($options)</a></li>
      <li><a href="#new_daughter_left-">new_daughter_left()</a></li>
      <li><a href="#new_daughter_left-options-">new_daughter_left($options)</a></li>
      <li><a href="#node2string-options-t-vert_dashes-">node2string($options, $t, $vert_dashes)</a></li>
      <li><a href="#random_network-options-">random_network($options)</a></li>
      <li><a href="#remove_daughter-LIST-">remove_daughter(LIST)</a></li>
      <li><a href="#remove_daughters-LIST-">remove_daughters(LIST)</a></li>
      <li><a href="#replace_with-LIST-">replace_with(LIST)</a></li>
      <li><a href="#replace_with_daughters-">replace_with_daughters()</a></li>
      <li><a href="#right_sister-">right_sister()</a></li>
      <li><a href="#right_sisters-">right_sisters()</a></li>
      <li><a href="#root-">root()</a></li>
      <li><a href="#self_and_descendants-">self_and_descendants()</a></li>
      <li><a href="#self_and_sisters-">self_and_sisters()</a></li>
      <li><a href="#set_daughters-LIST-">set_daughters(LIST)</a></li>
      <li><a href="#simple_lol_to_tree-simple_lol-">simple_lol_to_tree($simple_lol)</a></li>
      <li><a href="#sisters-">sisters()</a></li>
      <li><a href="#tree_to_lol-">tree_to_lol()</a></li>
      <li><a href="#tree_to_lol_notation-options-">tree_to_lol_notation($options)</a></li>
      <li><a href="#tree_to_simple_lol-">tree_to_simple_lol()</a></li>
      <li><a href="#tree_to_simple_lol_notation-options-">tree_to_simple_lol_notation($options)</a></li>
      <li><a href="#tree2string-options-some_tree-">tree2string([$options], [$some_tree])</a></li>
      <li><a href="#unlink_from_mother-">unlink_from_mother()</a></li>
      <li><a href="#walk_down-options-">walk_down($options)</a></li>
    </ul>
  </li>
  <li><a href="#WHEN-AND-HOW-TO-DESTROY-THE-TREE">WHEN AND HOW TO DESTROY THE TREE</a></li>
  <li><a href="#BUG-REPORTS">BUG REPORTS</a></li>
  <li><a href="#HELP-">HELP!</a></li>
  <li><a href="#RAMBLINGS">RAMBLINGS</a></li>
  <li><a href="#FAQ">FAQ</a>
    <ul>
      <li><a href="#Which-is-the-best-tree-processing-module-">Which is the best tree processing module?</a></li>
      <li><a href="#How-to-process-every-node-in-tree-">How to process every node in tree?</a></li>
      <li><a href="#How-do-I-switch-from-Tree-to-Tree::DAG_Node-">How do I switch from Tree to Tree::DAG_Node?</a></li>
      <li><a href="#Are-there-techniques-for-processing-lists-of-nodes-">Are there techniques for processing lists of nodes?</a></li>
      <li><a href="#Why-did-you-break-up-the-sections-of-methods-in-the-POD-">Why did you break up the sections of methods in the POD?</a></li>
      <li><a href="#Why-did-you-move-the-POD-to-the-end-">Why did you move the POD to the end?</a></li>
    </ul>
  </li>
  <li><a href="#TODO">TODO</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#REFERENCES">REFERENCES</a></li>
  <li><a href="#MACHINE-READABLE-CHANGE-LOG">MACHINE-READABLE CHANGE LOG</a></li>
  <li><a href="#SUPPORT">SUPPORT</a></li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
  <li><a href="#MAINTAINER">MAINTAINER</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT-LICENSE-AND-DISCLAIMER">COPYRIGHT, LICENSE, AND DISCLAIMER</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Tree::DAG_Node - An N-ary tree</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>Using as a base class:</p>

<pre><code><code>        <span class="keyword">package</span> <span class="variable">Game::Tree::Node</span><span class="operator">;</span>
        
        <span class="keyword">use</span> <span class="variable">parent</span> <span class="string">'Tree::DAG_Node'</span><span class="operator">;</span>
        
        <span class="comment"># Now add your own methods overriding/extending the methods in C&lt;Tree::DAG_Node&gt;...</span>
</code></code></pre>

<p>Using as a class of its own:</p>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">Tree::DAG_Node</span><span class="operator">;</span>
        
        <span class="keyword">my</span> <span class="variable">$root</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
        
        <span class="variable">$root</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">(</span><span class="string">"I'm the tops"</span><span class="operator">);</span>
        <span class="keyword">my</span> <span class="variable">$new_daughter</span> <span class="operator">=</span> <span class="variable">$root</span><span class="operator">-&gt;</span><span class="variable">new_daughter</span><span class="operator">;</span>
        <span class="variable">$new_daughter</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">(</span><span class="string">"More"</span><span class="operator">);</span>
        <span class="operator">...</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This class encapsulates/makes/manipulates objects that represent nodes in a tree structure. The tree structure is not an object itself, but is emergent from the linkages you create between nodes. This class provides the methods for making linkages that can be used to build up a tree, while preventing you from ever making any kinds of linkages which are not allowed in a tree (such as having a node be its own mother or ancestor, or having a node have two mothers).</p>

<p>This is what I mean by a &quot;tree structure&quot;, a bit redundantly stated:</p>

<dl>

<dt id="o-A-tree-is-a-special-case-of-an-acyclic-directed-graph">o A tree is a special case of an acyclic directed graph</dt>
<dd>

</dd>
<dt id="o-A-tree-is-a-network-of-nodes-where-theres-exactly-one-root-node">o A tree is a network of nodes where there&#39;s exactly one root node</dt>
<dd>

<p>Also, the only primary relationship between nodes is the mother-daughter relationship.</p>

</dd>
<dt id="o-No-node-can-be-its-own-mother-or-its-mothers-mother-etc">o No node can be its own mother, or its mother&#39;s mother, etc</dt>
<dd>

</dd>
<dt id="o-Each-node-in-the-tree-has-exactly-one-parent">o Each node in the tree has exactly one parent</dt>
<dd>

<p>Except for the root of course, which is parentless.</p>

</dd>
<dt id="o-Each-node-can-have-any-number-0-..-N-daughter-nodes">o Each node can have any number (0 .. N) daughter nodes</dt>
<dd>

<p>A given node&#39;s daughter nodes constitute an <i>ordered</i> list.</p>

<p>However, you are free to consider this ordering irrelevant. Some applications do need daughters to be ordered, so I chose to consider this the general case.</p>

</dd>
<dt id="o-A-node-can-appear-in-only-one-tree-and-only-once-in-that-tree">o A node can appear in only one tree, and only once in that tree</dt>
<dd>

<p>Notably (notable because it doesn&#39;t follow from the two above points), a node cannot appear twice in its mother&#39;s daughter list.</p>

</dd>
<dt id="o-Theres-an-idea-of-up-versus-down">o There&#39;s an idea of up versus down</dt>
<dd>

<p>Up means towards to the root, and down means away from the root (and towards the leaves).</p>

</dd>
<dt id="o-Theres-an-idea-of-left-versus-right">o There&#39;s an idea of left versus right</dt>
<dd>

<p>Left is toward the start (index 0) of a given node&#39;s daughter list, and right is toward the end of a given node&#39;s daughter list.</p>

</dd>
</dl>

<p>Trees as described above have various applications, among them: representing syntactic constituency, in formal linguistics; representing contingencies in a game tree; representing abstract syntax in the parsing of any computer language -- whether in expression trees for programming languages, or constituency in the parse of a markup language document. (Some of these might not use the fact that daughters are ordered.)</p>

<p>(Note: B-Trees are a very special case of the above kinds of trees, and are best treated with their own class. Check CPAN for modules encapsulating B-Trees; or if you actually want a database, and for some reason ended up looking here, go look at <a href="../../../lib/AnyDBM_File.html">AnyDBM_File</a>.)</p>

<p>Many base classes are not usable except as such -- but <code><code>Tree::DAG_Node</code></code> can be used as a normal class. You can go ahead and say:</p>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">Tree::DAG_Node</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$root</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
        <span class="variable">$root</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">(</span><span class="string">"I'm the tops"</span><span class="operator">);</span>
        <span class="variable">$new_daughter</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
        <span class="variable">$new_daughter</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">(</span><span class="string">"More"</span><span class="operator">);</span>
        <span class="variable">$root</span><span class="operator">-&gt;</span><span class="variable">add_daughter</span><span class="operator">(</span><span class="variable">$new_daughter</span><span class="operator">);</span>
</code></code></pre>

<p>and so on, constructing and linking objects from <code><code>Tree::DAG_Node</code></code> and making useful tree structures out of them.</p>

<h1 id="A-NOTE-TO-THE-READER">A NOTE TO THE READER</h1>

<p>This class is big and provides lots of methods. If your problem is simple (say, just representing a simple parse tree), this class might seem like using an atomic sledgehammer to swat a fly. But the complexity of this module&#39;s bells and whistles shouldn&#39;t detract from the efficiency of using this class for a simple purpose. In fact, I&#39;d be very surprised if any one user ever had use for more that even a third of the methods in this class. And remember: an atomic sledgehammer <b>will</b> kill that fly.</p>

<h1 id="OBJECT-CONTENTS">OBJECT CONTENTS</h1>

<p>Implementationally, each node in a tree is an object, in the sense of being an arbitrarily complex data structure that belongs to a class (presumably <code><code>Tree::DAG_Node</code></code>, or ones derived from it) that provides methods.</p>

<p>The attributes of a node-object are:</p>

<dl>

<dt id="o-mother----this-nodes-mother.-undef-if-this-is-a-root">o mother -- this node&#39;s mother. undef if this is a root</dt>
<dd>

</dd>
<dt id="o-daughters----the-possibly-empty-list-of-daughters-of-this-node">o daughters -- the (possibly empty) list of daughters of this node</dt>
<dd>

</dd>
<dt id="o-name----the-name-for-this-node">o name -- the name for this node</dt>
<dd>

<p>Need not be unique, or even printable. This is printed in some of the various dumper methods, but it&#39;s up to you if you don&#39;t put anything meaningful or printable here.</p>

</dd>
<dt id="o-attributes----whatever-the-user-wants-to-use-it-for">o attributes -- whatever the user wants to use it for</dt>
<dd>

<p>Presumably a hashref to whatever other attributes the user wants to store without risk of colliding with the object&#39;s real attributes. (Example usage: attributes to an SGML tag -- you definitely wouldn&#39;t want the existence of a &quot;mother=foo&quot; pair in such a tag to collide with a node object&#39;s &#39;mother&#39; attribute.)</p>

<p>Aside from (by default) initializing it to {}, and having the access method called &quot;attributes&quot; (described a ways below), I don&#39;t do anything with the &quot;attributes&quot; in this module. I basically intended this so that users who don&#39;t want/need to bother deriving a class from <code><code>Tree::DAG_Node</code></code>, could still attach whatever data they wanted in a node.</p>

</dd>
</dl>

<p>&quot;mother&quot; and &quot;daughters&quot; are attributes that relate to linkage -- they are never written to directly, but are changed as appropriate by the &quot;linkage methods&quot;, discussed below.</p>

<p>The other two (and whatever others you may add in derived classes) are simply accessed thru the same-named methods, discussed further below.</p>

<h2 id="About-The-Documented-Interface">About The Documented Interface</h2>

<p>Stick to the documented interface (and comments in the source -- especially ones saying &quot;undocumented!&quot; and/or &quot;disfavored!&quot; -- do not count as documentation!), and don&#39;t rely on any behavior that&#39;s not in the documented interface.</p>

<p>Specifically, unless the documentation for a particular method says &quot;this method returns thus-and-such a value&quot;, then you should not rely on it returning anything meaningful.</p>

<p>A <i>passing</i> acquintance with at least the broader details of the source code for this class is assumed for anyone using this class as a base class -- especially if you&#39;re overriding existing methods, and <b>definitely</b> if you&#39;re overriding linkage methods.</p>

<h1 id="MAIN-CONSTRUCTOR-AND-INITIALIZER">MAIN CONSTRUCTOR, AND INITIALIZER</h1>

<dl>

<dt id="the-constructor-CLASS-new-or-CLASS-new-options-">the constructor CLASS-&gt;new() or CLASS-&gt;new($options)</dt>
<dd>

<p>This creates a new node object, calls $object-&gt;_init($options) to provide it sane defaults (like: undef name, undef mother, no daughters, &#39;attributes&#39; setting of a new empty hashref), and returns the object created. (If you just said &quot;CLASS-&gt;new()&quot; or &quot;CLASS-&gt;new&quot;, then it pretends you called &quot;CLASS-&gt;new({})&quot;.)</p>

<p>Currently no options for putting in hashref $options are part of the documented interface, but the options is here in case you want to add such behavior in a derived class.</p>

<p>Read on if you plan on using Tree::DAG_New as a base class. (Otherwise feel free to skip to the description of _init.)</p>

<p>There are, in my mind, two ways to do object construction:</p>

<p>Way 1: create an object, knowing that it&#39;ll have certain uninteresting sane default values, and then call methods to change those values to what you want. Example:</p>

<pre><code><code>    <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
    <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">(</span><span class="string">'Supahnode!'</span><span class="operator">);</span>
    <span class="variable">$root</span><span class="operator">-&gt;</span><span class="variable">add_daughter</span><span class="operator">(</span><span class="variable">$node</span><span class="operator">);</span>
    <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">add_daughters</span><span class="operator">(</span><span class="variable">@some_others</span><span class="operator">)</span>
</code></code></pre>

<p>Way 2: be able to specify some/most/all the object&#39;s attributes in the call to the constructor. Something like:</p>

<pre><code><code>    <span class="variable">$node</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="operator">{</span>
      <span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'Supahnode!'</span><span class="operator">,</span>
      <span class="string">mother</span> <span class="operator">=&gt;</span> <span class="variable">$root</span><span class="operator">,</span>
      <span class="string">daughters</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">@some_others</span>
    <span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>After some deliberation, I&#39;ve decided that the second way is a Bad Thing. First off, it is <b>not</b> markedly more concise than the first way. Second off, it often requires subtly different syntax (e.g., \@some_others vs @some_others). It just complicates things for the programmer and the user, without making either appreciably happier.</p>

<p>See however the comments under <a href="#new-hashref-">&quot;new($hashref)&quot;</a> for options supported in the call to new().</p>

<p>(This is not to say that options in general for a constructor are bad -- <a href="#random_network-options-">&quot;random_network($options)&quot;</a>, discussed far below, necessarily takes options. But note that those are not options for the default values of attributes.)</p>

<p>Anyway, if you use <code><code>Tree::DAG_Node</code></code> as a superclass, and you add attributes that need to be initialized, what you need to do is provide an _init method that calls $this-&gt;SUPER::_init($options) to use its superclass&#39;s _init method, and then initializes the new attributes:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> _init </span><span class="operator">{</span>
    <span class="keyword">my</span><span class="operator">(</span><span class="variable">$this</span><span class="operator">,</span> <span class="variable">$options</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">[</span><span class="number">0</span><span class="operator">,</span><span class="number">1</span><span class="operator">]</span><span class="operator">;</span>
    <span class="variable">$this</span><span class="operator">-&gt;</span><span class="variable">SUPER::_init</span><span class="operator">(</span><span class="variable">$options</span><span class="operator">);</span> <span class="comment"># call my superclass's _init to</span>
      <span class="comment"># init all the attributes I'm inheriting</span>
  
    <span class="comment"># Now init /my/ new attributes:</span>
    <span class="variable">$this</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'amigos'</span><span class="operator">}</span> <span class="operator">=</span> <span class="operator">[]</span><span class="operator">;</span> <span class="comment"># for example</span>
  <span class="operator">}</span>
</code></code></pre>

<p>...or, as I prefer when I&#39;m being a neat freak:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> _init </span><span class="operator">{</span>
    <span class="keyword">my</span><span class="operator">(</span><span class="variable">$this</span><span class="operator">,</span> <span class="variable">$options</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">[</span><span class="number">0</span><span class="operator">,</span><span class="number">1</span><span class="operator">]</span><span class="operator">;</span>
    <span class="variable">$this</span><span class="operator">-&gt;</span><span class="variable">SUPER::_init</span><span class="operator">(</span><span class="variable">$options</span><span class="operator">);</span>
  
    <span class="variable">$this</span><span class="operator">-&gt;</span><span class="variable">_init_amigos</span><span class="operator">(</span><span class="variable">$options</span><span class="operator">);</span>
  <span class="operator">}</span>
  
  <span class="keyword">sub</span><span class="variable"> _init_amigos </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$this</span> <span class="operator">=</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
    <span class="comment"># Or my($this,$options) = @_[0,1]; if I'm using $options</span>
    <span class="variable">$this</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'amigos'</span><span class="operator">}</span> <span class="operator">=</span> <span class="operator">[]</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>In other words, I like to have each attribute initialized thru a method named _init_[attribute], which should expect the object as $_[0] and the the options hashref (or {} if none was given) as $_[1]. If you insist on having your _init recognize options for setting attributes, you might as well have them dealt with by the appropriate _init_[attribute] method, like this:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> _init </span><span class="operator">{</span>
    <span class="keyword">my</span><span class="operator">(</span><span class="variable">$this</span><span class="operator">,</span> <span class="variable">$options</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">[</span><span class="number">0</span><span class="operator">,</span><span class="number">1</span><span class="operator">]</span><span class="operator">;</span>
    <span class="variable">$this</span><span class="operator">-&gt;</span><span class="variable">SUPER::_init</span><span class="operator">(</span><span class="variable">$options</span><span class="operator">);</span>
  
    <span class="variable">$this</span><span class="operator">-&gt;</span><span class="variable">_init_amigos</span><span class="operator">(</span><span class="variable">$options</span><span class="operator">);</span>
  <span class="operator">}</span>
  
  <span class="keyword">sub</span><span class="variable"> _init_amigos </span><span class="operator">{</span>
    <span class="keyword">my</span><span class="operator">(</span><span class="variable">$this</span><span class="operator">,</span><span class="variable">$options</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">[</span><span class="number">0</span><span class="operator">,</span><span class="number">1</span><span class="operator">]</span><span class="operator">;</span> <span class="comment"># I need options this time</span>
    <span class="variable">$this</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'amigos'</span><span class="operator">}</span> <span class="operator">=</span> <span class="operator">[]</span><span class="operator">;</span>
    <span class="variable">$this</span><span class="operator">-&gt;</span><span class="variable">amigos</span><span class="operator">(</span><span class="variable">@</span><span class="operator">{</span><span class="variable">$options</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'amigos'</span><span class="operator">}}</span><span class="operator">)</span> <span class="keyword">if</span> <span class="variable">$options</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'amigos'</span><span class="operator">}</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>All this bookkeeping looks silly with just one new attribute in a class derived straight from <code><code>Tree::DAG_Node</code></code>, but if there&#39;s lots of new attributes running around, and if you&#39;re deriving from a class derived from a class derived from <code><code>Tree::DAG_Node</code></code>, then tidy stratification/modularization like this can keep you sane.</p>

</dd>
<dt id="the-constructor-obj-new-or-obj-new-options-">the constructor $obj-&gt;new() or $obj-&gt;new($options)</dt>
<dd>

<p>Just another way to get at the <a href="#new-hashref-">&quot;new($hashref)&quot;</a> method. This <b>does not copy</b> $obj, but merely constructs a new object of the same class as it. Saves you the bother of going $class = ref $obj; $obj2 = $class-&gt;new;</p>

</dd>
<dt id="the-method-node-_init-options-">the method $node-&gt;_init($options)</dt>
<dd>

<p>Initialize the object&#39;s attribute values. See the discussion above. Presumably this should be called only by the guts of the <a href="#new-hashref-">&quot;new($hashref)&quot;</a> constructor -- never by the end user.</p>

<p>Currently there are no documented options for putting in the $options hashref, but (in case you want to disregard the above rant) the option exists for you to use $options for something useful in a derived class.</p>

<p>Please see the source for more information.</p>

</dd>
<dt id="see-also-below-the-constructors-new_daughter-and-new_daughter_left">see also (below) the constructors &quot;new_daughter&quot; and &quot;new_daughter_left&quot;</dt>
<dd>

</dd>
</dl>

<h1 id="METHODS">METHODS</h1>

<h2 id="add_daughter-LIST-">add_daughter(LIST)</h2>

<p>An exact synonym for <a href="#add_daughters-LIST-">&quot;add_daughters(LIST)&quot;</a>.</p>

<h2 id="add_daughters-LIST-">add_daughters(LIST)</h2>

<p>This method adds the node objects in LIST to the (right) end of $mother&#39;s <i>daughter</i> list. Making a node N1 the daughter of another node N2 also means that N1&#39;s <i>mother</i> attribute is &quot;automatically&quot; set to N2; it also means that N1 stops being anything else&#39;s daughter as it becomes N2&#39;s daughter.</p>

<p>If you try to make a node its own mother, a fatal error results. If you try to take one of a a node N1&#39;s ancestors and make it also a daughter of N1, a fatal error results. A fatal error results if anything in LIST isn&#39;t a node object.</p>

<p>If you try to make N1 a daughter of N2, but it&#39;s <b>already</b> a daughter of N2, then this is a no-operation -- it won&#39;t move such nodes to the end of the list or anything; it just skips doing anything with them.</p>

<h2 id="add_daughter_left-LIST-">add_daughter_left(LIST)</h2>

<p>An exact synonym for <a href="#add_daughters_left-LIST-">&quot;add_daughters_left(LIST)&quot;</a>.</p>

<h2 id="add_daughters_left-LIST-">add_daughters_left(LIST)</h2>

<p>This method is just like <a href="#add_daughters-LIST-">&quot;add_daughters(LIST)&quot;</a>, except that it adds the node objects in LIST to the (left) beginning of $mother&#39;s daughter list, instead of the (right) end of it.</p>

<h2 id="add_left_sister-LIST-">add_left_sister(LIST)</h2>

<p>An exact synonym for <a href="#add_left_sisters-LIST-">&quot;add_left_sisters(LIST)&quot;</a>.</p>

<h2 id="add_left_sisters-LIST-">add_left_sisters(LIST)</h2>

<p>This adds the elements in LIST (in that order) as immediate left sisters of $node. In other words, given that B&#39;s mother&#39;s daughter-list is (A,B,C,D), calling B-&gt;add_left_sisters(X,Y) makes B&#39;s mother&#39;s daughter-list (A,X,Y,B,C,D).</p>

<p>If LIST is empty, this is a no-op, and returns empty-list.</p>

<p>This is basically implemented as a call to $node-&gt;replace_with(LIST, $node), and so all replace_with&#39;s limitations and caveats apply.</p>

<p>The return value of $node-&gt;add_left_sisters(LIST) is the elements of LIST that got added, as returned by replace_with -- minus the copies of $node you&#39;d get from a straight call to $node-&gt;replace_with(LIST, $node).</p>

<h2 id="add_right_sister-LIST-">add_right_sister(LIST)</h2>

<p>An exact synonym for <a href="#add_right_sisters-LIST-">&quot;add_right_sisters(LIST)&quot;</a>.</p>

<h2 id="add_right_sisters-LIST-">add_right_sisters(LIST)</h2>

<p>Just like add_left_sisters (which see), except that the the elements in LIST (in that order) as immediate <b>right</b> sisters of $node;</p>

<p>In other words, given that B&#39;s mother&#39;s daughter-list is (A,B,C,D), calling B-&gt;add_right_sisters(X,Y) makes B&#39;s mother&#39;s daughter-list (A,B,X,Y,C,D).</p>

<h2 id="address-">address()</h2>

<h2 id="address-ADDRESS-">address(ADDRESS)</h2>

<p>With the first syntax, returns the address of $node within its tree, based on its position within the tree. An address is formed by noting the path between the root and $node, and concatenating the daughter-indices of the nodes this passes thru (starting with 0 for the root, and ending with $node).</p>

<p>For example, if to get from node ROOT to node $node, you pass thru ROOT, A, B, and $node, then the address is determined as:</p>

<dl>

<dt id="o-ROOTs-my_daughter_index-is-0">o ROOT&#39;s my_daughter_index is 0</dt>
<dd>

</dd>
<dt id="o-As-my_daughter_index-is-suppose-2">o A&#39;s my_daughter_index is, suppose, 2</dt>
<dd>

<p>A is index 2 in ROOT&#39;s daughter list.</p>

</dd>
<dt id="o-Bs-my_daughter_index-is-suppose-0">o B&#39;s my_daughter_index is, suppose, 0</dt>
<dd>

<p>B is index 0 in A&#39;s daughter list.</p>

</dd>
<dt id="o-nodes-my_daughter_index-is-suppose-4">o $node&#39;s my_daughter_index is, suppose, 4</dt>
<dd>

<p>$node is index 4 in B&#39;s daughter list.</p>

</dd>
</dl>

<p>The address of the above-described $node is, therefore, &quot;0:2:0:4&quot;.</p>

<p>(As a somewhat special case, the address of the root is always &quot;0&quot;; and since addresses start from the root, all addresses start with a &quot;0&quot;.)</p>

<p>The second syntax, where you provide an address, starts from the root of the tree $anynode belongs to, and returns the node corresponding to that address. Returns undef if no node corresponds to that address. Note that this routine may be somewhat liberal in its interpretation of what can constitute an address; i.e., it accepts &quot;0.2.0.4&quot;, besides &quot;0:2:0:4&quot;.</p>

<p>Also note that the address of a node in a tree is meaningful only in that tree as currently structured.</p>

<p>(Consider how ($address1 cmp $address2) may be magically meaningful to you, if you mant to figure out what nodes are to the right of what other nodes.)</p>

<h2 id="ancestors-">ancestors()</h2>

<p>Returns the list of this node&#39;s ancestors, starting with its mother, then grandmother, and ending at the root. It does this by simply following the &#39;mother&#39; attributes up as far as it can. So if $item IS the root, this returns an empty list.</p>

<p>Consider that scalar($node-&gt;ancestors) returns the ply of this node within the tree -- 2 for a granddaughter of the root, etc., and 0 for root itself.</p>

<h2 id="attribute-">attribute()</h2>

<h2 id="attribute-SCALAR-">attribute(SCALAR)</h2>

<p>Exact synonyms for <a href="#attributes-">&quot;attributes()&quot;</a> and <a href="#attributes-SCALAR-">&quot;attributes(SCALAR)&quot;</a>.</p>

<h2 id="attributes-">attributes()</h2>

<h2 id="attributes-SCALAR-">attributes(SCALAR)</h2>

<p>In the first form, returns the value of the node object&#39;s &quot;attributes&quot; attribute. In the second form, sets it to the value of SCALAR. I intend this to be used to store a reference to a (presumably anonymous) hash the user can use to store whatever attributes he doesn&#39;t want to have to store as object attributes. In this case, you needn&#39;t ever set the value of this. (_init has already initialized it to {}.) Instead you can just do...</p>

<pre><code><code>  <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">attributes</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'foo'</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'bar'</span><span class="operator">;</span>
</code></code></pre>

<p>...to write foo =&gt; bar.</p>

<h2 id="clear_daughters-">clear_daughters()</h2>

<p>This unlinks all $mother&#39;s daughters. Returns the the list of what used to be $mother&#39;s daughters.</p>

<p>Not to be confused with <a href="#remove_daughters-LIST-">&quot;remove_daughters(LIST)&quot;</a>.</p>

<h2 id="common-LIST-">common(LIST)</h2>

<p>Returns the lowest node in the tree that is ancestor-or-self to the nodes $node and LIST.</p>

<p>If the nodes are far enough apart in the tree, the answer is just the root.</p>

<p>If the nodes aren&#39;t all in the same tree, the answer is undef.</p>

<p>As a degenerate case, if LIST is empty, returns $node.</p>

<h2 id="common_ancestor-LIST-">common_ancestor(LIST)</h2>

<p>Returns the lowest node that is ancestor to all the nodes given (in nodes $node and LIST). In other words, it answers the question: &quot;What node in the tree, as low as possible, is ancestor to the nodes given ($node and LIST)?&quot;</p>

<p>If the nodes are far enough apart, the answer is just the root -- except if any of the nodes are the root itself, in which case the answer is undef (since the root has no ancestor).</p>

<p>If the nodes aren&#39;t all in the same tree, the answer is undef.</p>

<p>As a degenerate case, if LIST is empty, returns $node&#39;s mother; that&#39;ll be undef if $node is root.</p>

<h2 id="copy_at_and_under-">copy_at_and_under()</h2>

<h2 id="copy_at_and_under-options-">copy_at_and_under($options)</h2>

<p>This returns a copy of the subtree consisting of $node and everything under it.</p>

<p>If you pass no options, copy_at_and_under pretends you&#39;ve passed {}.</p>

<p>This works by recursively building up the new tree from the leaves, duplicating nodes using $orig_node-&gt;copy($options_ref) and then linking them up into a new tree of the same shape.</p>

<p>Options you specify are passed down to calls to $node-&gt;copy.</p>

<h2 id="copy_tree-">copy_tree()</h2>

<h2 id="copy_tree-options-">copy_tree($options)</h2>

<p>This returns the root of a copy of the tree that $node is a member of. If you pass no options, copy_tree pretends you&#39;ve passed {}.</p>

<p>This method is currently implemented as just a call to $this-&gt;root-&gt;copy_at_and_under($options), but magic may be added in the future.</p>

<p>Options you specify are passed down to calls to $node-&gt;copy.</p>

<h2 id="daughters-">daughters()</h2>

<p>This returns the (possibly empty) list of daughters for $node.</p>

<h2 id="delete_tree-">delete_tree()</h2>

<p>Destroys the entire tree that $node is a member of (starting at the root), by nulling out each node-object&#39;s attributes (including, most importantly, its linkage attributes -- hopefully this is more than sufficient to eliminate all circularity in the data structure), and then moving it into the class DEADNODE.</p>

<p>Use this when you&#39;re finished with the tree in question, and want to free up its memory. (If you don&#39;t do this, it&#39;ll get freed up anyway when your program ends.)</p>

<p>If you try calling any methods on any of the node objects in the tree you&#39;ve destroyed, you&#39;ll get an error like:</p>

<pre><code><code>  Can&#39;t locate object method &quot;leaves_under&quot;
    via package &quot;DEADNODE&quot;.</code></code></pre>

<p>So if you see that, that&#39;s what you&#39;ve done wrong. (Actually, the class DEADNODE does provide one method: a no-op method &quot;delete_tree&quot;. So if you want to delete a tree, but think you may have deleted it already, it&#39;s safe to call $node-&gt;delete_tree on it (again).)</p>

<p>The <a href="#delete_tree-">&quot;delete_tree()&quot;</a> method is needed because Perl&#39;s garbage collector would never (as currently implemented) see that it was time to de-allocate the memory the tree uses -- until either you call $node-&gt;delete_tree, or until the program stops (at &quot;global destruction&quot; time, when <b>everything</b> is unallocated).</p>

<p>Incidentally, there are better ways to do garbage-collecting on a tree, ways which don&#39;t require the user to explicitly call a method like <a href="#delete_tree-">&quot;delete_tree()&quot;</a> -- they involve dummy classes, as explained at <a href="http://mox.perl.com/misc/circle-destroy.pod">http://mox.perl.com/misc/circle-destroy.pod</a></p>

<p>However, introducing a dummy class concept into <code><code>Tree::DAG_Node</code></code> would be rather a distraction. If you want to do this with your derived classes, via a DESTROY in a dummy class (or in a tree-metainformation class, maybe), then feel free to.</p>

<p>The only case where I can imagine <a href="#delete_tree-">&quot;delete_tree()&quot;</a> failing to totally void the tree, is if you use the hashref in the &quot;attributes&quot; attribute to store (presumably among other things) references to other nodes&#39; &quot;attributes&quot; hashrefs -- which 1) is maybe a bit odd, and 2) is your problem, because it&#39;s your hash structure that&#39;s circular, not the tree&#39;s. Anyway, consider:</p>

<pre><code><code>      <span class="comment"># null out all my "attributes" hashes</span>
      <span class="variable">$anywhere</span><span class="operator">-&gt;</span><span class="variable">root</span><span class="operator">-&gt;</span><span class="variable">walk_down</span><span class="operator">(</span><span class="operator">{</span>
        <span class="string">'callback'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
          <span class="variable">$hr</span> <span class="operator">=</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">-&gt;</span><span class="variable">attributes</span><span class="operator">;</span> <span class="variable">%$hr</span> <span class="operator">=</span> <span class="operator">();</span> <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
        <span class="operator">}</span>
      <span class="operator">}</span><span class="operator">);</span>
      <span class="comment"># And then:</span>
      <span class="variable">$anywhere</span><span class="operator">-&gt;</span><span class="variable">delete_tree</span><span class="operator">;</span>
</code></code></pre>

<p>(I suppose <a href="#delete_tree-">&quot;delete_tree()&quot;</a> is a &quot;destructor&quot;, or as close as you can meaningfully come for a circularity-rich data structure in Perl.)</p>

<p>See also <a href="#WHEN-AND-HOW-TO-DESTROY-THE-TREE">&quot;WHEN AND HOW TO DESTROY THE TREE&quot;</a>.</p>

<h2 id="depth_under-">depth_under()</h2>

<p>Returns an integer representing the number of branches between this $node and the most distant leaf under it. (In other words, this returns the ply of subtree starting of $node. Consider scalar($it-&gt;ancestors) if you want the ply of a node within the whole tree.)</p>

<h2 id="descendants-">descendants()</h2>

<p>Returns a list consisting of all the descendants of $node. Returns empty-list if $node is a terminal_node.</p>

<p>(Note that it&#39;s spelled &quot;descendants&quot;, not &quot;descendents&quot;.)</p>

<h2 id="draw_ascii_tree-options-">draw_ascii_tree([$options])</h2>

<p>Here, the [] refer to an optional parameter.</p>

<p>Returns an arrayref of lines suitable for printing.</p>

<p>Draws a nice ASCII-art representation of the tree structure.</p>

<p>The tree looks like:</p>

<pre><code><code>                     |
                  &lt;Root&gt;
           /-------+-----+---+---\
           |       |     |   |   |
          &lt;I&gt;     &lt;H&gt;   &lt;D&gt; &lt;E&gt; &lt;B&gt;
         /---\   /---\   |   |   |
         |   |   |   |  &lt;F&gt; &lt;F&gt; &lt;C&gt;
        &lt;J&gt; &lt;J&gt; &lt;J&gt; &lt;J&gt;  |   |
         |   |   |   |  &lt;G&gt; &lt;G&gt;
        &lt;K&gt; &lt;L&gt; &lt;K&gt; &lt;L&gt;
             |       |
            &lt;M&gt;     &lt;M&gt;
             |       |
            &lt;N&gt;     &lt;N&gt;
             |       |
            &lt;O&gt;     &lt;O&gt;</code></code></pre>

<p>See scripts/cut.and.paste.subtrees.pl.</p>

<p>Example usage:</p>

<pre><code><code>  <span class="keyword">print</span> <span class="keyword">map</span><span class="operator">(</span><span class="string">"</span><span class="variable">$_</span><span class="string">\n"</span><span class="operator">,</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">$tree</span><span class="operator">-&gt;</span><span class="variable">draw_ascii_tree</span><span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p><i>draw_ascii_tree()</i> takes parameters you set in the $options hashref:</p>

<dl>

<dt id="o-h_compact">o h_compact</dt>
<dd>

<p>Takes 0 or 1. Sets the extent to which <i>draw_ascii_tree()</i> tries to save horizontal space.</p>

<p>If I think of a better scrunching algorithm, there&#39;ll be a &quot;2&quot; setting for this.</p>

<p>Default: 1.</p>

</dd>
<dt id="o-h_spacing">o h_spacing</dt>
<dd>

<p>Takes a number 0 or greater. Sets the number of spaces inserted horizontally between nodes (and groups of nodes) in a tree.</p>

<p>Default: 1.</p>

</dd>
<dt id="o-no_name">o no_name</dt>
<dd>

<p>If true, <i>draw_ascii_tree()</i> doesn&#39;t print the name of the node; it simply prints a &quot;*&quot;.</p>

<p>Default: 0 (i.e., print the node name.)</p>

</dd>
<dt id="o-v_compact">o v_compact</dt>
<dd>

<p>Takes a number 0, 1, or 2. Sets the degree to which <i>draw_ascii_tree()</i> tries to save vertical space. Defaults to 1.</p>

</dd>
</dl>

<p>The code occasionally returns trees that are a bit cock-eyed in parts; if anyone can suggest a better drawing algorithm, I&#39;d be appreciative.</p>

<p>See also <a href="#tree2string-options-some_tree-">&quot;tree2string([$options], [$some_tree])&quot;</a>.</p>

<h2 id="dump_names-options-">dump_names($options)</h2>

<p>Returns an array.</p>

<p>Dumps, as an indented list, the names of the nodes starting at $node, and continuing under it. Options are:</p>

<dl>

<dt id="o-_depth----A-nonnegative-number">o _depth -- A nonnegative number</dt>
<dd>

<p>Indicating the depth to consider $node as being at (and so the generation under that is that plus one, etc.). You may choose to use set _depth =&gt; scalar($node-&gt;ancestors).</p>

<p>Default: 0.</p>

</dd>
<dt id="o-tick----a-string-to-preface-each-entry-with">o tick -- a string to preface each entry with</dt>
<dd>

<p>This string goes between the indenting-spacing and the node&#39;s name. You may prefer &quot;*&quot; or &quot;-&gt; &quot; or someting.</p>

<p>Default: &#39;&#39;.</p>

</dd>
<dt id="o-indent----the-string-used-to-indent-with">o indent -- the string used to indent with</dt>
<dd>

<p>Another sane value might be &#39;. &#39; (period, space). Setting it to empty-string suppresses indenting.</p>

<p>Default: &#39; &#39; x 2.</p>

</dd>
</dl>

<p>The output is not printed, but is returned as a list, where each item is a line, with a &quot;\n&quot; at the end.</p>

<p>Note: Names are converted to a printable form using the undocumented function _dump_quote().</p>

<h2 id="format_node-options-node-">format_node([$options], [$node])</h2>

<p>Here, [] represent optional parameters.</p>

<p>Returns a string consisting of the node&#39;s name and, optionally, it&#39;s attributes.</p>

<p>Possible keys in the $options hashref:</p>

<dl>

<dt id="o-no_attributes">o no_attributes</dt>
<dd>

<p>If given a true value, the node&#39;s attributes are not included in the string returned.</p>

<p>Default: 0 (include attributes).</p>

</dd>
</dl>

<p>Calls <a href="#hashref2string-hashref-">&quot;hashref2string($hashref)&quot;</a>.</p>

<p>Called by <a href="#node2string-options-node-">&quot;node2string([$options], [$node])&quot;</a>.</p>

<p>You would not normally call this method.</p>

<p>If you don&#39;t wish to supply options, use format_node({}, $node).</p>

<h2 id="generation-">generation()</h2>

<p>Returns a list of all nodes (going left-to-right) that are in $node&#39;s generation -- i.e., that are the some number of nodes down from the root. $root-&gt;generation() is just $root.</p>

<p>Of course, $node is always in its own generation.</p>

<h2 id="generation_under-node-">generation_under($node)</h2>

<p>Like <a href="#generation-">&quot;generation()&quot;</a>, but returns only the nodes in $node&#39;s generation that are also descendants of $node -- in other words,</p>

<pre><code><code>    <span class="variable">@us</span> <span class="operator">=</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">generation_under</span><span class="operator">(</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">mother</span><span class="operator">-&gt;</span><span class="variable">mother</span> <span class="operator">);</span>
</code></code></pre>

<p>is all $node&#39;s first cousins (to borrow yet more kinship terminology) -- assuming $node does indeed have a grandmother. Actually &quot;cousins&quot; isn&#39;t quite an apt word, because <code><code>@us</code></code> ends up including $node&#39;s siblings and $node.</p>

<p>Actually, <a href="#generation_under-node-">&quot;generation_under($node)&quot;</a> is just an alias to <a href="#generation-">&quot;generation()&quot;</a>, but I figure that this:</p>

<pre><code><code>   <span class="variable">@us</span> <span class="operator">=</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">generation_under</span><span class="operator">(</span><span class="variable">$way_upline</span><span class="operator">);</span>
</code></code></pre>

<p>is a bit more readable than this:</p>

<pre><code><code>   <span class="variable">@us</span> <span class="operator">=</span> <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">generation</span><span class="operator">(</span><span class="variable">$way_upline</span><span class="operator">);</span>
</code></code></pre>

<p>But it&#39;s up to you.</p>

<p>$node-&gt;generation_under($node) returns just $node.</p>

<p>If you call $node-&gt;generation_under($node) but NODE2 is not $node or an ancestor of $node, it behaves as if you called just $node-&gt;generation().</p>

<p>head2 hashref2string($hashref)</p>

<p>Returns the given hashref as a string.</p>

<p>Called by <a href="#format_node-options-node-">&quot;format_node([$options], [$node])&quot;</a>.</p>

<h2 id="is_daughter_of-node2-">is_daughter_of($node2)</h2>

<p>Returns true iff $node is a daughter of $node2. Currently implemented as just a test of ($it-&gt;mother eq $node2).</p>

<h2 id="is_node-">is_node()</h2>

<p>This always returns true. More pertinently, $object-&gt;can(&#39;is_node&#39;) is true (regardless of what <a href="#is_node-">&quot;is_node()&quot;</a> would do if called) for objects belonging to this class or for any class derived from it.</p>

<h2 id="is_root-">is_root()</h2>

<p>Returns 1 if the caller is the root, and 0 if it is not.</p>

<h2 id="leaves_under-">leaves_under()</h2>

<p>Returns a list (going left-to-right) of all the leaf nodes under $node. (&quot;Leaf nodes&quot; are also called &quot;terminal nodes&quot; -- i.e., nodes that have no daughters.) Returns $node in the degenerate case of $node being a leaf itself.</p>

<h2 id="left_sister-">left_sister()</h2>

<p>Returns the node that&#39;s the immediate left sister of $node. If $node is the leftmost (or only) daughter of its mother (or has no mother), then this returns undef.</p>

<p>See also <a href="#add_left_sisters-LIST-">&quot;add_left_sisters(LIST)&quot;</a> and <a href="#add_right_sisters-LIST-">&quot;add_right_sisters(LIST)&quot;</a>.</p>

<h2 id="left_sisters-">left_sisters()</h2>

<p>Returns a list of nodes that&#39;re sisters to the left of $node. If $node is the leftmost (or only) daughter of its mother (or has no mother), then this returns an empty list.</p>

<p>See also <a href="#add_left_sisters-LIST-">&quot;add_left_sisters(LIST)&quot;</a> and <a href="#add_right_sisters-LIST-">&quot;add_right_sisters(LIST)&quot;</a>.</p>

<h2 id="lol_to_tree-lol-">lol_to_tree($lol)</h2>

<p>This must be called as a class method.</p>

<p>Converts something like bracket-notation for &quot;Chomsky trees&quot; (or rather, the closest you can come with Perl list-of-lists(-of-lists(-of-lists))) into a tree structure. Returns the root of the tree converted.</p>

<p>The conversion rules are that: 1) if the last (possibly the only) item in a given list is a scalar, then that is used as the &quot;name&quot; attribute for the node based on this list. 2) All other items in the list represent daughter nodes of the current node -- recursively so, if they are list references; otherwise, (non-terminal) scalars are considered to denote nodes with that name. So [&#39;Foo&#39;, &#39;Bar&#39;, &#39;N&#39;] is an alternate way to represent [[&#39;Foo&#39;], [&#39;Bar&#39;], &#39;N&#39;].</p>

<p>An example will illustrate:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Tree::DAG_Node</span><span class="operator">;</span>
  <span class="variable">$lol</span> <span class="operator">=</span>
    <span class="operator">[</span>
      <span class="operator">[</span>
        <span class="operator">[</span> <span class="operator">[</span> <span class="string">'Det:The'</span> <span class="operator">]</span><span class="operator">,</span>
          <span class="operator">[</span> <span class="operator">[</span> <span class="string">'dog'</span> <span class="operator">]</span><span class="operator">,</span> <span class="string">'N'</span><span class="operator">]</span><span class="operator">,</span> <span class="string">'NP'</span><span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span> <span class="string">'/with rabies\\'</span><span class="operator">,</span> <span class="string">'PP'</span><span class="operator">]</span><span class="operator">,</span>
        <span class="string">'NP'</span>
      <span class="operator">]</span><span class="operator">,</span>
      <span class="operator">[</span> <span class="string">'died'</span><span class="operator">,</span> <span class="string">'VP'</span><span class="operator">]</span><span class="operator">,</span>
      <span class="string">'S'</span>
    <span class="operator">]</span><span class="operator">;</span>
   <span class="variable">$tree</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">lol_to_tree</span><span class="operator">(</span><span class="variable">$lol</span><span class="operator">);</span>
   <span class="variable">$diagram</span> <span class="operator">=</span> <span class="variable">$tree</span><span class="operator">-&gt;</span><span class="variable">draw_ascii_tree</span><span class="operator">;</span>
   <span class="keyword">print</span> <span class="keyword">map</span> <span class="string">"</span><span class="variable">$_</span><span class="string">\n"</span><span class="operator">,</span> <span class="variable">@$diagram</span><span class="operator">;</span>
</code></code></pre>

<p>...returns this tree:</p>

<pre><code><code>                   |
                  &lt;S&gt;
                   |
                /------------------\
                |                  |
              &lt;NP&gt;                &lt;VP&gt;
                |                  |
        /---------------\        &lt;died&gt;
        |               |
      &lt;NP&gt;            &lt;PP&gt;
        |               |
     /-------\   &lt;/with rabies\&gt;
     |       |
 &lt;Det:The&gt;  &lt;N&gt;
             |
           &lt;dog&gt;</code></code></pre>

<p>By the way (and this rather follows from the above rules), when denoting a LoL tree consisting of just one node, this:</p>

<pre><code><code>  <span class="variable">$tree</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">lol_to_tree</span><span class="operator">(</span> <span class="string">'Lonely'</span> <span class="operator">);</span>
</code></code></pre>

<p>is okay, although it&#39;d probably occur to you to denote it only as:</p>

<pre><code><code>  <span class="variable">$tree</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">lol_to_tree</span><span class="operator">(</span> <span class="operator">[</span><span class="string">'Lonely'</span><span class="operator">]</span> <span class="operator">);</span>
</code></code></pre>

<p>which is of course fine, too.</p>

<h2 id="mother-">mother()</h2>

<p>This returns what node is $node&#39;s mother. This is undef if $node has no mother -- i.e., if it is a root.</p>

<p>See also <a href="#is_root-">&quot;is_root()&quot;</a> and <a href="#root-">&quot;root()&quot;</a>.</p>

<h2 id="my_daughter_index-">my_daughter_index()</h2>

<p>Returns what index this daughter is, in its mother&#39;s <code><code>daughter</code></code> list. In other words, if $node is ($node-&gt;mother-&gt;daughters)[3], then $node-&gt;my_daughter_index returns 3.</p>

<p>As a special case, returns 0 if $node has no mother.</p>

<h2 id="name-">name()</h2>

<h2 id="name-SCALAR-">name(SCALAR)</h2>

<p>In the first form, returns the value of the node object&#39;s &quot;name&quot; attribute. In the second form, sets it to the value of SCALAR.</p>

<h2 id="new-hashref-">new($hashref)</h2>

<p>These options are supported in $hashref:</p>

<dl>

<dt id="o-attributes-A-hashref-of-attributes">o attributes =&gt; A hashref of attributes</dt>
<dd>

</dd>
<dt id="o-daughters-An-arrayref-of-nodes">o daughters =&gt; An arrayref of nodes</dt>
<dd>

</dd>
<dt id="o-mother-A-node">o mother =&gt; A node</dt>
<dd>

</dd>
<dt id="o-name-A-string">o name =&gt; A string</dt>
<dd>

</dd>
</dl>

<p>See also <a href="#MAIN-CONSTRUCTOR-AND-INITIALIZER">&quot;MAIN CONSTRUCTOR, AND INITIALIZER&quot;</a> for a long discussion on object creation.</p>

<h2 id="new_daughter-">new_daughter()</h2>

<h2 id="new_daughter-options-">new_daughter($options)</h2>

<p>This <b>constructs</b> a <b>new</b> node (of the same class as $mother), and adds it to the (right) end of the daughter list of $mother. This is essentially the same as going</p>

<pre><code><code>      <span class="variable">$daughter</span> <span class="operator">=</span> <span class="variable">$mother</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
      <span class="variable">$mother</span><span class="operator">-&gt;</span><span class="variable">add_daughter</span><span class="operator">(</span><span class="variable">$daughter</span><span class="operator">);</span>
</code></code></pre>

<p>but is rather more efficient because (since $daughter is guaranteed new and isn&#39;t linked to/from anything), it doesn&#39;t have to check that $daughter isn&#39;t an ancestor of $mother, isn&#39;t already daughter to a mother it needs to be unlinked from, isn&#39;t already in $mother&#39;s daughter list, etc.</p>

<p>As you&#39;d expect for a constructor, it returns the node-object created.</p>

<p># Note that if you radically change &#39;mother&#39;/&#39;daughters&#39; bookkeeping, # you may have to change this routine, since it&#39;s one of the places # that directly writes to &#39;daughters&#39; and &#39;mother&#39;.</p>

<h2 id="new_daughter_left-">new_daughter_left()</h2>

<h2 id="new_daughter_left-options-">new_daughter_left($options)</h2>

<p>This is just like $mother-&gt;new_daughter, but adds the new daughter to the left (start) of $mother&#39;s daughter list.</p>

<p># Note that if you radically change &#39;mother&#39;/&#39;daughters&#39; bookkeeping, # you may have to change this routine, since it&#39;s one of the places # that directly writes to &#39;daughters&#39; and &#39;mother&#39;.</p>

<h2 id="node2string-options-t-vert_dashes-">node2string($options, $t, $vert_dashes)</h2>

<p>Returns a string of the node&#39;s name and attributes, with a leading indent, suitable for printing.</p>

<p>Possible keys in the $options hashref:</p>

<dl>

<dt id="o-no_attributes1">o no_attributes</dt>
<dd>

<p>If given a true value, the node&#39;s attributes are not included in the string returned.</p>

<p>Default: 0 (include attributes).</p>

</dd>
</dl>

<p>Calls <a href="#format_node-options-node-">&quot;format_node([$options], [$node])&quot;</a>.</p>

<p>Called by <a href="#tree2string-options-some_tree-">&quot;tree2string([$options], [$some_tree])&quot;</a>.</p>

<h2 id="random_network-options-">random_network($options)</h2>

<p>This method can be called as a class method or as an object method.</p>

<p>In the first case, constructs a randomly arranged network under a new node, and returns the root node of that tree. In the latter case, constructs the network under $node.</p>

<p>Currently, this is implemented a bit half-heartedly, and half-wittedly. I basically needed to make up random-looking networks to stress-test the various tree-dumper methods, and so wrote this. If you actually want to rely on this for any application more serious than that, I suggest examining the source code and seeing if this does really what you need (say, in reliability of randomness); and feel totally free to suggest changes to me (especially in the form of &quot;I rewrote <a href="#random_network-options-">&quot;random_network($options)&quot;</a>, here&#39;s the code...&quot;)</p>

<p>It takes four options:</p>

<dl>

<dt id="o-max_node_count----maximum-number-of-nodes-this-tree-will-be-allowed-to-have-counting-the-root-">o max_node_count -- maximum number of nodes this tree will be allowed to have (counting the root)</dt>
<dd>

<p>Default: 25.</p>

</dd>
<dt id="o-min_depth----minimum-depth-for-the-tree">o min_depth -- minimum depth for the tree</dt>
<dd>

<p>Leaves can be generated only after this depth is reached, so the tree will be at least this deep -- unless max_node_count is hit first.</p>

<p>Default: 2.</p>

</dd>
<dt id="o-max_depth----maximum-depth-for-the-tree">o max_depth -- maximum depth for the tree</dt>
<dd>

<p>The tree will not be deeper than this.</p>

<p>Default: 3 plus min_depth.</p>

</dd>
<dt id="o-max_children----maximum-number-of-children-any-mother-in-the-tree-can-have.">o max_children -- maximum number of children any mother in the tree can have.</dt>
<dd>

<p>Default: 4.</p>

</dd>
</dl>

<h2 id="remove_daughter-LIST-">remove_daughter(LIST)</h2>

<p>An exact synonym for <a href="#remove_daughters-LIST-">&quot;remove_daughters(LIST)&quot;</a>.</p>

<h2 id="remove_daughters-LIST-">remove_daughters(LIST)</h2>

<p>This removes the nodes listed in LIST from $mother&#39;s daughter list. This is a no-operation if LIST is empty. If there are things in LIST that aren&#39;t a current daughter of $mother, they are ignored.</p>

<p>Not to be confused with <a href="#clear_daughters-">&quot;clear_daughters()&quot;</a>.</p>

<h2 id="replace_with-LIST-">replace_with(LIST)</h2>

<p>This replaces $node in its mother&#39;s daughter list, by unlinking $node and replacing it with the items in LIST. This returns a list consisting of $node followed by LIST, i.e., the nodes that replaced it.</p>

<p>LIST can include $node itself (presumably at most once). LIST can also be empty-list. However, if any items in LIST are sisters to $node, they are ignored, and are not in the copy of LIST passed as the return value.</p>

<p>As you might expect for any linking operation, the items in LIST cannot be $node&#39;s mother, or any ancestor to it; and items in LIST are, of course, unlinked from their mothers (if they have any) as they&#39;re linked to $node&#39;s mother.</p>

<p>(In the special (and bizarre) case where $node is root, this simply calls $this-&gt;unlink_from_mother on all the items in LIST, making them roots of their own trees.)</p>

<p>Note that the daughter-list of $node is not necessarily affected; nor are the daughter-lists of the items in LIST. I mention this in case you think replace_with switches one node for another, with respect to its mother list <b>and</b> its daughter list, leaving the rest of the tree unchanged. If that&#39;s what you want, replacing $Old with $New, then you want:</p>

<pre><code><code>  <span class="variable">$New</span><span class="operator">-&gt;</span><span class="variable">set_daughters</span><span class="operator">(</span><span class="variable">$Old</span><span class="operator">-&gt;</span><span class="variable">clear_daughters</span><span class="operator">);</span>
  <span class="variable">$Old</span><span class="operator">-&gt;</span><span class="variable">replace_with</span><span class="operator">(</span><span class="variable">$New</span><span class="operator">);</span>
</code></code></pre>

<p>(I can&#39;t say $node&#39;s and LIST-items&#39; daughter lists are <b>never</b> affected my replace_with -- they can be affected in this case:</p>

<pre><code><code>  <span class="variable">$N1</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">daughters</span><span class="operator">)</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span> <span class="comment"># first daughter of $node</span>
  <span class="variable">$N2</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$N1</span><span class="operator">-&gt;</span><span class="variable">daughters</span><span class="operator">)</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>   <span class="comment"># first daughter of $N1;</span>
  <span class="variable">$N3</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">random_network</span><span class="operator">;</span> <span class="comment"># or whatever</span>
  <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">replace_with</span><span class="operator">(</span><span class="variable">$N1</span><span class="operator">,</span> <span class="variable">$N2</span><span class="operator">,</span> <span class="variable">$N3</span><span class="operator">);</span>
</code></code></pre>

<p>As a side affect of attaching $N1 and $N2 to $node&#39;s mother, they&#39;re unlinked from their parents ($node, and $N1, replectively). But N3&#39;s daughter list is unaffected.</p>

<p>In other words, this method does what it has to, as you&#39;d expect it to.</p>

<h2 id="replace_with_daughters-">replace_with_daughters()</h2>

<p>This replaces $node in its mother&#39;s daughter list, by unlinking $node and replacing it with its daughters. In other words, $node becomes motherless and daughterless as its daughters move up and take its place. This returns a list consisting of $node followed by the nodes that were its daughters.</p>

<p>In the special (and bizarre) case where $node is root, this simply unlinks its daughters from it, making them roots of their own trees.</p>

<p>Effectively the same as $node-&gt;replace_with($node-&gt;daughters), but more efficient, since less checking has to be done. (And I also think $node-&gt;replace_with_daughters is a more common operation in tree-wrangling than $node-&gt;replace_with(LIST), so deserves a named method of its own, but that&#39;s just me.)</p>

<p># Note that if you radically change &#39;mother&#39;/&#39;daughters&#39; bookkeeping, # you may have to change this routine, since it&#39;s one of the places # that directly writes to &#39;daughters&#39; and &#39;mother&#39;.</p>

<h2 id="right_sister-">right_sister()</h2>

<p>Returns the node that&#39;s the immediate right sister of $node. If $node is the rightmost (or only) daughter of its mother (or has no mother), then this returns undef.</p>

<p>See also <a href="#add_left_sisters-LIST-">&quot;add_left_sisters(LIST)&quot;</a> and <a href="#add_right_sisters-LIST-">&quot;add_right_sisters(LIST)&quot;</a>.</p>

<h2 id="right_sisters-">right_sisters()</h2>

<p>Returns a list of nodes that&#39;re sisters to the right of $node. If $node is the rightmost (or only) daughter of its mother (or has no mother), then this returns an empty list.</p>

<p>See also <a href="#add_left_sisters-LIST-">&quot;add_left_sisters(LIST)&quot;</a> and <a href="#add_right_sisters-LIST-">&quot;add_right_sisters(LIST)&quot;</a>.</p>

<h2 id="root-">root()</h2>

<p>Returns the root of whatever tree $node is a member of. If $node is the root, then the result is $node itself.</p>

<p>Not to be confused with <a href="#is_root-">&quot;is_root()&quot;</a>.</p>

<h2 id="self_and_descendants-">self_and_descendants()</h2>

<p>Returns a list consisting of itself (as element 0) and all the descendants of $node. Returns just itself if $node is a terminal_node.</p>

<p>(Note that it&#39;s spelled &quot;descendants&quot;, not &quot;descendents&quot;.)</p>

<h2 id="self_and_sisters-">self_and_sisters()</h2>

<p>Returns a list of all nodes (going left-to-right) that have the same mother as $node -- including $node itself. This is just like $node-&gt;mother-&gt;daughters, except that that fails where $node is root, whereas $root-&gt;self_and_siblings, as a special case, returns $root.</p>

<p>(Contrary to how you may interpret how this method is named, &quot;self&quot; is not (necessarily) the first element of what&#39;s returned.)</p>

<h2 id="set_daughters-LIST-">set_daughters(LIST)</h2>

<p>This unlinks all $mother&#39;s daughters, and replaces them with the daughters in LIST.</p>

<p>Currently implemented as just $mother-&gt;clear_daughters followed by $mother-&gt;add_daughters(LIST).</p>

<h2 id="simple_lol_to_tree-simple_lol-">simple_lol_to_tree($simple_lol)</h2>

<p>This must be called as a class method.</p>

<p>This is like lol_to_tree, except that rule 1 doesn&#39;t apply -- i.e., all scalars (or really, anything not a listref) in the LoL-structure end up as named terminal nodes, and only terminal nodes get names (and, of course, that name comes from that scalar value). This method is useful for making things like expression trees, or at least starting them off. Consider that this:</p>

<pre><code><code>    <span class="variable">$tree</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">simple_lol_to_tree</span><span class="operator">(</span>
      <span class="operator">[</span> <span class="string">'foo'</span><span class="operator">,</span> <span class="operator">[</span><span class="string">'bar'</span><span class="operator">,</span> <span class="operator">[</span><span class="string">'baz'</span><span class="operator">]</span><span class="operator">,</span> <span class="string">'quux'</span><span class="operator">]</span><span class="operator">,</span> <span class="string">'zaz'</span><span class="operator">,</span> <span class="string">'pati'</span> <span class="operator">]</span>
    <span class="operator">);</span>
</code></code></pre>

<p>converts from something like a Lispish or Iconish tree, if you pretend the brackets are parentheses.</p>

<p>Note that there is a (possibly surprising) degenerate case of what I&#39;m calling a &quot;simple-LoL&quot;, and it&#39;s like this:</p>

<pre><code><code>  <span class="variable">$tree</span> <span class="operator">=</span> <span class="variable">Tree::DAG_Node</span><span class="operator">-&gt;</span><span class="variable">simple_lol_to_tree</span><span class="operator">(</span><span class="string">'Lonely'</span><span class="operator">);</span>
</code></code></pre>

<p>This is the (only) way you can specify a tree consisting of only a single node, which here gets the name &#39;Lonely&#39;.</p>

<h2 id="sisters-">sisters()</h2>

<p>Returns a list of all nodes (going left-to-right) that have the same mother as $node -- <b>not including</b> $node itself. If $node is root, this returns empty-list.</p>

<h2 id="tree_to_lol-">tree_to_lol()</h2>

<p>Returns that tree (starting at $node) represented as a LoL, like what $lol, above, holds. (This is as opposed to <a href="#tree_to_lol_notation-options-">&quot;tree_to_lol_notation($options)&quot;</a>, which returns the viewable code like what gets evaluated and stored in $lol, above.)</p>

<p>Lord only knows what you use this for -- maybe for feeding to Data::Dumper, in case <a href="#tree_to_lol_notation-options-">&quot;tree_to_lol_notation($options)&quot;</a> doesn&#39;t do just what you want?</p>

<h2 id="tree_to_lol_notation-options-">tree_to_lol_notation($options)</h2>

<p>Dumps a tree (starting at $node) as the sort of LoL-like bracket notation you see in the above example code. Returns just one big block of text. The only option is &quot;multiline&quot; -- if true, it dumps the text as the sort of indented structure as seen above; if false (and it defaults to false), dumps it all on one line (with no indenting, of course).</p>

<p>For example, starting with the tree from the above example, this:</p>

<pre><code><code>  <span class="keyword">print</span> <span class="variable">$tree</span><span class="operator">-&gt;</span><span class="variable">tree_to_lol_notation</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</code></code></pre>

<p>prints the following (which I&#39;ve broken over two lines for sake of printablitity of documentation):</p>

<pre><code><code>  [[[[&#39;Det:The&#39;], [[&#39;dog&#39;], &#39;N&#39;], &#39;NP&#39;], [[&quot;/with rabies\x5c&quot;],
  &#39;PP&#39;], &#39;NP&#39;], [[&#39;died&#39;], &#39;VP&#39;], &#39;S&#39;],</code></code></pre>

<p>Doing this:</p>

<pre><code><code>  <span class="keyword">print</span> <span class="variable">$tree</span><span class="operator">-&gt;</span><span class="variable">tree_to_lol_notation</span><span class="operator">(</span><span class="operator">{</span> <span class="string">multiline</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>prints the same content, just spread over many lines, and prettily indented.</p>

<p>Note: Names are converted to a printable form using the undocumented function _dump_quote().</p>

<h2 id="tree_to_simple_lol-">tree_to_simple_lol()</h2>

<p>Returns that tree (starting at $node) represented as a simple-LoL -- i.e., one where non-terminal nodes are represented as listrefs, and terminal nodes are gotten from the contents of those nodes&#39; &quot;name&#39; attributes.</p>

<p>Note that in the case of $node being terminal, what you get back is the same as $node-&gt;name.</p>

<p>Compare to tree_to_simple_lol_notation.</p>

<h2 id="tree_to_simple_lol_notation-options-">tree_to_simple_lol_notation($options)</h2>

<p>A simple-LoL version of tree_to_lol_notation (which see); takes the same options.</p>

<p>Note: Names are converted to a printable form using the undocumented function _dump_quote().</p>

<h2 id="tree2string-options-some_tree-">tree2string([$options], [$some_tree])</h2>

<p>Here, the [] represent optional parameters.</p>

<p>Returns an arrayref of lines, suitable for printing.</p>

<p>Draws a nice ASCII-art representation of the tree structure.</p>

<p>The tree looks like:</p>

<pre><code><code>        <span class="variable">Root</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "0"}</span>
           <span class="operator">|---</span><span class="variable">I</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "1"}</span>
           <span class="operator">|</span>   <span class="operator">|---</span><span class="variable">J</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "3"}</span>
           <span class="operator">|</span>   <span class="operator">|</span>   <span class="operator">|---</span><span class="variable">K</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "3"}</span>
           <span class="operator">|</span>   <span class="operator">|---</span><span class="variable">J</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "4"}</span>
           <span class="operator">|</span>       <span class="operator">|---</span><span class="variable">L</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "5"}</span>
           <span class="operator">|</span>           <span class="operator">|--</span><span class="keyword">-M</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "5"}</span>
           <span class="operator">|</span>               <span class="operator">|---</span><span class="variable">N</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "5"}</span>
           <span class="operator">|</span>                   <span class="operator">|--</span><span class="keyword">-O</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "5"}</span>
           <span class="operator">|---</span><span class="variable">H</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "2"}</span>
           <span class="operator">|</span>   <span class="operator">|---</span><span class="variable">J</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "3"}</span>
           <span class="operator">|</span>   <span class="operator">|</span>   <span class="operator">|---</span><span class="variable">K</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "3"}</span>
           <span class="operator">|</span>   <span class="operator">|---</span><span class="variable">J</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "4"}</span>
           <span class="operator">|</span>       <span class="operator">|---</span><span class="variable">L</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "5"}</span>
           <span class="operator">|</span>           <span class="operator">|--</span><span class="keyword">-M</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "5"}</span>
           <span class="operator">|</span>               <span class="operator">|---</span><span class="variable">N</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "5"}</span>
           <span class="operator">|</span>                   <span class="operator">|--</span><span class="keyword">-O</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "5"}</span>
           <span class="operator">|---</span><span class="variable">D</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "6"}</span>
           <span class="operator">|</span>   <span class="operator">|---</span><span class="variable">F</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "8"}</span>
           <span class="operator">|</span>       <span class="operator">|---</span><span class="variable">G</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "8"}</span>
           <span class="operator">|---</span><span class="variable">E</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "7"}</span>
           <span class="operator">|</span>   <span class="operator">|---</span><span class="variable">F</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "8"}</span>
           <span class="operator">|</span>       <span class="operator">|---</span><span class="variable">G</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "8"}</span>
           <span class="operator">|--</span><span class="keyword">-B</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "9"}</span>
               <span class="operator">|--</span><span class="keyword">-C</span><span class="operator">.</span> <span class="variable">Attributes</span><span class="operator">:</span> <span class="operator">{</span><span class="comment"># =&gt; "9"}</span>
</code></code></pre>

<p>Or, without attributes:</p>

<pre><code><code>        Root
           |---I
           |   |---J
           |   |   |---K
           |   |---J
           |       |---L
           |           |---M
           |               |---N
           |                   |---O
           |---H
           |   |---J
           |   |   |---K
           |   |---J
           |       |---L
           |           |---M
           |               |---N
           |                   |---O
           |---D
           |   |---F
           |       |---G
           |---E
           |   |---F
           |       |---G
           |---B
               |---C</code></code></pre>

<p>See scripts/cut.and.paste.subtrees.pl.</p>

<p>Example usage:</p>

<pre><code><code>  <span class="keyword">print</span> <span class="keyword">map</span><span class="operator">(</span><span class="string">"</span><span class="variable">$_</span><span class="string">\n"</span><span class="operator">,</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">$tree</span><span class="operator">-&gt;</span><span class="variable">tree2string</span><span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>Can be called with $some_tree set to any $node, and will print the tree assuming $node is the root.</p>

<p>If you don&#39;t wish to supply options, use tree2string({}, $node).</p>

<p>Possible keys in the $options hashref (which defaults to {}):</p>

<dl>

<dt id="o-no_attributes2">o no_attributes</dt>
<dd>

<p>If given a true value, the node&#39;s attributes are not included in the string returned.</p>

<p>Default: 0 (include attributes).</p>

</dd>
</dl>

<p>Calls <a href="#node2string-options-t-vert_dashes-">&quot;node2string($options, $t, $vert_dashes)&quot;</a>.</p>

<p>See also <a href="#draw_ascii_tree-options-">&quot;draw_ascii_tree([$options])&quot;</a>.</p>

<h2 id="unlink_from_mother-">unlink_from_mother()</h2>

<p>This removes node from the daughter list of its mother. If it has no mother, this is a no-operation.</p>

<p>Returns the mother unlinked from (if any).</p>

<h2 id="walk_down-options-">walk_down($options)</h2>

<p>Performs a depth-first traversal of the structure at and under $node. What it does at each node depends on the value of the options hashref, which you must provide. There are three options, &quot;callback&quot; and &quot;callbackback&quot; (at least one of which must be defined, as a sub reference), and &quot;_depth&quot;.</p>

<p>This is what <i>walk_down()</i> does, in pseudocode form:</p>

<dl>

<dt id="o-Starting-pount">o Starting pount</dt>
<dd>

<p>Start at the $node given.</p>

</dd>
<dt id="o-Callback">o Callback</dt>
<dd>

<p>If there&#39;s a <i>callback</i>, call it with $node as the first argument, and the options hashref as the second argument (which contains the potentially useful <i>_depth</i>, remember). This function must return true or false -- if false, it will block the next step:</p>

</dd>
<dt id="o-Daughters">o Daughters</dt>
<dd>

<p>If $node has any daughter nodes, increment <i>_depth</i>, and call $daughter-&gt;walk_down($options) for each daughter (in order, of course), where options_hashref is the same hashref it was called with. When this returns, decrements <i>_depth</i>.</p>

</dd>
<dt id="Callbackback">Callbackback</dt>
<dd>

<p>If there&#39;s a <i>callbackback</i>, call just it as with <i>callback</i> (but tossing out the return value). Note that <i>callback</i> returning false blocks traversal below $node, but doesn&#39;t block calling callbackback for $node. (Incidentally, in the unlikely case that $node has stopped being a node object, <i>callbackback</i> won&#39;t get called.)</p>

</dd>
<dt id="o-Return">o Return</dt>
<dd>

</dd>
</dl>

<p>$node-&gt;walk_down($options) is the way to recursively do things to a tree (if you start at the root) or part of a tree; if what you&#39;re doing is best done via pre-pre order traversal, use <i>callback</i>; if what you&#39;re doing is best done with post-order traversal, use <i>callbackback</i>. <i>walk_down()</i> is even the basis for plenty of the methods in this class. See the source code for examples both simple and horrific.</p>

<p>Note that if you don&#39;t specify <i>_depth</i>, it effectively defaults to 0. You should set it to scalar($node-&gt;ancestors) if you want <i>_depth</i> to reflect the true depth-in-the-tree for the nodes called, instead of just the depth below $node. (If $node is the root, there&#39;s difference, of course.)</p>

<p>And <b>by the way</b>, it&#39;s a bad idea to modify the tree from the callback. Unpredictable things may happen. I instead suggest having your callback add to a stack of things that need changing, and then, once <i>walk_down()</i> is all finished, changing those nodes from that stack.</p>

<p>Note that the existence of <i>walk_down()</i> doesn&#39;t mean you can&#39;t write you own special-use traversers.</p>

<h1 id="WHEN-AND-HOW-TO-DESTROY-THE-TREE">WHEN AND HOW TO DESTROY THE TREE</h1>

<p>It should be clear to you that if you&#39;ve built a big parse tree or something, and then you&#39;re finished with it, you should call $some_node-&gt;delete_tree on it if you want the memory back.</p>

<p>But consider this case: you&#39;ve got this tree:</p>

<pre><code><code>      A
    / | \
   B  C  D
   |     | \
   E     X  Y</code></code></pre>

<p>Let&#39;s say you decide you don&#39;t want D or any of its descendants in the tree, so you call D-&gt;unlink_from_mother. This does NOT automagically destroy the tree D-X-Y. Instead it merely splits the tree into two:</p>

<pre><code><code>     A                        D
    / \                      / \
   B   C                    X   Y
   |
   E</code></code></pre>

<p>To destroy D and its little tree, you have to explicitly call delete_tree on it.</p>

<p>Note, however, that if you call C-&gt;unlink_from_mother, and if you don&#39;t have a link to C anywhere, then it <b>does</b> magically go away. This is because nothing links to C -- whereas with the D-X-Y tree, D links to X and Y, and X and Y each link back to D. Note that calling C-&gt;delete_tree is harmless -- after all, a tree of only one node is still a tree.</p>

<p>So, this is a surefire way of getting rid of all $node&#39;s children and freeing up the memory associated with them and their descendants:</p>

<pre><code><code>  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$it</span> <span class="operator">(</span><span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">clear_daughters</span><span class="operator">)</span> <span class="operator">{</span> <span class="variable">$it</span><span class="operator">-&gt;</span><span class="variable">delete_tree</span> <span class="operator">}</span>
</code></code></pre>

<p>Just be sure not to do this:</p>

<pre><code><code>  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$it</span> <span class="operator">(</span><span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">daughters</span><span class="operator">)</span> <span class="operator">{</span> <span class="variable">$it</span><span class="operator">-&gt;</span><span class="variable">delete_tree</span> <span class="operator">}</span>
  <span class="variable">$node</span><span class="operator">-&gt;</span><span class="variable">clear_daughters</span><span class="operator">;</span>
</code></code></pre>

<p>That&#39;s bad; the first call to $_-&gt;delete_tree will climb to the root of $node&#39;s tree, and nuke the whole tree, not just the bits under $node. You might as well have just called $node-&gt;delete_tree. (Moreavor, once $node is dead, you can&#39;t call clear_daughters on it, so you&#39;ll get an error there.)</p>

<h1 id="BUG-REPORTS">BUG REPORTS</h1>

<p>If you find a bug in this library, report it to me as soon as possible, at the address listed in the MAINTAINER section, below. Please try to be as specific as possible about how you got the bug to occur.</p>

<h1 id="HELP-">HELP!</h1>

<p>If you develop a given routine for dealing with trees in some way, and use it a lot, then if you think it&#39;d be of use to anyone else, do email me about it; it might be helpful to others to include that routine, or something based on it, in a later version of this module.</p>

<p>It&#39;s occurred to me that you might like to (and might yourself develop routines to) draw trees in something other than ASCII art. If you do so -- say, for PostScript output, or for output interpretable by some external plotting program -- I&#39;d be most interested in the results.</p>

<h1 id="RAMBLINGS">RAMBLINGS</h1>

<p>This module uses &quot;strict&quot;, but I never wrote it with -w warnings in mind -- so if you use -w, do not be surprised if you see complaints from the guts of DAG_Node. As long as there is no way to turn off -w for a given module (instead of having to do it in every single subroutine with a &quot;local $^W&quot;), I&#39;m not going to change this. However, I do, at points, get bursts of ambition, and I try to fix code in DAG_Node that generates warnings, <i>as I come across them</i> -- which is only occasionally. Feel free to email me any patches for any such fixes you come up with, tho.</p>

<p>Currently I don&#39;t assume (or enforce) anything about the class membership of nodes being manipulated, other than by testing whether each one provides a method <a href="#is_node-">&quot;is_node()&quot;</a>, a la:</p>

<pre><code><code>  <span class="keyword">die</span> <span class="string">"Not a node!!!"</span> <span class="keyword">unless</span> <span class="variable">UNIVERSAL::can</span><span class="operator">(</span><span class="variable">$node</span><span class="operator">,</span> <span class="string">"is_node"</span><span class="operator">);</span>
</code></code></pre>

<p>So, as far as I&#39;m concerned, a given tree&#39;s nodes are free to belong to different classes, just so long as they provide/inherit <a href="#is_node-">&quot;is_node()&quot;</a>, the few methods that this class relies on to navigate the tree, and have the same internal object structure, or a superset of it. Presumably this would be the case for any object belonging to a class derived from <code><code>Tree::DAG_Node</code></code>, or belonging to <code><code>Tree::DAG_Node</code></code> itself.</p>

<p>When routines in this class access a node&#39;s &quot;mother&quot; attribute, or its &quot;daughters&quot; attribute, they (generally) do so directly (via $node-&gt;{&#39;mother&#39;}, etc.), for sake of efficiency. But classes derived from this class should probably do this instead thru a method (via $node-&gt;mother, etc.), for sake of portability, abstraction, and general goodness.</p>

<p>However, no routines in this class (aside from, necessarily, <i>_init()</i>, <i>_init_name()</i>, and <a href="#name-">&quot;name()&quot;</a>) access the &quot;name&quot; attribute directly; routines (like the various tree draw/dump methods) get the &quot;name&quot; value thru a call to $obj-&gt;name(). So if you want the object&#39;s name to not be a real attribute, but instead have it derived dynamically from some feature of the object (say, based on some of its other attributes, or based on its address), you can to override the <a href="#name-">&quot;name()&quot;</a> method, without causing problems. (Be sure to consider the case of $obj-&gt;name as a write method, as it&#39;s used in <i>/lol_to_tree($lol)</i> and <a href="#random_network-options-">&quot;random_network($options)&quot;</a>.)</p>

<h1 id="FAQ">FAQ</h1>

<h2 id="Which-is-the-best-tree-processing-module-">Which is the best tree processing module?</h2>

<p><code><code>Tree::DAG_Node</code></code>, as it happens. More details: <a href="#SEE-ALSO">&quot;SEE ALSO&quot;</a>.</p>

<h2 id="How-to-process-every-node-in-tree-">How to process every node in tree?</h2>

<p>See <a href="#walk_down-options-">&quot;walk_down($options)&quot;</a>. $options normally looks like, assuming we wish to pass in an arrayref to a stack, for example:</p>

<pre><code><code>        <span class="keyword">my</span><span class="operator">(</span><span class="variable">@stack</span><span class="operator">);</span>
        
        <span class="variable">$tree</span> <span class="operator">-&gt;</span> <span class="variable">walk_down</span>
        <span class="operator">(</span><span class="operator">{</span>
                <span class="string">callback</span> <span class="operator">=&gt;</span>
                <span class="keyword">sub</span><span class="variable">
                </span><span class="operator">{</span>
                        <span class="keyword">my</span><span class="operator">(</span><span class="variable">@node</span><span class="operator">,</span> <span class="variable">$options</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        
                        <span class="comment"># Process $node, using $options...</span>
        
                        <span class="keyword">push</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">$$options</span><span class="operator">{</span><span class="string">stack</span><span class="operator">}</span> <span class="operator">}</span><span class="operator">,</span> <span class="variable">$node</span> <span class="operator">-&gt;</span> <span class="variable">name</span><span class="operator">;</span>
        
                        <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span> <span class="comment"># Keep walking.</span>
                <span class="operator">},</span>
                <span class="string">_depth</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span>
                <span class="string">stack</span>  <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">@stack</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">);</span>
        
        <span class="comment"># Process @stack...</span>
</code></code></pre>

<h2 id="How-do-I-switch-from-Tree-to-Tree::DAG_Node-">How do I switch from Tree to Tree::DAG_Node?</h2>

<dl>

<dt id="o-The-nodes-name">o The node&#39;s name</dt>
<dd>

<p>In <code><code>Tree</code></code> you use $node -&gt; value and in <code><code>Tree::DAG_Node</code></code> it&#39;s $node -&gt; name.</p>

</dd>
<dt id="o-The-nodes-attributes">o The node&#39;s attributes</dt>
<dd>

<p>In <code><code>Tree</code></code> you use $node -&gt; meta and in <code><code>Tree::DAG_Node</code></code> it&#39;s $node -&gt; attributes.</p>

</dd>
</dl>

<h2 id="Are-there-techniques-for-processing-lists-of-nodes-">Are there techniques for processing lists of nodes?</h2>

<dl>

<dt id="o-Copy-the-daughter-list-and-change-it">o Copy the daughter list, and change it</dt>
<dd>

<pre><code><code>        <span class="variable">@them</span>    <span class="operator">=</span> <span class="variable">$mother</span><span class="operator">-&gt;</span><span class="variable">daughters</span><span class="operator">;</span>
        <span class="variable">@removed</span> <span class="operator">=</span> <span class="keyword">splice</span><span class="operator">(</span><span class="variable">@them</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="variable">@new_nodes</span><span class="operator">);</span>
        
        <span class="variable">$mother</span><span class="operator">-&gt;</span><span class="variable">set_daughters</span><span class="operator">(</span><span class="variable">@them</span><span class="operator">);</span>
</code></code></pre>

</dd>
<dt id="o-Select-a-sub-set-of-nodes">o Select a sub-set of nodes</dt>
<dd>

<pre><code><code>        <span class="variable">$mother</span><span class="operator">-&gt;</span><span class="variable">set_daughters</span>
        <span class="operator">(</span>
                <span class="keyword">grep</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">name</span> <span class="operator">=~</span> <span class="regex">/wanted/</span><span class="operator">,</span> <span class="variable">$mother</span><span class="operator">-&gt;</span><span class="variable">daughters</span><span class="operator">)</span>
        <span class="operator">);</span>
</code></code></pre>

</dd>
</dl>

<h2 id="Why-did-you-break-up-the-sections-of-methods-in-the-POD-">Why did you break up the sections of methods in the POD?</h2>

<p>Because I want to list the methods in alphabetical order.</p>

<h2 id="Why-did-you-move-the-POD-to-the-end-">Why did you move the POD to the end?</h2>

<p>Because the apostrophes in the text confused the syntax hightlighter in my editor UltraEdit.</p>

<h1 id="TODO">TODO</h1>

<dl>

<dt id="o-Copy-node-does-not-respect-the-no_attribute_copy-option">o Copy node does not respect the no_attribute_copy option</dt>
<dd>

<p>This is a bug.</p>

</dd>
</dl>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<dl>

<dt id="o-HTML::Element-HTML::Tree-and-HTML::TreeBuilder">o <a href="../../../lib/HTML/Element.html">HTML::Element</a>, <a href="../../../lib/HTML/Tree.html">HTML::Tree</a> and <a href="../../../lib/HTML/TreeBuilder.html">HTML::TreeBuilder</a></dt>
<dd>

<p>Sean is also the author of these modules.</p>

</dd>
<dt id="o-Tree">o <a href="../../../lib/HTML/Tree.html">Tree</a></dt>
<dd>

<p>Lightweight.</p>

</dd>
<dt id="o-Tree::Binary">o <a>Tree::Binary</a></dt>
<dd>

<p>Lightweight.</p>

</dd>
<dt id="o-Tree::DAG_Node::Persist">o <a>Tree::DAG_Node::Persist</a></dt>
<dd>

<p>Lightweight.</p>

</dd>
<dt id="o-Tree::Persist">o <a>Tree::Persist</a></dt>
<dd>

<p>Lightweight.</p>

</dd>
<dt id="o-Forest">o <a>Forest</a></dt>
<dd>

<p>Uses <a href="../../../lib/Moose.html">Moose</a>.</p>

</dd>
</dl>

<p><code><code>Tree::DAG_Node</code></code> itself is also lightweight.</p>

<h1 id="REFERENCES">REFERENCES</h1>

<p>Wirth, Niklaus. 1976. <i>Algorithms + Data Structures = Programs</i> Prentice-Hall, Englewood Cliffs, NJ.</p>

<p>Knuth, Donald Ervin. 1997. <i>Art of Computer Programming, Volume 1, Third Edition: Fundamental Algorithms</i>. Addison-Wesley, Reading, MA.</p>

<p>Wirth&#39;s classic, currently and lamentably out of print, has a good section on trees. I find it clearer than Knuth&#39;s (if not quite as encyclopedic), probably because Wirth&#39;s example code is in a block-structured high-level language (basically Pascal), instead of in assembler (MIX).</p>

<p>Until some kind publisher brings out a new printing of Wirth&#39;s book, try poking around used bookstores (or <code><code>www.abebooks.com</code></code>) for a copy. I think it was also republished in the 1980s under the title <i>Algorithms and Data Structures</i>, and in a German edition called <i>Algorithmen und Datenstrukturen</i>. (That is, I&#39;m sure books by Knuth were published under those titles, but I&#39;m <i>assuming</i> that they&#39;re just later printings/editions of <i>Algorithms + Data Structures = Programs</i>.)</p>

<h1 id="MACHINE-READABLE-CHANGE-LOG">MACHINE-READABLE CHANGE LOG</h1>

<p>The file CHANGES was converted into Changelog.ini by <a>Module::Metadata::Changes</a>.</p>

<h1 id="SUPPORT">SUPPORT</h1>

<p>Email the author, or log a bug on RT:</p>

<p><a href="https://rt.cpan.org/Public/Dist/Display.html?Name=Tree::DAG_Node">https://rt.cpan.org/Public/Dist/Display.html?Name=Tree::DAG_Node</a>.</p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>The code to print the tree, in tree2string(), was adapted from <a>Forest::Tree::Writer::ASCIIWithBranches</a>.</p>

<h1 id="MAINTAINER">MAINTAINER</h1>

<p>David Hand, <code><code>&lt;cogent@cpan.org&gt;</code></code> up to V 1.06.</p>

<p>Ron Savage <code><code>&lt;rsavage@cpan.org&gt;</code></code> from V 1.07.</p>

<p>In this POD, usage of &#39;I&#39; refers to Sean, up until V 1.07.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Sean M. Burke, <code><code>&lt;sburke@cpan.org&gt;</code></code></p>

<h1 id="COPYRIGHT-LICENSE-AND-DISCLAIMER">COPYRIGHT, LICENSE, AND DISCLAIMER</h1>

<p>Copyright 1998-2001, 2004, 2007 by Sean M. Burke and David Hand.</p>

<p>This program is free software. It is released under the Artistic License 2.0. See <a href="http://opensource.org/licenses/Artistic-2.0">http://opensource.org/licenses/Artistic-2.0</a>.</p>

<p>This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</p>


</body>

</html>


