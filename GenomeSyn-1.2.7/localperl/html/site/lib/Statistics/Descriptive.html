<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#Sparse-Methods">Sparse Methods</a></li>
      <li><a href="#Full-Methods">Full Methods</a></li>
    </ul>
  </li>
  <li><a href="#REPORTING-ERRORS">REPORTING ERRORS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#CONTRIBUTORS">CONTRIBUTORS</a></li>
  <li><a href="#REFERENCES">REFERENCES</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
  <li><a href="#LICENSE">LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Statistics::Descriptive - Module of basic descriptive statistical functions.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Statistics::Descriptive</span><span class="operator">;</span>
  <span class="variable">$stat</span> <span class="operator">=</span> <span class="variable">Statistics::Descriptive::Full</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
  <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">add_data</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">);</span> <span class="variable">$mean</span> <span class="operator">=</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">mean</span><span class="operator">();</span>
  <span class="variable">$var</span>  <span class="operator">=</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">variance</span><span class="operator">();</span>
  <span class="variable">$tm</span>   <span class="operator">=</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">trimmed_mean</span><span class="operator">(</span><span class="number">.25</span><span class="operator">);</span>
  <span class="variable">$Statistics::Descriptive::Tolerance</span> <span class="operator">=</span> <span class="number">1e-10</span><span class="operator">;</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides basic functions used in descriptive statistics. It has an object oriented design and supports two different types of data storage and calculation objects: sparse and full. With the sparse method, none of the data is stored and only a few statistical measures are available. Using the full method, the entire data set is retained and additional functions are available.</p>

<p>Whenever a division by zero may occur, the denominator is checked to be greater than the value <code><code>$Statistics::Descriptive::Tolerance</code></code>, which defaults to 0.0. You may want to change this value to some small positive value such as 1e-24 in order to obtain error messages in case of very small denominators.</p>

<p>Many of the methods (both Sparse and Full) cache values so that subsequent calls with the same arguments are faster.</p>

<h1 id="METHODS">METHODS</h1>

<h2 id="Sparse-Methods">Sparse Methods</h2>

<dl>

<dt id="stat-Statistics::Descriptive::Sparse-new-">$stat = Statistics::Descriptive::Sparse-&gt;new();</dt>
<dd>

<p>Create a new sparse statistics object.</p>

</dd>
<dt id="stat-clear-">$stat-&gt;clear();</dt>
<dd>

<p>Effectively the same as</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">ref</span><span class="operator">(</span><span class="variable">$stat</span><span class="operator">);</span>
  <span class="keyword">undef</span> <span class="variable">$stat</span><span class="operator">;</span>
  <span class="variable">$stat</span> <span class="operator">=</span> <span class="variable">new</span> <span class="variable">$class</span><span class="operator">;</span>
</code></code></pre>

<p>except more efficient.</p>

</dd>
<dt id="stat-add_data-1-2-3-">$stat-&gt;add_data(1,2,3);</dt>
<dd>

<p>Adds data to the statistics variable. The cached statistical values are updated automatically.</p>

</dd>
<dt id="stat-count-">$stat-&gt;count();</dt>
<dd>

<p>Returns the number of data items.</p>

</dd>
<dt id="stat-mean-">$stat-&gt;mean();</dt>
<dd>

<p>Returns the mean of the data.</p>

</dd>
<dt id="stat-sum-">$stat-&gt;sum();</dt>
<dd>

<p>Returns the sum of the data.</p>

</dd>
<dt id="stat-variance-">$stat-&gt;variance();</dt>
<dd>

<p>Returns the variance of the data. Division by n-1 is used.</p>

</dd>
<dt id="stat-standard_deviation-">$stat-&gt;standard_deviation();</dt>
<dd>

<p>Returns the standard deviation of the data. Division by n-1 is used.</p>

</dd>
<dt id="stat-min-">$stat-&gt;min();</dt>
<dd>

<p>Returns the minimum value of the data set.</p>

</dd>
<dt id="stat-mindex-">$stat-&gt;mindex();</dt>
<dd>

<p>Returns the index of the minimum value of the data set.</p>

</dd>
<dt id="stat-max-">$stat-&gt;max();</dt>
<dd>

<p>Returns the maximum value of the data set.</p>

</dd>
<dt id="stat-maxdex-">$stat-&gt;maxdex();</dt>
<dd>

<p>Returns the index of the maximum value of the data set.</p>

</dd>
<dt id="stat-sample_range-">$stat-&gt;sample_range();</dt>
<dd>

<p>Returns the sample range (max - min) of the data set.</p>

</dd>
</dl>

<h2 id="Full-Methods">Full Methods</h2>

<p>Similar to the Sparse Methods above, any Full Method that is called caches the current result so that it doesn&#39;t have to be recalculated. In some cases, several values can be cached at the same time.</p>

<dl>

<dt id="stat-Statistics::Descriptive::Full-new-">$stat = Statistics::Descriptive::Full-&gt;new();</dt>
<dd>

<p>Create a new statistics object that inherits from Statistics::Descriptive::Sparse so that it contains all the methods described above.</p>

</dd>
<dt id="stat-add_data-1-2-4-5-">$stat-&gt;add_data(1,2,4,5);</dt>
<dd>

<p>Adds data to the statistics variable. All of the sparse statistical values are updated and cached. Cached values from Full methods are deleted since they are no longer valid.</p>

<p><i>Note: Calling add_data with an empty array will delete all of your Full method cached values! Cached values for the sparse methods are not changed</i></p>

</dd>
<dt id="stat-add_data_with_samples-1-10-2-20-3-30-">$stat-&gt;add_data_with_samples([{1 =&gt; 10}, {2 =&gt; 20}, {3 =&gt; 30},]);</dt>
<dd>

<p>Add data to the statistics variable and set the number of samples each value has been built with. The data is the key of each element of the input array ref, while the value is the number of samples: [{data1 =&gt; smaples1}, {data2 =&gt; samples2}, ...].</p>

<p><b>NOTE:</b> The number of samples is only used by the smoothing function and is ignored otherwise. It is not equivalent to repeat count. In order to repeat a certain datum more than one time call add_data() like this:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$value</span> <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$repeat_count</span> <span class="operator">=</span> <span class="number">10</span><span class="operator">;</span>
    <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">add_data</span><span class="operator">(</span>
        <span class="operator">[</span> <span class="operator">(</span><span class="variable">$value</span><span class="operator">)</span> <span class="operator">x</span> <span class="variable">$repeat_count</span> <span class="operator">]</span>
    <span class="operator">);</span>
</code></code></pre>

</dd>
<dt id="stat-get_data-">$stat-&gt;get_data();</dt>
<dd>

<p>Returns a copy of the data array.</p>

</dd>
<dt id="stat-get_data_without_outliers-">$stat-&gt;get_data_without_outliers();</dt>
<dd>

<p>Returns a copy of the data array without outliers. The number minimum of samples to apply the outlier filtering is <code><code>$Statistics::Descriptive::Min_samples_number</code></code>, 4 by default.</p>

<p>A function to detect outliers need to be defined (see <code><code>set_outlier_filter</code></code>), otherwise the function will return an undef value.</p>

<p>The filtering will act only on the most extreme value of the data set (i.e.: value with the highest absolute standard deviation from the mean).</p>

<p>If there is the need to remove more than one outlier, the filtering need to be re-run for the next most extreme value with the initial outlier removed.</p>

<p>This is not always needed since the test (for example Grubb&#39;s test) usually can only detect the most exreme value. If there is more than one extreme case in a set, then the standard deviation will be high enough to make neither case an outlier.</p>

</dd>
<dt id="stat-set_outlier_filter-code_ref-">$stat-&gt;set_outlier_filter($code_ref);</dt>
<dd>

<p>Set the function to filter out the outlier.</p>

<p><code><code>$code_ref</code></code> is the reference to the subroutine implementing the filtering function.</p>

<p>Returns <code><code>undef</code></code> for invalid values of <code><code>$code_ref</code></code> (i.e.: not defined or not a code reference), <code><code>1</code></code> otherwise.</p>

<ul>

<li><p>Example #1: Undefined code reference</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$stat</span> <span class="operator">=</span> <span class="variable">Statistics::Descriptive::Full</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
    <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">add_data</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">5</span><span class="operator">);</span>
    
    <span class="keyword">print</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">set_outlier_filter</span><span class="operator">();</span> <span class="comment"># =&gt; undef</span>
</code></code></pre>

</li>
<li><p>Example #2: Valid code reference</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> outlier_filter </span><span class="operator">{</span> <span class="keyword">return</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">&gt;</span> <span class="number">1</span><span class="operator">;</span> <span class="operator">}</span>
    
    <span class="keyword">my</span> <span class="variable">$stat</span> <span class="operator">=</span> <span class="variable">Statistics::Descriptive::Full</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
    <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">add_data</span><span class="operator">(</span> <span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">100</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="operator">);</span>
    
    <span class="keyword">print</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">set_outlier_filter</span><span class="operator">(</span> <span class="operator">\&amp;</span><span class="variable">outlier_filter</span> <span class="operator">);</span> <span class="comment"># =&gt; 1</span>
    <span class="keyword">my</span> <span class="variable">@filtered_data</span> <span class="operator">=</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">get_data_without_outliers</span><span class="operator">();</span>
    <span class="comment"># @filtered_data is (1, 1, 1, 1)</span>
</code></code></pre>

<p>In this example the series is really simple and the outlier filter function as well. For more complex series the outlier filter function might be more complex (see Grubbs&#39; test for outliers).</p>

<p>The outlier filter function will receive as first parameter the Statistics::Descriptive::Full object, as second the value of the candidate outlier. Having the object in the function might be useful for complex filters where statistics property are needed (again see Grubbs&#39; test for outlier).</p>

</li>
</ul>

</dd>
<dt id="stat-set_smoother-method-exponential-coeff-0-">$stat-&gt;set_smoother({ method =&gt; &#39;exponential&#39;, coeff =&gt; 0, });</dt>
<dd>

<p>Set the method used to smooth the data and the smoothing coefficient. See <code><code>Statistics::Smoother</code></code> for more details.</p>

</dd>
<dt id="stat-get_smoothed_data-">$stat-&gt;get_smoothed_data();</dt>
<dd>

<p>Returns a copy of the smoothed data array.</p>

<p>The smoothing method and coefficient need to be defined (see <code><code>set_smoother</code></code>), otherwise the function will return an undef value.</p>

</dd>
<dt id="stat-sort_data-">$stat-&gt;sort_data();</dt>
<dd>

<p>Sort the stored data and update the mindex and maxdex methods. This method uses perl&#39;s internal sort.</p>

</dd>
<dt id="stat-presorted-1-">$stat-&gt;presorted(1);</dt>
<dd>

</dd>
<dt id="stat-presorted-">$stat-&gt;presorted();</dt>
<dd>

<p>If called with a non-zero argument, this method sets a flag that says the data is already sorted and need not be sorted again. Since some of the methods in this class require sorted data, this saves some time. If you supply sorted data to the object, call this method to prevent the data from being sorted again. The flag is cleared whenever add_data is called. Calling the method without an argument returns the value of the flag.</p>

</dd>
<dt id="stat-skewness-">$stat-&gt;skewness();</dt>
<dd>

<p>Returns the skewness of the data. A value of zero is no skew, negative is a left skewed tail, positive is a right skewed tail. This is consistent with Excel.</p>

</dd>
<dt id="stat-kurtosis-">$stat-&gt;kurtosis();</dt>
<dd>

<p>Returns the kurtosis of the data. Positive is peaked, negative is flattened.</p>

</dd>
<dt id="x-stat-percentile-25-">$x = $stat-&gt;percentile(25);</dt>
<dd>

</dd>
<dt id="x-index-stat-percentile-25-">($x, $index) = $stat-&gt;percentile(25);</dt>
<dd>

<p>Sorts the data and returns the value that corresponds to the percentile as defined in RFC2330:</p>

<ul>

<li><p>For example, given the 6 measurements:</p>

<p>-2, 7, 7, 4, 18, -5</p>

<p>Then F(-8) = 0, F(-5) = 1/6, F(-5.0001) = 0, F(-4.999) = 1/6, F(7) = 5/6, F(18) = 1, F(239) = 1.</p>

<p>Note that we can recover the different measured values and how many times each occurred from F(x) -- no information regarding the range in values is lost. Summarizing measurements using histograms, on the other hand, in general loses information about the different values observed, so the EDF is preferred.</p>

<p>Using either the EDF or a histogram, however, we do lose information regarding the order in which the values were observed. Whether this loss is potentially significant will depend on the metric being measured.</p>

<p>We will use the term &quot;percentile&quot; to refer to the smallest value of x for which F(x) &gt;= a given percentage. So the 50th percentile of the example above is 4, since F(4) = 3/6 = 50%; the 25th percentile is -2, since F(-5) = 1/6 &lt; 25%, and F(-2) = 2/6 &gt;= 25%; the 100th percentile is 18; and the 0th percentile is -infinity, as is the 15th percentile, which for ease of handling and backward compatibility is returned as undef() by the function.</p>

<p>Care must be taken when using percentiles to summarize a sample, because they can lend an unwarranted appearance of more precision than is really available. Any such summary must include the sample size N, because any percentile difference finer than 1/N is below the resolution of the sample.</p>

</li>
</ul>

<p>(Taken from: <i>RFC2330 - Framework for IP Performance Metrics</i>, Section 11.3. Defining Statistical Distributions. RFC2330 is available from: <a href="http://www.ietf.org/rfc/rfc2330.txt">http://www.ietf.org/rfc/rfc2330.txt</a> .)</p>

<p>If the percentile method is called in a list context then it will also return the index of the percentile.</p>

</dd>
<dt id="x-stat-quantile-Type-">$x = $stat-&gt;quantile($Type);</dt>
<dd>

<p>Sorts the data and returns estimates of underlying distribution quantiles based on one or two order statistics from the supplied elements.</p>

<p>This method use the same algorithm as Excel and R language (quantile <b>type 7</b>).</p>

<p>The generic function quantile produces sample quantiles corresponding to the given probabilities.</p>

<p><b>$Type</b> is an integer value between 0 to 4 :</p>

<pre><code><code>  0 =&gt; zero quartile (Q0) : minimal value
  1 =&gt; first quartile (Q1) : lower quartile = lowest cut off (25%) of data = 25th percentile
  2 =&gt; second quartile (Q2) : median = it cuts data set in half = 50th percentile
  3 =&gt; third quartile (Q3) : upper quartile = highest cut off (25%) of data, or lowest 75% = 75th percentile
  4 =&gt; fourth quartile (Q4) : maximal value</code></code></pre>

<p>Exemple :</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">@data</span> <span class="operator">=</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">10</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$stat</span> <span class="operator">=</span> <span class="variable">Statistics::Descriptive::Full</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
  <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">add_data</span><span class="operator">(</span><span class="variable">@data</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">quantile</span><span class="operator">(</span><span class="number">0</span><span class="operator">);</span> <span class="comment"># =&gt; 1</span>
  <span class="keyword">print</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">quantile</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span> <span class="comment"># =&gt; 3.25</span>
  <span class="keyword">print</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">quantile</span><span class="operator">(</span><span class="number">2</span><span class="operator">);</span> <span class="comment"># =&gt; 5.5</span>
  <span class="keyword">print</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">quantile</span><span class="operator">(</span><span class="number">3</span><span class="operator">);</span> <span class="comment"># =&gt; 7.75</span>
  <span class="keyword">print</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">quantile</span><span class="operator">(</span><span class="number">4</span><span class="operator">);</span> <span class="comment"># =&gt; 10</span>
</code></code></pre>

</dd>
<dt id="stat-median-">$stat-&gt;median();</dt>
<dd>

<p>Sorts the data and returns the median value of the data.</p>

</dd>
<dt id="stat-harmonic_mean-">$stat-&gt;harmonic_mean();</dt>
<dd>

<p>Returns the harmonic mean of the data. Since the mean is undefined if any of the data are zero or if the sum of the reciprocals is zero, it will return undef for both of those cases.</p>

</dd>
<dt id="stat-geometric_mean-">$stat-&gt;geometric_mean();</dt>
<dd>

<p>Returns the geometric mean of the data.</p>

</dd>
<dt id="my-mode-stat-mode-">my $mode = $stat-&gt;mode();</dt>
<dd>

<p>Returns the mode of the data. The mode is the most commonly occuring datum. See <a href="http://en.wikipedia.org/wiki/Mode_%28statistics%29">http://en.wikipedia.org/wiki/Mode_%28statistics%29</a> . If all values occur only once, then mode() will return undef.</p>

</dd>
<dt id="stat-trimmed_mean-ltrim-utrim-">$stat-&gt;trimmed_mean(ltrim[,utrim]);</dt>
<dd>

<p><code><code>trimmed_mean(ltrim)</code></code> returns the mean with a fraction <code><code>ltrim</code></code> of entries at each end dropped. <code><code>trimmed_mean(ltrim,utrim)</code></code> returns the mean after a fraction <code><code>ltrim</code></code> has been removed from the lower end of the data and a fraction <code><code>utrim</code></code> has been removed from the upper end of the data. This method sorts the data before beginning to analyze it.</p>

<p>All calls to trimmed_mean() are cached so that they don&#39;t have to be calculated a second time.</p>

</dd>
<dt id="stat-frequency_distribution_ref-partitions-">$stat-&gt;frequency_distribution_ref($partitions);</dt>
<dd>

</dd>
<dt id="stat-frequency_distribution_ref-bins-">$stat-&gt;frequency_distribution_ref(\@bins);</dt>
<dd>

</dd>
<dt id="stat-frequency_distribution_ref-">$stat-&gt;frequency_distribution_ref();</dt>
<dd>

<p><code><code>frequency_distribution_ref($partitions)</code></code> slices the data into <code><code>$partition</code></code> sets (where $partition is greater than 1) and counts the number of items that fall into each partition. It returns a reference to a hash where the keys are the numerical values of the partitions used. The minimum value of the data set is not a key and the maximum value of the data set is always a key. The number of entries for a particular partition key are the number of items which are greater than the previous partition key and less then or equal to the current partition key. As an example,</p>

<pre><code><code>   <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">add_data</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span><span class="number">1.5</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">2.5</span><span class="operator">,</span><span class="number">3</span><span class="operator">,</span><span class="number">3.5</span><span class="operator">,</span><span class="number">4</span><span class="operator">);</span>
   <span class="variable">$f</span> <span class="operator">=</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">frequency_distribution_ref</span><span class="operator">(</span><span class="number">2</span><span class="operator">);</span>
   <span class="keyword">for</span> <span class="operator">(</span><span class="keyword">sort</span> <span class="operator">{</span><span class="variable">$a</span> <span class="operator">&lt;=&gt;</span> <span class="variable">$b</span><span class="operator">}</span> <span class="keyword">keys</span> <span class="variable">%$f</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"key = </span><span class="variable">$_</span><span class="string">, count = </span><span class="variable">$f</span><span class="string">-&gt;{</span><span class="variable">$_</span><span class="string">}\n"</span><span class="operator">;</span>
   <span class="operator">}</span>
</code></code></pre>

<p>prints</p>

<pre><code><code>   key = 2.5, count = 4
   key = 4, count = 3</code></code></pre>

<p>since there are four items less than or equal to 2.5, and 3 items greater than 2.5 and less than 4.</p>

<p><code><code>frequency_distribution_refs(\@bins)</code></code> provides the bins that are to be used for the distribution. This allows for non-uniform distributions as well as trimmed or sample distributions to be found. <code><code>@bins</code></code> must be monotonic and contain at least one element. Note that unless the set of bins contains the range that the total counts returned will be less than the sample size.</p>

<p>Calling <code><code>frequency_distribution_ref()</code></code> with no arguments returns the last distribution calculated, if such exists.</p>

</dd>
<dt id="my-hash-stat-frequency_distribution-partitions-">my %hash = $stat-&gt;frequency_distribution($partitions);</dt>
<dd>

</dd>
<dt id="my-hash-stat-frequency_distribution-bins-">my %hash = $stat-&gt;frequency_distribution(\@bins);</dt>
<dd>

</dd>
<dt id="my-hash-stat-frequency_distribution-">my %hash = $stat-&gt;frequency_distribution();</dt>
<dd>

<p>Same as <code><code>frequency_distribution_ref()</code></code> except that returns the hash clobbered into the return list. Kept for compatibility reasons with previous versions of Statistics::Descriptive and using it is discouraged.</p>

</dd>
<dt id="stat-least_squares_fit-">$stat-&gt;least_squares_fit();</dt>
<dd>

</dd>
<dt id="stat-least_squares_fit-x-">$stat-&gt;least_squares_fit(@x);</dt>
<dd>

<p><code><code>least_squares_fit()</code></code> performs a least squares fit on the data, assuming a domain of <code><code>@x</code></code> or a default of 1..$stat-&gt;count(). It returns an array of four elements <code><code>($q, $m, $r, $rms)</code></code> where</p>

<dl>

<dt id="q-and-m"><code><code>$q and $m</code></code></dt>
<dd>

<p>satisfy the equation C($y = $m*$x + $q).</p>

</dd>
<dt id="r"><code><code>$r</code></code></dt>
<dd>

<p>is the Pearson linear correlation cofficient.</p>

</dd>
<dt id="rms"><code><code>$rms</code></code></dt>
<dd>

<p>is the root-mean-square error.</p>

</dd>
</dl>

<p>If case of error or division by zero, the empty list is returned.</p>

<p>The array that is returned can be &quot;coerced&quot; into a hash structure by doing the following:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">%hash</span> <span class="operator">=</span> <span class="operator">();</span>
  <span class="variable">@hash</span><span class="operator">{</span><span class="string">'q'</span><span class="operator">,</span> <span class="string">'m'</span><span class="operator">,</span> <span class="string">'r'</span><span class="operator">,</span> <span class="string">'err'</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$stat</span><span class="operator">-&gt;</span><span class="variable">least_squares_fit</span><span class="operator">();</span>
</code></code></pre>

<p>Because calling <code><code>least_squares_fit()</code></code> with no arguments defaults to using the current range, there is no caching of the results.</p>

</dd>
</dl>

<h1 id="REPORTING-ERRORS">REPORTING ERRORS</h1>

<p>I read my email frequently, but since adopting this module I&#39;ve added 2 children and 1 dog to my family, so please be patient about my response times. When reporting errors, please include the following to help me out:</p>

<ul>

<li><p>Your version of perl. This can be obtained by typing perl <code><code>-v</code></code> at the command line.</p>

</li>
<li><p>Which version of Statistics::Descriptive you&#39;re using. As you can see below, I do make mistakes. Unfortunately for me, right now there are thousands of CD&#39;s with the version of this module with the bugs in it. Fortunately for you, I&#39;m a very patient module maintainer.</p>

</li>
<li><p>Details about what the error is. Try to narrow down the scope of the problem and send me code that I can run to verify and track it down.</p>

</li>
</ul>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Current maintainer:</p>

<p>Shlomi Fish, <a href="http://www.shlomifish.org/">http://www.shlomifish.org/</a> , <code><code>shlomif@cpan.org</code></code></p>

<p>Previously:</p>

<p>Colin Kuskie</p>

<p>My email address can be found at http://www.perl.com under Who&#39;s Who or at: https://metacpan.org/author/COLINK .</p>

<h1 id="CONTRIBUTORS">CONTRIBUTORS</h1>

<p>Fabio Ponciroli &amp; Adzuna Ltd. team (outliers handling)</p>

<h1 id="REFERENCES">REFERENCES</h1>

<p>RFC2330, Framework for IP Performance Metrics</p>

<p>The Art of Computer Programming, Volume 2, Donald Knuth.</p>

<p>Handbook of Mathematica Functions, Milton Abramowitz and Irene Stegun.</p>

<p>Probability and Statistics for Engineering and the Sciences, Jay Devore.</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 1997,1998 Colin Kuskie. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>Copyright (c) 1998 Andrea Spinelli. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>Copyright (c) 1994,1995 Jason Kastner. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1 id="LICENSE">LICENSE</h1>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>


</body>

</html>


