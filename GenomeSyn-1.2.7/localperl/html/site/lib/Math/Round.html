<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a></li>
  <li><a href="#VARIABLE">VARIABLE</a></li>
  <li><a href="#STANDARD-FLOATING-POINT-DISCLAIMER">STANDARD FLOATING-POINT DISCLAIMER</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Math::Round - Perl extension for rounding numbers</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Math::Round</span> <span class="string">qw(...those desired... or :all)</span><span class="operator">;</span>
  
  <span class="variable">$rounded</span> <span class="operator">=</span> <span class="variable">round</span><span class="operator">(</span><span class="variable">$scalar</span><span class="operator">);</span>
  <span class="variable">@rounded</span> <span class="operator">=</span> <span class="variable">round</span><span class="operator">(</span><span class="variable">LIST</span><span class="operator">...);</span>
  <span class="variable">$rounded</span> <span class="operator">=</span> <span class="variable">nearest</span><span class="operator">(</span><span class="variable">$target</span><span class="operator">,</span> <span class="variable">$scalar</span><span class="operator">);</span>
  <span class="variable">@rounded</span> <span class="operator">=</span> <span class="variable">nearest</span><span class="operator">(</span><span class="variable">$target</span><span class="operator">,</span> <span class="variable">LIST</span><span class="operator">...);</span>
  
  <span class="comment"># and other functions as described below</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p><b>Math::Round</b> supplies functions that will round numbers in different ways. The functions <b>round</b> and <b>nearest</b> are exported by default; others are available as described below. &quot;use ... qw(:all)&quot; exports all functions.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<dl>

<dt id="round-LIST"><b>round</b> LIST</dt>
<dd>

<p>Rounds the number(s) to the nearest integer. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are halfway between two integers are rounded &quot;to infinity&quot;; i.e., positive values are rounded up (e.g., 2.5 becomes 3) and negative values down (e.g., -2.5 becomes -3).</p>

</dd>
<dt id="round_even-LIST"><b>round_even</b> LIST</dt>
<dd>

<p>Rounds the number(s) to the nearest integer. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are halfway between two integers are rounded to the nearest even number; e.g., 2.5 becomes 2, 3.5 becomes 4, and -2.5 becomes -2.</p>

</dd>
<dt id="round_odd-LIST"><b>round_odd</b> LIST</dt>
<dd>

<p>Rounds the number(s) to the nearest integer. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are halfway between two integers are rounded to the nearest odd number; e.g., 3.5 becomes 3, 4.5 becomes 5, and -3.5 becomes -3.</p>

</dd>
<dt id="round_rand-LIST"><b>round_rand</b> LIST</dt>
<dd>

<p>Rounds the number(s) to the nearest integer. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are halfway between two integers are rounded up or down in a random fashion. For example, in a large number of trials, 2.5 will become 2 half the time and 3 half the time.</p>

</dd>
<dt id="nearest-TARGET-LIST"><b>nearest</b> TARGET, LIST</dt>
<dd>

<p>Rounds the number(s) to the nearest multiple of the target value. TARGET must be positive. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are halfway between two multiples of the target will be rounded to infinity. For example:</p>

<pre><code><code>  nearest(10, 44)    yields  40
  nearest(10, 46)            50
  nearest(10, 45)            50
  nearest(25, 328)          325
  nearest(.1, 4.567)          4.6
  nearest(10, -45)          -50</code></code></pre>

</dd>
<dt id="nearest_ceil-TARGET-LIST"><b>nearest_ceil</b> TARGET, LIST</dt>
<dd>

<p>Rounds the number(s) to the nearest multiple of the target value. TARGET must be positive. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are halfway between two multiples of the target will be rounded to the ceiling, i.e. the next algebraically higher multiple. For example:</p>

<pre><code><code>  nearest_ceil(10, 44)    yields  40
  nearest_ceil(10, 45)            50
  nearest_ceil(10, -45)          -40</code></code></pre>

</dd>
<dt id="nearest_floor-TARGET-LIST"><b>nearest_floor</b> TARGET, LIST</dt>
<dd>

<p>Rounds the number(s) to the nearest multiple of the target value. TARGET must be positive. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are halfway between two multiples of the target will be rounded to the floor, i.e. the next algebraically lower multiple. For example:</p>

<pre><code><code>  nearest_floor(10, 44)    yields  40
  nearest_floor(10, 45)            40
  nearest_floor(10, -45)          -50</code></code></pre>

</dd>
<dt id="nearest_rand-TARGET-LIST"><b>nearest_rand</b> TARGET, LIST</dt>
<dd>

<p>Rounds the number(s) to the nearest multiple of the target value. TARGET must be positive. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are halfway between two multiples of the target will be rounded up or down in a random fashion. For example, in a large number of trials, <code><code>nearest(10, 45)</code></code> will yield 40 half the time and 50 half the time.</p>

</dd>
<dt id="nlowmult-TARGET-LIST"><b>nlowmult</b> TARGET, LIST</dt>
<dd>

<p>Returns the next lower multiple of the number(s) in LIST. TARGET must be positive. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are between two multiples of the target will be adjusted to the nearest multiples of LIST that are algebraically lower. For example:</p>

<pre><code><code>  nlowmult(10, 44)    yields  40
  nlowmult(10, 46)            40
  nlowmult(25, 328)          325
  nlowmult(.1, 4.567)          4.5
  nlowmult(10, -41)          -50</code></code></pre>

</dd>
<dt id="nhimult-TARGET-LIST"><b>nhimult</b> TARGET, LIST</dt>
<dd>

<p>Returns the next higher multiple of the number(s) in LIST. TARGET must be positive. In scalar context, returns a single value; in list context, returns a list of values. Numbers that are between two multiples of the target will be adjusted to the nearest multiples of LIST that are algebraically higher. For example:</p>

<pre><code><code>  nhimult(10, 44)    yields  50
  nhimult(10, 46)            50
  nhimult(25, 328)          350
  nhimult(.1, 4.512)          4.6
  nhimult(10, -49)          -40</code></code></pre>

</dd>
</dl>

<h1 id="VARIABLE">VARIABLE</h1>

<p>The variable <b>$Math::Round::half</b> is used by most routines in this module. Its value is very slightly larger than 0.5, for reasons explained below. If you find that your application does not deliver the expected results, you may reset this variable at will.</p>

<h1 id="STANDARD-FLOATING-POINT-DISCLAIMER">STANDARD FLOATING-POINT DISCLAIMER</h1>

<p>Floating-point numbers are, of course, a rational subset of the real numbers, so calculations with them are not always exact. Numbers that are supposed to be halfway between two others may surprise you; for instance, 0.85 may not be exactly halfway between 0.8 and 0.9, and (0.75 - 0.7) may not be the same as (0.85 - 0.8).</p>

<p>In order to give more predictable results, these routines use a value for one-half that is slightly larger than 0.5. Nevertheless, if the numbers to be rounded are stored as floating-point, they will be subject, as usual, to the mercies of your hardware, your C compiler, etc.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Math::Round was written by Geoffrey Rommel &lt;GROMMEL@cpan.org&gt; in October 2000.</p>


</body>

</html>


